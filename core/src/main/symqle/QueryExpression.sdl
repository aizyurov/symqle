#############################################################################
#
#   Copyright 2010-2013 Alexander Izyurov
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.package org.symqle.common;
#
##############################################################################

#### QueryExpressionBody ###

# There are 2 flavors of QueryExpressionBody: multicolumn and scalar, the latter is QueryExpressionBodyScalar
# Scalar supports the whole hierarchy of QueryTerm, QueryPrimary, QuerySpecification
# Multicolumn QueryExpressionBody is derived only from QuerySpecification


public interface QueryExpressionBody<T> : QueryBuilder<T> {}

# see QueryBase.sdl, Where.sdl

<T> QueryExpressionBody<T> ::=
    qs:QuerySpecification<T> :: implicit {}
|
    qebs:QueryExpressionBodyScalar<T> :: implicit {}
;

public interface QueryExpressionBodyScalar<T> extends Scalar<T> : QueryBuilder<T> {}
public class AbstractQueryExpressionBodyScalar<T> implements QueryExpressionBodyScalar<T> {}

<T> QueryExpressionBodyScalar<T> ::=
    qt:QueryTerm<T> :: implicit {}
|
    /**
     * Creates a AbstractQueryExpressionBodyScalar
     * representing {@code (QueryExpressionBodyScalar)this UNION ALL other}.
     * @param other second argument of UNION ALL
     * @return new AbstractQueryExpressionBodyScalar
     */
    qe:QueryExpressionBodyScalar<T> UNION ALL other:QueryTerm<T> ::
        AbstractQueryExpressionBodyScalar<T> unionAll {
            public QueryBuilder<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                return new UnionExceptBuilder<T>(qe, other) {
                    @Override
                    protected SqlBuilder composeSql(final Dialect dialect, final SqlBuilder left, final SqlBuilder right) {
                        return dialect.QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_UNION_ALL_QueryTerm(left, right);
                    }
                }
                .build(context);
            }
        }
|
    /**
     * Creates a AbstractQueryExpressionBodyScalar
     * representing {@code (QueryExpressionBodyScalar)this UNION DISTINCT other}.
     * @param other second argument of UNION DISTINCT
     * @return new AbstractQueryExpressionBodyScalar
     */
    qe:QueryExpressionBodyScalar<T> UNION DISTINCT other:QueryTerm<T> ::
        AbstractQueryExpressionBodyScalar<T> unionDistinct {
            public QueryBuilder<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                return new UnionExceptBuilder<T>(qe, other) {
                    @Override
                    protected SqlBuilder composeSql(final Dialect dialect, final SqlBuilder left, final SqlBuilder right) {
                        return dialect.QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_UNION_DISTINCT_QueryTerm(left, right);
                    }
                }
                .build(context);
            }
        }
|
    /**
     * Creates a AbstractQueryExpressionBodyScalar representing
     * {@code (QueryExpressionBodyScalar)this UNION other}.
     * @param other second argument of UNION
     * @return new AbstractQueryExpressionBodyScalar
     */
    qe:QueryExpressionBodyScalar<T> UNION other:QueryTerm<T> ::
        AbstractQueryExpressionBodyScalar<T> union {
            public QueryBuilder<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                return new UnionExceptBuilder<T>(qe, other) {
                    @Override
                    protected SqlBuilder composeSql(final Dialect dialect, final SqlBuilder left, final SqlBuilder right) {
                        return dialect.QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_UNION_QueryTerm(left, right);
                    }
                }
                .build(context);
            }
        }
|
    /**
     * Creates a AbstractQueryExpressionBodyScalar representing
     * {@code (QueryExpressionBodyScalar)this EXCEPT ALL other}.
     * @param other second argument of EXCEPT ALL
     * @return new AbstractQueryExpressionBodyScalar
     */
    qe:QueryExpressionBodyScalar<T> EXCEPT ALL other:QueryTerm<T> ::
        AbstractQueryExpressionBodyScalar<T> exceptAll {
            public QueryBuilder<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                return new UnionExceptBuilder<T>(qe, other) {
                    @Override
                    protected SqlBuilder composeSql(final Dialect dialect, final SqlBuilder left, final SqlBuilder right) {
                        return dialect.QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_EXCEPT_ALL_QueryTerm(left, right);
                    }
                }
                .build(context);
            }
        }
|
    /**
     * Creates a AbstractQueryExpressionBodyScalar representing
     * {@code (QueryExpressionBodyScalar)this EXCEPT DISTINCT other}.
     * @param other second argument of EXCEPT DISTINCT
     * @return new AbstractQueryExpressionBodyScalar
     */
    qe:QueryExpressionBodyScalar<T> EXCEPT DISTINCT other:QueryTerm<T> ::
        AbstractQueryExpressionBodyScalar<T> exceptDistinct {
            public QueryBuilder<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                return new UnionExceptBuilder<T>(qe, other) {
                    @Override
                    protected SqlBuilder composeSql(final Dialect dialect, final SqlBuilder left, final SqlBuilder right) {
                        return dialect.QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_EXCEPT_DISTINCT_QueryTerm(left, right);
                    }
                }
                .build(context);
            }
        }
|
    /**
     * Creates a AbstractQueryExpressionBodyScalar representing
     * {@code (QueryExpressionBodyScalar) this EXCEPT other}.
     * @param other second argument of EXCEPT
     * @return new AbstractQueryExpressionBodyScalar
     */
    qe:QueryExpressionBodyScalar<T> EXCEPT other:QueryTerm<T> ::
        AbstractQueryExpressionBodyScalar<T> except {
            public QueryBuilder<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                return new UnionExceptBuilder<T>(qe, other) {
                    @Override
                    protected SqlBuilder composeSql(final Dialect dialect, final SqlBuilder left, final SqlBuilder right) {
                        return dialect.QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_EXCEPT_QueryTerm(left, right);
                    }
                }
                .build(context);
            }
        }
;

# QueryTerm is always scalar; we do not add suffix Scalar
#
public interface QueryTerm<T> extends Scalar<T> : QueryBuilder<T> {}

public class AbstractQueryTerm<T> implements QueryTerm<T> {}

<T> QueryTerm<T> ::=
    qp:QueryPrimary<T> :: implicit
|
    /**
     * Creates a AbstractQueryTerm representing {@code (QueryTerm)this INTERSECT ALL other}.
     * @param other second argument of INTERSECT ALL
     * @return new AbstractQueryExpressionBodyScalar
     */
    qt:QueryTerm<T> INTERSECT ALL other:QueryPrimary<T> ::
        AbstractQueryTerm<T> intersectAll {
            public QueryBuilder<T> z$sqlOfQueryTerm(final SqlContext context) {
                return new IntersectBuilder<T>(qt, other) {
                    @Override
                    protected SqlBuilder composeSql(final Dialect dialect, final SqlBuilder left, final SqlBuilder right) {
                        return dialect.QueryTerm_is_QueryTerm_INTERSECT_ALL_QueryPrimary(left, right);
                    }
                }
                .build(context);
            }
        }
|
    /**
     * Creates a AbstractQueryTerm representing {@code (QueryTerm)this INTERSECT DISTINCT other}.
     * @param other second argument of INTERSECT DISTINCT
     * @return new AbstractQueryExpressionBodyScalar
     */
    qt:QueryTerm<T> INTERSECT DISTINCT other:QueryPrimary<T> ::
          AbstractQueryTerm<T> intersectDistinct {
            public QueryBuilder<T> z$sqlOfQueryTerm(final SqlContext context) {
                return new IntersectBuilder<T>(qt, other) {
                    @Override
                    protected SqlBuilder composeSql(final Dialect dialect, final SqlBuilder left, final SqlBuilder right) {
                        return dialect.QueryTerm_is_QueryTerm_INTERSECT_DISTINCT_QueryPrimary(left, right);
                    }
                }
                .build(context);
            }
          }
|
    /**
     * Creates a AbstractQueryTerm representing {@code (QueryTerm)this INTERSECT other}.
     * @param other second argument of INTERSECT
     * @return new AbstractQueryExpressionBodyScalar
     */
    qt:QueryTerm<T> INTERSECT other:QueryPrimary<T> ::
          AbstractQueryTerm<T> intersect {
            public QueryBuilder<T> z$sqlOfQueryTerm(final SqlContext context) {
                return new IntersectBuilder<T>(qt, other) {
                    @Override
                    protected SqlBuilder composeSql(final Dialect dialect, final SqlBuilder left, final SqlBuilder right) {
                        return dialect.QueryTerm_is_QueryTerm_INTERSECT_QueryPrimary(left, right);
                    }
                }
                .build(context);
            }
          }
;

public interface QueryPrimary<T> extends Scalar<T>  : QueryBuilder<T> {}

<T> QueryPrimary<T> ::=
    qs:QuerySpecificationScalar<T> :: implicit
|
    LEFT_PAREN qe:QueryExpressionBodyScalar<T> RIGHT_PAREN :: implicit
;









