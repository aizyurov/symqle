(done another way: method map() for expressions) public ValueExpression<T> add(ValueExpression<?>, Term<?>, Mapper<T>);
mult, div, sum
Same for concat

(done) Rename plus -> add, minus -> sub

(discarder) Add access to DialectDataSource from Row (needed for collections) - no need, can pass DDS to Selector constructor

(done) Refactor DialectDataSource -> DatabaseGate - transaction suport! is DataSource enough?
Remove list(DataSource,...) ?

(done) Remove setIgnoreType: methods with Mapper will do

casts

(done) contains() for subquery

(done) refactor Pair - rename all methods and variables

LIMIT/OFFSET

(?) add ORDER BY for union/except/intersect (without parameter, there is only one column accessible via Context)

map() for WhenClause*; rename methods (orWhen -> option ; orElse => otherwise)





