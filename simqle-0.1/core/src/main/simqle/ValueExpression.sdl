public interface ValueExpression<T> extends Scalar<T> : Sql {}

// public class AbstractValue<T> implements ValueExpression<T> {}

# Hierarchy of ValueExpression approximately follows SQL standard.
# For some interfaces type parameters are bounded
# <row value expression> is not considered being <value expression>
# it is not Scalar and we have different rules for RowValueExpression and ValueExpression

public class AbstractValueExpression<T> implements ValueExpression<T> {}

:: public <T> AbstractValueExpression<T> map(final ValueExpression<?> e, final Mapper<T> mapper) {
    return new AbstractValueExpression<T>() {
        @Override
        public Mapper<T> getMapper() {
            return mapper;
        }

        @Override
        public Sql z$create$ValueExpression(final SqlContext context) {
            return e.z$create$ValueExpression(context);
        }
    };
}


<T> ValueExpression<T> ::=
    e:NumericExpression<T> :: implicit {}
|
    e:StringExpression<T> :: implicit {}
|
    e:ValueExpressionPrimary<T> :: implicit {}
;

# see BooleanValueExpression.sdl
ValueExpression<Boolean> ::=  bve:BooleanExpression :: public AbstractValueExpression<Boolean> asValue {
                public Mapper<Boolean> getMapper() {
                    return Mappers.BOOLEAN;
                }
    }
;

# no abstract class: no methods - removed as unnecessary
// public interface CommonValueExpression<T> extends Scalar<T> : Sql {}

public interface StringExpression<T> extends Scalar<T> : Sql {}

public class AbstractStringExpression<T> implements StringExpression<T> {}

:: public <T> AbstractStringExpression<T> map(final StringExpression<?> e, final Mapper<T> mapper) {
    return new AbstractStringExpression<T>() {
        @Override
        public Mapper<T> getMapper() {
            return mapper;
        }

        @Override
        public Sql z$create$StringExpression(final SqlContext context) {
            return e.z$create$StringExpression(context);
        }
    };
}


<T> StringExpression<T> ::=
    p:ValueExpressionPrimary<T> :: implicit {}
;

StringExpression<String> ::=
    s:StringExpression<?> CONCAT e:ValueExpressionPrimary<?>
        :: public AbstractStringExpression<String> concat {
                public Mapper<String> getMapper() {
                    return Mappers.STRING;
                }
        }
;

:: public AbstractStringExpression<String> concat(final StringExpression<?> e, final String s) {
    return concat(e,  DynamicParameter.create(Mappers.STRING, s));
}

