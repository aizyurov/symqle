# This file contains templates for Symqle, Dialect and GenericDialect.
# Methods are added to the classes during code generation

# Scalar interface is also defined here, because code generator should know it

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import javax.sql.DataSource;
import org.symqle.*;
import org.symqle.jdbc.ResultSetRow;
import org.symqle.jdbc.StatementParameters;
public final class Symqle  {
    private static final Symqle instance = new Symqle();

    private Symqle() {}

    public static Symqle get() {
         return instance;
    }

    private static SqlContext createInnerContext(SqlContext context) {
        SqlContext innerContext = new SqlContext();
        innerContext.set(UniqueNameProvider.class, null);
        innerContext.set(Dialect.class, context.get(Dialect.class));
        innerContext.set(Configuration.class, context.get(Configuration.class));
        // create an empty AbstractFromClause for QueryExpressionScalar with current FromClause as enclosing
        innerContext.set(TableRegistry.class, new SelectTableRegistry(context.get(TableRegistry.class)));
        return innerContext;
    }

    private static SqlContext createScalarInnerContext(SqlContext context) {
        SqlContext innerContext = new SqlContext();
        // if already in inner context, do not provide column labels
        innerContext.set(UniqueNameProvider.class, context.get(UniqueNameProvider.class) == null ? null :new ScalarNameProvider());
        innerContext.set(Dialect.class, context.get(Dialect.class));
        // create an empty AbstractFromClause with current FromClause as enclosing
        innerContext.set(TableRegistry.class, new SelectTableRegistry(context.get(TableRegistry.class)));
        return innerContext;
    }

}


import org.symqle.Sql;
/** This interface declares methods for construction of SQL nonterminal symbols.
*   Each method corresponds to one syntactic rule. Method arguments are nonterminal symbols
* from the right part. Terminal symbols are not parameters; they have fixed values.
*/
public interface Dialect  {
    String getName();
    String fallbackTableName();
}

import org.symqle.SqlParameters;
import org.symqle.Sql;
import static org.symqle.SqlTerm.*;
/**
* A standard straighforward implementation of Dialect.
* Each nonterminal symbol is constructed exactly as required by the rule.
* Subclasses may override methods preserving semantics.
* e.g. replace {@code concat(qe, EXCEPT, qt)} for {@code concat(qe, MINUS, qt)}
* in {@link #QueryExpressionScalar_is_QueryExpressionScalar_EXCEPT_QueryTerm(org.symqle.Sql, org.symqle.Sql)}
*/
public class GenericDialect implements Dialect {

    private static final Dialect instance = new GenericDialect();

    protected GenericDialect() {}

    public static Dialect get() {
         return instance;
    }

    public String getName() {
        return "Generic";
    }

    public String fallbackTableName() {
        throw new IllegalStateException("Generic dialect does not support selects with no tables");
    }

    protected final Sql concat(final Sql first, final Sql... other) {
        return new CompositeSql(first, other);
    }

    /**
     * Represents an Sql element composed from a list of sub-elements.
     * Provides implementation of {@link #getSqlText()} and {@link #setParameters(SqlParameters}}
     * @author Alexander Izyurov
     */
    public static class CompositeSql implements Sql {
        /**
         * the first sub-element.
         */
        private final Sql first;
        /**
         * other sub-elements.
         */
        private final Sql[] other;

        /**
         * Constructs composite Sql from elements.
         * @param first the first element of sequence, not null
         * @param other elements, optional (but each not null)
         */
        public CompositeSql(final Sql first, final Sql... other) {
            this.first = first;
            this.other = other;
        }


        /**
         * Constructs Sql text as concatenation of Sql text of elements.
         * @return constructed text
         */
        public final String getSqlText() {
            // minor optimization
            if (other.length==0) {
                return first.getSqlText();
            } else {
                StringBuilder builder = new StringBuilder();
                builder.append(first.getSqlText());
                for (Sql element : this.other) {
                    builder.append(' ');
                    builder.append(element.getSqlText());
                }
                return builder.toString();
            }
        }

        /**
         * Sets SqlParameter by delegation to each member in turn.
         * @param p SqlParameter interface to write parameter values into
         */
        public final void setParameters(final SqlParameters p) throws SQLException {
            first.setParameters(p);
            for (Sql element : this.other) {
                element.setParameters(p);
            }
        }


    }

}

import org.symqle.CustomSql;
import org.symqle.Sql;
class DebugDialect extends GenericDialect {

    private static final Dialect instance = new DebugDialect();

    protected DebugDialect() {}

    public static Dialect get() {
        return instance;
    }

    @Override
    public String fallbackTableName() {
        return null;
    }

}


import org.symqle.Mapper;

/**
 * Scalar corresponds to one element of a tuple.
 * It can be mapped to some Java type: values of this type
 * can be retrieved from a definite column of a ResultSet and may be set as SQL parameters.
 * @author lvovich
 * @param <T> the Java type to which this Scalar is mapped.
 */
public interface Scalar<T> {

    Mapper<T> getMapper();

}

