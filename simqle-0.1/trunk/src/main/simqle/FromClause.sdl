public interface FromClause : Sql {}

# <from clause> ::= FROM <table reference list>
#
# <table reference list> ::= <table reference> [ { <comma> <table reference> }... ]
# Simqle does not support implicit cross joins, so this is simplified

FromClause ::= FROM t:TableReference :: implicit {}
;

# <table reference> ::= <table primary or joined table> [ <sample clause> ]
# Simqle does not support <sample clause>, so we are omitting <tableprimary or joined table>

public interface TableReference : Sql {}

TableReference ::=
    t:TablePrimary :: implicit {}
|
    t:JoinedTable :: implicit {}
;

# <table primary> ::=
#		<table or query name> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
#	|	<derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
#	|	<lateral derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
#	|	<collection derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
#	|	<table function derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
#	|	<only spec> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
#	|	<left paren> <joined table> <right paren>
#
# only the first one is supported, AS <correlation name> is always used <correlation name> is just Identifier

public interface TablePrimary : Sql {}

TablePrimary ::= t:TableName AS id:Identifier :: protected TablePrimary use {}
;

:: TablePrimary implicit(final TableName t) {
    return new TablePrimary() {
        @Override
        public Sql z$create$TablePrimary(final SqlContext context) {
            final String correlationName = context.get(AutoFromClause.class).getCorrelationName(t);
            return use(t, new DefinedIdentifier(correlationName)).z$create$TablePrimary(context);
        }
    };
}

public interface TableName extends Dependent : Sql {
}

# a simgle class Table implements both TableName and Join
# Tables are handled specially bu AutoFromClause

import org.simqle.CustomSql;
public class Table implements TableName, Join {
    private final String name;

    /**
     * Delegates to this member to implement Join.
     */
    private Join join;

    protected Table(final String name) {
        this.name = name;
    }

    public Set<TableName> dependsOn() {
        if (join != null) {
            return join.dependsOn();
        } else {
            return Collections.emptySet();
        }
    }

    private void checkNotJoined() {
        if (join != null) {
            throw new IllegalStateException("Already joined");
        }
    }

    public void crossJoin() {
        checkNotJoined();
        join = Simqle.get().crossJoin(this);
    }

    public void leftJoin(BooleanExpression condition) {
        checkNotJoined();
        join = Simqle.get().leftJoin(this, condition);
    }

    public void rightJoin(BooleanExpression condition) {
        checkNotJoined();
        join = Simqle.get().rightJoin(this, condition);
    }

    public void outerJoin(BooleanExpression condition) {
        checkNotJoined();
        join = Simqle.get().outerJoin(this, condition);
    }

    public void innerJoin(BooleanExpression condition) {
        checkNotJoined();
        join = Simqle.get().innerJoin(this, condition);
    }
    /**
            * Creates an Sql representing <code>this</code>
            * @param context the Sql construction context
            * @return sql conforming to <code>this</code> syntax
            */
            public Sql z$create$Join(SqlContext context) {
                if (join != null) {
                    return join.z$create$Join(context);
                } else {
                    throw new IllegalStateException("Not joined");
                }
            }
            /**
            * Creates an Sql representing <code>this</code>
            * @param context the Sql construction context
            * @return sql conforming to <code>this</code> syntax
            */
            public Sql z$create$TableName(SqlContext context) {
                return new CustomSql(name);
            }
}

# <joined table> ::=
#		<cross join>
#	|	<qualified join>
#	|	<natural join>
#	|	<union join>
#
# <cross join> ::= <table reference> CROSS JOIN <table primary>
#
# <qualified join> ::= <table reference> [ <join type> ] JOIN <table reference> <join specification>
#
# <natural join> ::= <table reference> NATURAL [ <join type> ] JOIN <table primary>
#
# <union join> ::= <table reference> UNION JOIN <table primary>
#
# Simqle supports only cross join and qualified join. We are introducing
# intermediate non-terminal Join, which is CROSS JOIN <table primary> or <join type> JOIN <table reference> <join specification>
# a limitation: in qualified join the second <table reference> can be only <table primary>
#
# <join specification> ::= <join condition> | <named columns join>
# Simqle does not support/use <named columns join>, so we are inlining <join condition> in Join productions


public interface JoinedTable : Sql {}

JoinedTable ::= t:TableReference j:Join :: protected JoinedTable join {}
;

public interface Join extends Dependent : Sql {}

Join ::=
    CROSS JOIN t:TablePrimary ::protected Join crossJoin {
        public Set<TableName> dependsOn() {
            return Collections.emptySet();
        }
    }
|
    LEFT JOIN t:TablePrimary ON c:BooleanExpression ::protected Join leftJoin {
        public Set<TableName> dependsOn() {
            Set<TableName> dependencies = new HashSet<TableName>(c.dependsOn());
            dependencies.remove(t);
            return dependencies;
        }
    }
|
    RIGHT JOIN t:TablePrimary ON c:BooleanExpression :: protected Join rightJoin {
        public Set<TableName> dependsOn() {
            Set<TableName> dependencies = new HashSet<TableName>(c.dependsOn());
            dependencies.remove(t);
            return dependencies;
        }
    }
|
    OUTER JOIN t:TablePrimary ON c:BooleanExpression :: protected Join outerJoin {
        public Set<TableName> dependsOn() {
            Set<TableName> dependencies = new HashSet<TableName>(c.dependsOn());
            dependencies.remove(t);
            return dependencies;
        }
    }
|
    INNER JOIN t:TablePrimary ON c:BooleanExpression :: protected Join innerJoin {
        public Set<TableName> dependsOn() {
            Set<TableName> dependencies = new HashSet<TableName>(c.dependsOn());
            dependencies.remove(t);
            return dependencies;
        }
    }
;


public class ImplicitFromClause implements FromClause {
            public Sql z$create$FromClause(SqlContext context) {
                return context.get(AutoFromClause.class).z$create$FromClause(context);
            }
}

import java.util.Map;
import java.util.HashMap;
import org.simqle.TableNameProvider;
import org.simqle.util.TSort;
public class AutoFromClause implements FromClause {

    private final AutoFromClause parent;

    private final Map<TableName, String> localNames = new HashMap<TableName, String>();

    private TableNameProvider tableNameProvider;

    boolean crossJoinsAllowed;

    public AutoFromClause() {
        this.parent = null;
        this.tableNameProvider = new TableNameProvider();
    }


    public AutoFromClause(AutoFromClause parent) {
        this.parent = parent;
        this.tableNameProvider = parent.tableNameProvider;
        this.crossJoinsAllowed = parent.crossJoinsAllowed;
    }

    void allowImplicitCrossJoins(boolean allow) {
        crossJoinsAllowed = allow;
    }

    /**
     * Creates correlation name if not found
     * @param table
     * @return
     */
    public String getCorrelationName(TableName table) {
        // find it somewhere;
        // if not found, assume it is local and create
        final String found = findCorrelationName(table);
        if (found != null) {
            return found;
        } else {
            final String newName = tableNameProvider.getUniqueName();
            localNames.put(table, newName);
            return newName;
        }
    }

    /**
     * Returns null if not found
     * @param table
     * @return
     */
    private String findCorrelationName(TableName table) {
        final String found = localNames.get(table);
        return found != null ? found : (parent == null ? null : parent.findCorrelationName(table));
    }


    public Sql z$create$FromClause(final SqlContext context) {
        final TSort<TableName> tSort = new TSort<TableName>();
        final Simqle simqle = Simqle.get();
        if (localNames.keySet().isEmpty()) {
            throw new IllegalStateException("From clause cannot be empty");
//            return simqle.createEmptyFromClause();
        }
        for (TableName table: localNames.keySet()) {
            final Set<TableName> dependencies = table.dependsOn();
            tSort.add(table, dependencies.toArray(new TableName[dependencies.size()]));
        }
        final List<TableName> sortedTables = tSort.sort();
        TableReference tableReference = simqle.z$TableReference$from$TablePrimary((TablePrimary) sortedTables.get(0));
        int i;
        for (i = 1; i < sortedTables.size(); i++) {
            final TableName currentTable = sortedTables.get(i);
            Join join = (Join) currentTable;
            // although all Tables formally implement Join, it may be implicit cross join,
            // make sure that it does not throw exception
            try {
                join.z$create$Join(context);
            } catch (IllegalStateException e) {
                if (crossJoinsAllowed) {
                    // make cross join
                    join = simqle.crossJoin((TablePrimary) currentTable);
                } else {
                    throw e;
                }
            }
            tableReference = simqle.z$TableReference$from$JoinedTable(simqle.join(tableReference, join));
        }
        return simqle.z$FromClause$from$TableReference(tableReference).z$create$FromClause(context);
    }

}








