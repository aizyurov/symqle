public interface NumericExpression<T> extends Scalar<T>: Sql {}

public class AbstractNumericExpression<T> implements NumericExpression<T> {}

# implicit operations retain type argument
<T> NumericExpression<T> ::=
    t:Term<T> :: implicit {}
;

# all operations accept <? extends Number> and return <Number>
NumericExpression<Number> ::=
    e:NumericExpression<?> PLUS t:Term<?>
         :: public AbstractNumericExpression<Number> plus {
            public Number value(final Element element) throws SQLException {
                    return element.getBigDecimal();
            }
         }
|
    e:NumericExpression<?> MINUS t:Term<?>
         :: public AbstractNumericExpression<Number> minus {
            public Number value(final Element element) throws SQLException {
                    return element.getBigDecimal();
            }
         }
;

:: public AbstractNumericExpression<Number> plus(final NumericExpression<?> e, final Number n) {
    return plus(e, createNumberParameter(n));
}

:: public AbstractNumericExpression<Number> minus(final NumericExpression<?> e, final Number n) {
    return minus(e, createNumberParameter(n));
}


public interface Term<T> extends Scalar<T> : Sql {}

public class AbstractTerm<T> implements Term<T> {}

<T> Term<T> ::= f:Factor<T> :: implicit {}
;

Term<Number> ::=
    t:Term<?> ASTERISK f:Factor<?>
        :: public AbstractTerm<Number> mult {
                public Number value(final Element element) throws SQLException {
                        return element.getBigDecimal();
                }
        }
|
    t:Term<?> SOLIDUS f:Factor<?>
        :: public AbstractTerm<Number> div {
            public Number value(final Element element) throws SQLException {
                    return element.getBigDecimal();
            }
        }
;

:: public AbstractTerm<Number> mult(final Term<?> t, final Number n) {
    return mult(t, createNumberParameter(n));
 }

:: public AbstractTerm<Number> div(final Term<?> t, final Number n) {
    return div(t, createNumberParameter(n));
 }


public interface Factor<T> extends Scalar<T> : Sql {}

public class AbstractFactor<T> implements Factor<T> {}

# negate retains type argument
<T> Factor<T> ::=
    e:ValueExpressionPrimary<T> :: implicit {}
;
<T> Factor<T> ::= 
    MINUS e:ValueExpressionPrimary<T> :: public AbstractFactor<T> opposite {}
;

import java.math.BigDecimal;
import java.sql.SQLException;
:: protected DynamicParameter<Number> createNumberParameter(final Number n) {
    return new DynamicParameter<Number>() {
        protected void set(final SqlParameter p) throws SQLException {
            p.setBigDecimal(new BigDecimal(n.toString()));
        }
        public Number value(final Element element) throws SQLException {
            return element.getBigDecimal();
        }
     };
}