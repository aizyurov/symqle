public interface Predicate extends Scalar<Boolean>, Dependent : Sql {}

Predicate ::=
 		p:ComparisonPredicate :: implicit {}
|
        p:InPredicate :: implicit {}
|
        p:NullPredicate :: implicit {}
|
        p:ExistsPredicate :: implicit {}
;

# All predicates use Predicand (<row value predicand>)
# in current version of Simqle it can be only scalar

public interface Predicand<T> extends Scalar<T>, Dependent : Sql {}

<T> Predicand<T> ::= e: CommonValueExpression<T> :: implicit {}
;

Predicand<Boolean> ::= LEFT_PAREN b:BooleanExpression RIGHT_PAREN :: implicit {}
;


public interface ComparisonPredicate extends Scalar<Boolean>, Dependent : Sql {}

import java.sql.SQLException;
public class AbstractPredicate implements Scalar<Boolean> {
    public Boolean value(final Element element) throws SQLException {
        return element.getBoolean();
    }
}

public class AbstractComparisonPredicate extends AbstractPredicate implements ComparisonPredicate {}

<T> ComparisonPredicate ::=
     p1:Predicand<T> EQ p2:Predicand<T>
        :: public AbstractComparisonPredicate eq {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
|
     p1:Predicand<T> NE p2:Predicand<T>
        :: public AbstractComparisonPredicate ne {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
|
     p1:Predicand<T> GT p2:Predicand<T>
        :: public AbstractComparisonPredicate gt {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
|
     p1:Predicand<T> GE p2:Predicand<T>
        :: public AbstractComparisonPredicate ge {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
|
     p1:Predicand<T> LT p2:Predicand<T>
        :: public AbstractComparisonPredicate lt {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
|
     p1:Predicand<T> LE p2:Predicand<T>
        :: public AbstractComparisonPredicate le {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
;


public interface InPredicate extends Scalar<Boolean>, Dependent : Sql {}

public class AbstractInPredicate extends AbstractPredicate implements InPredicate {
}

<T> InPredicate ::=
    p:Predicand<T> IN v:InPredicateValue<T> :: protected AbstractInPredicate inValues {
        public Set<TableName> dependsOn() {
            return dependsAs(p, v);
        }
    }
|
        p:Predicand<T> NOT IN v:InPredicateValue<T> :: protected AbstractInPredicate notInValues {
            public Set<TableName> dependsOn() {
                Set<TableName> dependencies = new HashSet<TableName>(p.dependsOn());
                dependencies.addAll(v.dependsOn());
                return dependencies;
            }
        }
;

public interface InPredicateValue<T> extends Scalar<T>, Dependent : Sql {}

<T> InPredicateValue<T> ::=
    s:ScalarSubquery<T> :: implicit {}
|
    LEFT_PAREN l:InValueList<T> RIGHT_PAREN :: implicit {}
;

public interface InValueList<T> extends Scalar<T>, Dependent : Sql {}

public class AbstractInValueList<T> implements InValueList<T> {}

<T>  InValueList<T> ::=
    e:ValueExpression<T> :: implicit {}
|
    l:InValueList<T> COMMA e:ValueExpression<T> :: protected AbstractInValueList<T> append {
        public final Set<TableName> dependsOn() {
            return dependsAs(l, e);
        }
    }
;

# public method for construction of InPredicate from list of ValueExpression

:: public <T> AbstractInPredicate in(final Predicand<T> p, final ScalarSubquery<T> s) {
        return inValues(p, z$InPredicateValue$from$ScalarSubquery(s));
    }

:: public <T> AbstractInPredicate notIn(final Predicand<T> p, final ScalarSubquery<T> s) {
        return notInValues(p, z$InPredicateValue$from$ScalarSubquery(s));
    }

:: public <T> AbstractInPredicate in(final Predicand<T> p, ValueExpression<T> first, ValueExpression<T>... other) {
     return inValues(p, prepareInPredicateValue(first, other));
}

:: public <T> AbstractInPredicate notIn(final Predicand<T> p, ValueExpression<T> first, ValueExpression<T>... other) {
     return notInValues(p, prepareInPredicateValue(first, other));
}

:: protected <T> InPredicateValue<T> prepareInPredicateValue(ValueExpression<T> first, ValueExpression<T>... other) {
     InValueList<T> list = z$InValueList$from$ValueExpression(first);
     for (ValueExpression<T> e: other) {
         list = append(list, e);
     }
     return z$InPredicateValue$from$InValueList(list);
}


public interface NullPredicate extends Scalar<Boolean>, Dependent : Sql {}

public interface ExistsPredicate extends Scalar<Boolean>, Dependent : Sql {}




# <in zPredicate> ::= <row value predicand> <in zPredicate part 2>
# 
# <in zPredicate part 2> ::= [ NOT ] IN <in zPredicate value>
# 
# <in zPredicate value> ::=
# 		<table zSubquery>
# 	|	<left paren> <in value list> <right paren>
# 
# <in value list> ::= <row value expression> [ { <comma> <row value expression> }... ]
# */
# 
# <T> zInPredicate ::= p:zRowValuePredicand<T> IN v:zInPredicateValue<T>
#     {
#         return new AbstractInPredicate(p, v) {
#             @Override
#             public Sql z$create$zInPredicate(final SqlContext context) {
#                 return new CompositeSql(p.z$create$zRowValuePredicand(context), IN, v.z$create$zInPredicateValue(context));
#             }
#         };
#     }
#     :: RowValuePredicand<T>
#     {
#         public InPredicate in(zSubquery<T> v)   {
#         final zInPredicateValue<T> pv = SqlFactory.getInstance().zInPredicateValue_IS_zSubquery(v);
#             return new InPredicate(SqlFactory.getInstance().zInPredicate_IS_zRowValuePredicand_IN_zInPredicateValue(this, pv));
#         }
# 
# public InPredicate in(zRowValueExpression<T> first, zRowValueExpression<T> second, zRowValueExpression<T>... more)     {
#             zInValueList<T> vl = SqlFactory.getInstance().zInValueList_IS_zRowValueExpression(first);
#             vl = SqlFactory.getInstance().zInValueList_IS_zInValueList_COMMA_zRowValueExpression(vl, second);
#             for (zRowValueExpression<T> e: more) {
#                 vl = SqlFactory.getInstance().zInValueList_IS_zInValueList_COMMA_zRowValueExpression(vl, e);
#             }
#             final zInPredicateValue<T> pv = SqlFactory.getInstance().zInPredicateValue_IS_LEFT_PAREN_zInValueList_RIGHT_PAREN(vl);
#             return new InPredicate(SqlFactory.getInstance().zInPredicate_IS_zRowValuePredicand_IN_zInPredicateValue(this, pv));
#         }
#     }
# |   p:zRowValuePredicand<T> NOT IN v:zInPredicateValue<T>
#     {
#         return new AbstractInPredicate(p, v) {
#             @Override
#             public Sql z$create$zInPredicate(final SqlContext context) {
#                 return new CompositeSql(p.z$create$zRowValuePredicand(context), NOT, IN, v.z$create$zInPredicateValue(context));
#             }
#         };
#     }
#     :: RowValuePredicand<T>
#     {
#         public InPredicate notIn(zSubquery<T> v)   {
#         final zInPredicateValue<T> pv = SqlFactory.getInstance().zInPredicateValue_IS_zSubquery(v);
#             return new InPredicate(SqlFactory.getInstance().zInPredicate_IS_zRowValuePredicand_NOT_IN_zInPredicateValue(this, pv));
#         }
# 
# public InPredicate notIn(zRowValueExpression<T> first, zRowValueExpression<T> second, zRowValueExpression<T>... more)     {
#             zInValueList<T> vl = SqlFactory.getInstance().zInValueList_IS_zRowValueExpression(first);
#             vl = SqlFactory.getInstance().zInValueList_IS_zInValueList_COMMA_zRowValueExpression(vl, second);
#             for (zRowValueExpression<T> e: more) {
#                 vl = SqlFactory.getInstance().zInValueList_IS_zInValueList_COMMA_zRowValueExpression(vl, e);
#             }
#             final zInPredicateValue<T> pv = SqlFactory.getInstance().zInPredicateValue_IS_LEFT_PAREN_zInValueList_RIGHT_PAREN(vl);
#             return new InPredicate(SqlFactory.getInstance().zInPredicate_IS_zRowValuePredicand_NOT_IN_zInPredicateValue(this, pv));
#         }
#     }
# ;
# 
# public interface zInPredicateValue<T> : Sql
# {}
# 
# <T> zInPredicateValue<T> ::= sq:zSubquery<T>
# |
#     LEFT_PAREN vl:zInValueList<T> RIGHT_PAREN
# ;
# 
# public interface zInValueList<T> : Sql
# {}
# 
# <T> zInValueList<T> ::= e:zRowValueExpression<T>
# |  l:zInValueList<T> COMMA e:zRowValueExpression<T>
# ;
# 
# public abstract class AbstractInPredicate extends AbstractPredicate implements zInPredicate
# {
#     private final zRowValuePredicand<?> p;
#     private final zInPredicateValue<?> v;
# 
# 
#     public AbstractInPredicate$(zRowValuePredicand<?> p, final zInPredicateValue<?> v) {
#         this.p = p;
#         this.v = v;
#     }
# 
#     @Override
#     public final void z$prepare$zInPredicate(final SqlContext context) {
#         p.z$prepare$zRowValuePredicand(context);
#         v.z$prepare$zInPredicateValue(context);
#     }
# 
# }
# 
# public interface zNullPredicate extends Scalar<Boolean> : Sql
# {}
# 
# class NullPredicate implements zNullPredicate with SqlBuilder
# {}
# 
# /*
# <null zPredicate> ::= <row value predicand> <null zPredicate part 2>
# 
# <null zPredicate part 2> ::= IS [ NOT ] NULL
# */
# 
# zNullPredicate ::= p:zRowValuePredicand<?> IS NULL
#     {
#         return new AbstractNullPredicate(p) {
#             @Override
#              public Sql z$create$zNullPredicate(final SqlContext context) {
#                  return new CompositeSql(p.z$create$zRowValuePredicand(context), IS, NULL);
#              }
#         };
#     }
#     :: RowValuePredicand<T>
#     {
#         public NullPredicate isNull() {
#             return new NullPredicate(_APPLY_RULE_(this));
#         }
#     }
# |   p:zRowValuePredicand<?> IS NOT NULL
#     {
#         return new AbstractNullPredicate(p) {
#              @Override
#              public Sql z$create$zNullPredicate(final SqlContext context) {
#                  return new CompositeSql(p.z$create$zRowValuePredicand(context), IS, NOT, NULL);
#              }
#         };
#     }
#     :: RowValuePredicand<T>
#     {
#         public NullPredicate isNotNull() {
#             return new NullPredicate(_APPLY_RULE_(this));
#         }
#     }
# ;
# 
# public abstract class AbstractNullPredicate extends AbstractPredicate implements zNullPredicate {
#     private final zRowValuePredicand p;
# 
#     protected AbstractNullPredicate$(final zRowValuePredicand p) {
#         this.p = p;
#     }
# 
#     @Override
#     public final void z$prepare$zNullPredicate(final SqlContext context) {
#         p.z$prepare$zRowValuePredicand(context);
#     }
# 
# }
# 
# public interface zExistsPredicate extends Scalar<Boolean> : Sql
# {}
# 
# public class ExistsPredicate implements zExistsPredicate with SqlBuilder
# {}
# 
# zExistsPredicate ::= EXISTS sq:zSubquery<?>
#     {
#         return new AbstractExistsPredicate() {
#              @Override
#              public Sql z$create$zExistsPredicate(final SqlContext context) {
#                  return new CompositeSql(EXISTS, sq.z$create$zSubquery(context));
#              }
#              @Override
#              public void z$prepare$zExistsPredicate(final SqlContext context) {
#                 sq.z$prepare$zSubquery(context);
#              }
#         };
# 
#     }
#     :: Subquery<T>
#     {
#         public ExistsPredicate exists() {
#             return new ExistsPredicate(_APPLY_RULE_(this));
#         }
#     }
# ;
# 
# public abstract class AbstractPredicate implements Scalar<Boolean> {
#     @Override
#     public final Boolean value(final Element element) throws SQLException {
#         return element.getBoolean();
#     }
# }
# 
# public abstract class AbstractExistsPredicate extends AbstractPredicate implements zExistsPredicate
# {}