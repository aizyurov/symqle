public interface Predicate extends Scalar<Boolean> : Sql {}

Predicate ::=
 		p:ComparisonPredicate :: implicit {}
|
        p:InPredicate :: implicit {}
|
        p:NullPredicate :: implicit {}
|
        p:ExistsPredicate :: implicit {}
;

# All predicates use Predicand (<row value predicand>)
# in current version of Simqle it can be only scalar

public interface Predicand<T> extends Scalar<T> : Sql {}

<T> Predicand<T> ::=
    e:NumericExpression<T> :: implicit {}
|
    e:StringExpression<T> :: implicit {}
|
    e:ValueExpressionPrimary<T> :: implicit {}
;

Predicand<Boolean> ::= LEFT_PAREN b:BooleanExpression RIGHT_PAREN :: implicit {}
;


public interface ComparisonPredicate extends Scalar<Boolean> : Sql {}

import java.sql.SQLException;
public class AbstractPredicate implements Scalar<Boolean> {
    public Boolean value(final Element element) throws SQLException {
        return element.getBoolean();
    }
}

public class AbstractComparisonPredicate extends AbstractPredicate implements ComparisonPredicate {}

<T> ComparisonPredicate ::=
     p1:Predicand<T> EQ p2:Predicand<T>
        :: public AbstractComparisonPredicate eq {}
|
     p1:Predicand<T> NE p2:Predicand<T>
        :: public AbstractComparisonPredicate ne {}
|
     p1:Predicand<T> GT p2:Predicand<T>
        :: public AbstractComparisonPredicate gt {}
|
     p1:Predicand<T> GE p2:Predicand<T>
        :: public AbstractComparisonPredicate ge {}
|
     p1:Predicand<T> LT p2:Predicand<T>
        :: public AbstractComparisonPredicate lt {}
|
     p1:Predicand<T> LE p2:Predicand<T>
        :: public AbstractComparisonPredicate le {}
;


public interface InPredicate extends Scalar<Boolean> : Sql {}

public class AbstractInPredicate extends AbstractPredicate implements InPredicate {
}

<T> InPredicate ::=
    p:Predicand<T> IN v:InPredicateValue<T> :: public AbstractInPredicate in {}
|
        p:Predicand<T> NOT IN v:InPredicateValue<T> :: public AbstractInPredicate notIn {}
;

public interface InPredicateValue<T> extends Scalar<T> : Sql {}

<T> InPredicateValue<T> ::=
    s:ScalarSubquery<T> :: implicit {}
|
    LEFT_PAREN l:InValueList<T> RIGHT_PAREN :: implicit {}
;

public interface InValueList<T> extends Scalar<T> : Sql {}

public class AbstractInValueList<T> implements InValueList<T> {}

<T>  InValueList<T> ::=
    e1:ValueExpression<T> COMMA e2:ValueExpression<T> :: protected AbstractInValueList<T> createInValueList {}
|
    l:InValueList<T> COMMA e:ValueExpression<T> :: protected AbstractInValueList<T> append {}
;

# public convenience methods for construction of InPredicate from list of ValueExpression

:: public <T> AbstractInPredicate in(final Predicand<T> p, ValueExpression<T> first, ValueExpression<T> second, ValueExpression<T>... other) {
     return in(p, prepareInPredicateValue(first, second, other));
}

:: public <T> AbstractInPredicate notIn(final Predicand<T> p, ValueExpression<T> first, ValueExpression<T> second, ValueExpression<T>... other) {
     return notIn(p, prepareInPredicateValue(first, second, other));
}

:: protected <T> InPredicateValue<T> prepareInPredicateValue(ValueExpression<T> first, ValueExpression<T> second, ValueExpression<T>... other) {
     InValueList<T> list = createInValueList(first, second);
     for (ValueExpression<T> e: other) {
         list = append(list, e);
     }
     return z$InPredicateValue$from$InValueList(list);
}


public interface NullPredicate extends Scalar<Boolean> : Sql {}

public class AbstractNullPredicate extends AbstractPredicate implements NullPredicate {}

NullPredicate ::=
    p:Predicand<?> IS NULL :: public AbstractNullPredicate isNull {}
|
    p:Predicand<?> IS NOT NULL :: public AbstractNullPredicate isNotNull {}
;

public interface ExistsPredicate extends Scalar<Boolean> : Sql {}

public class AbstractExistsPredicate extends AbstractPredicate implements ExistsPredicate {}

ExistsPredicate ::= EXISTS s:ScalarSubquery<?> :: public AbstractExistsPredicate exists {}
;
