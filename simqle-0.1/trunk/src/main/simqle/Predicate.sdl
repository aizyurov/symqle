public interface Predicate : Sql {}

Predicate ::=
 		p:ComparisonPredicate :: implicit {}
|
        p:InPredicate :: implicit {}
|
        p:NullPredicate :: implicit {}
|
        p:ExistsPredicate :: implicit {}
;

# All predicates use Predicand (<row value predicand>)
# in current version of Simqle it can be only scalar

public interface Predicand<T> extends Scalar<T> : Sql {}

<T> Predicand<T> ::=
    e:NumericExpression<T> :: implicit {}
|
    e:StringExpression<T> :: implicit {}
|
    e:ValueExpressionPrimary<T> :: implicit {}
;

Predicand<Boolean> ::= LEFT_PAREN b:BooleanExpression RIGHT_PAREN :: implicit {
            public ElementMapper<Boolean> getElementMapper() {
                return Mappers.BOOLEAN;
            }
    }
;


public interface ComparisonPredicate : Sql {}

public class AbstractComparisonPredicate implements ComparisonPredicate {}

<T> ComparisonPredicate ::=
     p1:Predicand<T> EQ p2:Predicand<T>
        :: public AbstractComparisonPredicate eq {}
|

     p1:Predicand<T> NE p2:Predicand<T>
        :: public AbstractComparisonPredicate ne {}
|
     p1:Predicand<T> GT p2:Predicand<T>
        :: public AbstractComparisonPredicate gt {}
|
     p1:Predicand<T> GE p2:Predicand<T>
        :: public AbstractComparisonPredicate ge {}
|
     p1:Predicand<T> LT p2:Predicand<T>
        :: public AbstractComparisonPredicate lt {}
|
     p1:Predicand<T> LE p2:Predicand<T>
        :: public AbstractComparisonPredicate le {}
;

:: public <T> AbstractComparisonPredicate eq(Predicand<T> p, T v) {
    return eq(p, DynamicParameter.create(p.getElementMapper(), v));
}
:: public <T> AbstractComparisonPredicate ne(Predicand<T> p, T v) {
    return ne(p, DynamicParameter.create(p.getElementMapper(), v));
}
:: public <T> AbstractComparisonPredicate gt(Predicand<T> p, T v) {
    return gt(p, DynamicParameter.create(p.getElementMapper(), v));
}
:: public <T> AbstractComparisonPredicate ge(Predicand<T> p, T v) {
    return ge(p, DynamicParameter.create(p.getElementMapper(), v));
}
:: public <T> AbstractComparisonPredicate lt(Predicand<T> p, T v) {
    return lt(p, DynamicParameter.create(p.getElementMapper(), v));
}
:: public <T> AbstractComparisonPredicate le(Predicand<T> p, T v) {
    return le(p, DynamicParameter.create(p.getElementMapper(), v));
}
public interface InPredicate : Sql {}

public class AbstractInPredicate implements InPredicate {
}

<T> InPredicate ::=
    p:Predicand<T> IN v:InPredicateValue<T> :: public AbstractInPredicate in {}
|
        p:Predicand<T> NOT IN v:InPredicateValue<T> :: public AbstractInPredicate notIn {}
;

public interface InPredicateValue<T> : Sql {}

<T> InPredicateValue<T> ::=
    s:ScalarSubquery<T> :: implicit {}
|
    LEFT_PAREN l:InValueList<T> RIGHT_PAREN :: implicit {}
;

public interface InValueList<T> : Sql {}

<T>  InValueList<T> ::=
    e1:ValueExpression<T> :: protected InValueList<T> createInValueList {}
|
    l:InValueList<T> COMMA e:ValueExpression<T> :: protected InValueList<T> append {}
;

# public convenience methods for construction of InPredicate from list of ValueExpression

:: public <T> AbstractInPredicate in(final Predicand<T> p, final ValueExpression<T> first, final ValueExpression<T> second, final ValueExpression<T>... other) {
     return in(p, prepareInPredicateValue(first, second, other));
}

:: public <T> AbstractInPredicate notIn(final Predicand<T> p, final ValueExpression<T> first, final ValueExpression<T> second, final ValueExpression<T>... other) {
     return notIn(p, prepareInPredicateValue(first, second, other));
}

:: protected <T> InPredicateValue<T> prepareInPredicateValue(ValueExpression<T> first, final ValueExpression<T> second, ValueExpression<T>... other) {
     InValueList<T> list = createInValueList(first);
     list = append(list, second);
     for (ValueExpression<T> e: other) {
         list = append(list, e);
     }
     return z$InPredicateValue$from$InValueList(list);
}


public interface NullPredicate : Sql {}

public class AbstractNullPredicate implements NullPredicate {}

NullPredicate ::=
    p:Predicand<?> IS NULL :: public AbstractNullPredicate isNull {}
|
    p:Predicand<?> IS NOT NULL :: public AbstractNullPredicate isNotNull {}
;

public interface ExistsPredicate : Sql {}

public class AbstractExistsPredicate implements ExistsPredicate {}

ExistsPredicate ::= EXISTS s:ScalarSubquery<?> :: public AbstractExistsPredicate exists {}
;
