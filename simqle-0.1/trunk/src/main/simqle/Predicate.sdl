public interface Predicate extends Scalar<Boolean>, Dependent : Sql {}

Predicate ::=
 		p:ComparisonPredicate :: implicit {}
|
        p:InPredicate :: implicit {}
|
        p:NullPredicate :: implicit {}
|
        p:ExistsPredicate :: implicit {}
;

# All predicates use Predicand (<row value predicand>)
# in current version of Simqle it can be only scalar

public interface Predicand<T> extends Scalar<T>, Dependent : Sql {}

<T> Predicand<T> ::= e: CommonValueExpression<T> :: implicit {}
;

Predicand<Boolean> ::= LEFT_PAREN b:BooleanExpression RIGHT_PAREN :: implicit {}
;


public interface ComparisonPredicate extends Scalar<Boolean>, Dependent : Sql {}

import java.sql.SQLException;
public class AbstractPredicate implements Scalar<Boolean> {
    public Boolean value(final Element element) throws SQLException {
        return element.getBoolean();
    }
}

public class AbstractComparisonPredicate extends AbstractPredicate implements ComparisonPredicate {}

<T> ComparisonPredicate ::=
     p1:Predicand<T> EQ p2:Predicand<T>
        :: public AbstractComparisonPredicate eq {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
|
     p1:Predicand<T> NE p2:Predicand<T>
        :: public AbstractComparisonPredicate ne {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
|
     p1:Predicand<T> GT p2:Predicand<T>
        :: public AbstractComparisonPredicate gt {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
|
     p1:Predicand<T> GE p2:Predicand<T>
        :: public AbstractComparisonPredicate ge {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
|
     p1:Predicand<T> LT p2:Predicand<T>
        :: public AbstractComparisonPredicate lt {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
|
     p1:Predicand<T> LE p2:Predicand<T>
        :: public AbstractComparisonPredicate le {
            public Set<TableName> dependsOn() {
                return dependsAs(p1, p2);
            }
        }
;


public interface InPredicate extends Scalar<Boolean>, Dependent : Sql {}

public class AbstractInPredicate extends AbstractPredicate implements InPredicate {
}

<T> InPredicate ::=
    p:Predicand<T> IN v:InPredicateValue<T> :: public AbstractInPredicate in {
        public Set<TableName> dependsOn() {
            return dependsAs(p, v);
        }
    }
|
        p:Predicand<T> NOT IN v:InPredicateValue<T> :: public AbstractInPredicate notIn {
            public Set<TableName> dependsOn() {
                Set<TableName> dependencies = new HashSet<TableName>(p.dependsOn());
                dependencies.addAll(v.dependsOn());
                return dependencies;
            }
        }
;

public interface InPredicateValue<T> extends Scalar<T>, Dependent : Sql {}

<T> InPredicateValue<T> ::=
    s:ScalarSubquery<T> :: implicit {}
|
    LEFT_PAREN l:InValueList<T> RIGHT_PAREN :: implicit {}
;

public interface InValueList<T> extends Scalar<T>, Dependent : Sql {}

public class AbstractInValueList<T> implements InValueList<T> {}

<T>  InValueList<T> ::=
    e1:ValueExpression<T> COMMA e2:ValueExpression<T> :: protected AbstractInValueList<T> createInValueList {
        public final Set<TableName> dependsOn() {
            return dependsAs(e1, e2);
        }
    }
|
    l:InValueList<T> COMMA e:ValueExpression<T> :: protected AbstractInValueList<T> append {
        public final Set<TableName> dependsOn() {
            return dependsAs(l, e);
        }
    }
;

# public convenience methods for construction of InPredicate from list of ValueExpression

:: public <T> AbstractInPredicate in(final Predicand<T> p, ValueExpression<T> first, ValueExpression<T> second, ValueExpression<T>... other) {
     return in(p, prepareInPredicateValue(first, second, other));
}

:: public <T> AbstractInPredicate notIn(final Predicand<T> p, ValueExpression<T> first, ValueExpression<T> second, ValueExpression<T>... other) {
     return notIn(p, prepareInPredicateValue(first, second, other));
}

:: protected <T> InPredicateValue<T> prepareInPredicateValue(ValueExpression<T> first, ValueExpression<T> second, ValueExpression<T>... other) {
     InValueList<T> list = createInValueList(first, second);
     for (ValueExpression<T> e: other) {
         list = append(list, e);
     }
     return z$InPredicateValue$from$InValueList(list);
}


public interface NullPredicate extends Scalar<Boolean>, Dependent : Sql {}

public class AbstractNullPredicate extends AbstractPredicate implements NullPredicate {}

NullPredicate ::=
    p:Predicand<?> IS NULL :: public AbstractNullPredicate isNull {}
|
    p:Predicand<?> IS NOT NULL :: public AbstractNullPredicate isNotNull {}
;

public interface ExistsPredicate extends Scalar<Boolean>, Dependent : Sql {}

public class AbstractExistsPredicate extends AbstractPredicate implements ExistsPredicate {}

ExistsPredicate ::= EXISTS s:ScalarSubquery<?> :: public AbstractExistsPredicate exists {}
;
