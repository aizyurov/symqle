
public interface QueryExpression<T> : Query<T> {}

public class AbstractQueryExpression<T> implements QueryExpression<T> {}

# we have different rules for QueryExpression and QueryExpressionScalar
# the first one is just QueryBase with (maybe) WhereClause
# the second one is really an expression, which may include union, intersection etc.
# see QueryBase.sdl, Where.sdl

<T> QueryExpression<T> ::=
    qb:QueryBase<T> :: implicit {}
|
    qb:QueryBase<T> wc:WhereClause :: public AbstractQueryExpression<T> where {}
|
    qes:QueryExpressionScalar<T> :: implicit {}
;

public interface QueryExpressionScalar<T> extends Scalar<T> : Query<T> {}

public class AbstractQueryExpressionScalar<T> implements QueryExpressionScalar<T> {}

<T> QueryExpressionScalar<T> ::=
    qt:QueryTerm<T> :: implicit {}
|
    qe:QueryExpressionScalar<T> UNION ALL qt:QueryTerm<T> ::
        public AbstractQueryExpressionScalar<T> unionAll {}
|
    qe:QueryExpressionScalar<T> UNION DISTINCT qt:QueryTerm<T> ::
        public AbstractQueryExpressionScalar<T> unionDistinct {}
|
    qe:QueryExpressionScalar<T> EXCEPT ALL qt:QueryTerm<T> ::
        public AbstractQueryExpressionScalar<T> exceptAll {}
|
    qe:QueryExpressionScalar<T> EXCEPT DISTINCT qt:QueryTerm<T> ::
        public AbstractQueryExpressionScalar<T> exceptDistinct {}
;

# zQueryTerm is always scalar; we do not add suffix _scalar for brevity
#
public interface QueryTerm<T> extends Scalar<T> :  Query<T> {}

public class AbstractQueryTerm<T> implements QueryTerm<T> {}

<T> QueryTerm<T> ::=
    qp:QueryPrimary<T> :: implicit {}
|
    qt:QueryTerm<T> INTERSECT ALL qp:QueryPrimary<T> ::
        public QueryTerm<T> intersectAll {}
|   qt:QueryTerm<T> INTERSECT DISTINCT qp:QueryPrimary<T> ::
          public QueryTerm<T> intersectDistinct {}
;

public interface QueryPrimary<T> extends Scalar<T>  : Query<T> {}

public class AbstractQueryPrimary<T> implements QueryPrimary<T> {}

<T> QueryPrimary<T> ::=
    qs:QuerySpecification<T> :: implicit {}
|
    LEFT_PAREN qe:QueryExpressionScalar<T> RIGHT_PAREN :: implicit {}
;

public interface QuerySpecification<T> extends Scalar<T> : Query<T> {}


public class AbstractQuerySpecification<T> implements QuerySpecification<T> {}

<T> QuerySpecification<T> ::=
    qb:QueryBaseScalar<T> :: implicit {}
|
    qb:QueryBaseScalar<T> wc:WhereClause ::
         public QuerySpecification<T> where {}
;


# QueryBase and QueryBaseScalar

public interface QueryBase<T> : Query<T> {}

public class AbstractQueryBase<T> implements QueryBase<T> {}

# see SelectList.sdl, FromClause.sdl
# all methods derived from syntax are protected
# public methods do not include FromClause

<T> QueryBase<T> ::=
    SELECT sl:SelectList<T> fc:FromClause :: protected QueryBase<T> from {}
|
    SELECT ALL sl:SelectList<T> fc:FromClause ::
         protected AbstractQueryBase<T> all {
         }
|
    SELECT DISTINCT sl:SelectList<T> fc:FromClause ::
         protected AbstractQueryBase<T> distinct {
         }
;
# implicit conversion from SelectList

:: <T> QueryBase<T> implicit(final SelectList<T> sl) {
    return from(sl, new ImplicitFromClause());
}

# public methods for construction of AbstractQueryBase
:: public <T> AbstractQueryBase<T> all(final SelectList<T> sl) {
    return all(sl, new ImplicitFromClause());
}

:: public <T> AbstractQueryBase<T> distinct(final SelectList<T> sl) {
    return distinct(sl, new ImplicitFromClause());
}

# :: <T> QueryBase<T> implicit (final SelectList<T> sl) {}

public interface QueryBaseScalar<T> extends Scalar<T> :  Query<T> {}

public class AbstractQueryBaseScalar<T> implements QueryBaseScalar<T> {}

# scalar counterpart of SelectList is SelectSublist rather than SelectListScalar
# see SelectList.sdl, FromClause.sdl

<T> QueryBaseScalar<T> ::=
    SELECT sl:SelectSublist<T> fc:FromClause :: protected AbstractQueryBaseScalar<T> from {}
|
    SELECT ALL sl:SelectSublist<T> fc:FromClause ::
         protected AbstractQueryBaseScalar<T> all {
         }
|
    SELECT DISTINCT sl:SelectSublist<T> fc:FromClause ::
         protected AbstractQueryBaseScalar<T> distinct {
         }
;
