# # corresponds to direct_select-statement in Sql-2003.2
public interface SelectStatement<T> : Query<T>
{}

public class AbstractSelectStatement<T> implements SelectStatement<T>
{}

# key Simqle methods to query values

import org.simqle.Callback;
import javax.sql.DataSource;
import java.sql.SQLException;
import java.sql.PreparedStatement;
import java.sql.Connection;
import java.sql.ResultSet;
import org.simqle.Callback;
import org.simqle.Row;
import org.simqle.jdbc.ResultSetRow;
import org.simqle.jdbc.StatementParameters;
:: public <T> void scroll(final SelectStatement<T> statement,
                          final DataSource datasource,
                          final Callback<T, SQLException> callback
                          ) throws SQLException {
     final SqlContext context = new SqlContext();
     context.set(TableRegistry.class, new SelectTableRegistry(new TableNameProvider()));
     context.set(UniqueNameProvider.class, new ColumnNameProvider());
     final Query<T> query = statement.z$create$SelectStatement(context);
     final Connection connection = datasource.getConnection();
     try {
         final PreparedStatement preparedStatement = connection.prepareStatement(query.getSqlText());
         try {
             query.setParameters(new StatementParameters(preparedStatement));
             final ResultSet resultSet = preparedStatement.executeQuery();
             final Row row = new ResultSetRow(resultSet);
             try {
                 while (resultSet.next()) {
                     try {
                         callback.iterate(query.extract(row));
                     } catch (Callback.BreakException e) {
                         break;
                     }
                 }
             } finally {
                 resultSet.close();
             }
         } finally {
             preparedStatement.close();
         }
     } finally {
         connection.close();
     }
}

import javax.sql.DataSource;
import java.sql.SQLException;
import java.util.List;
::
public <T> List<T> list(final SelectStatement<T> statement,
                          final DataSource datasource) throws SQLException {
        final List<T> result = new LinkedList<T>();
        scroll(statement,  datasource,
            new Callback<T, SQLException>() {
                public void iterate(T arg) {
                    result.add(arg);
                }
             });
        return result;
    }

:: public String show(final SelectStatement<?> statement) {
        final SelectTableRegistry tableRegistry = new SelectTableRegistry(new TableNameProvider());
        // training: learn all tables participating in query
        {
            final SqlContext context = new SqlContext();
            context.set(UniqueNameProvider.class, new ColumnNameProvider());
            context.set(TableRegistry.class, tableRegistry);
            statement.z$create$SelectStatement(context);
        }
        // real generation of Sql
        {
            final SqlContext context = new SqlContext();
            context.set(UniqueNameProvider.class, new ColumnNameProvider());
            context.set(TableRegistry.class, tableRegistry);
            String sql = statement.z$create$SelectStatement(context).getSqlText();
            sql = beautifySql(sql);
            return sql;
        }
    }

:: private String beautifySql(final String source) {
        return source
                .replaceAll("([(.])\\s+", "$1")
                .replaceAll("\\s+([().,])", "$1")
                .trim();
    }



#
# import java.util.List;
# import java.util.LinkedList;
# import java.sql.SQLException;
# {
#     // TODO add scroll
#     // TODO uncomment when ready (requires FromClause)
#     /*
#     public List<T> list(final Database database)  throws SQLException {
#         final SqlContext context = new SqlContext();
#         context.set(FromClause.class, new FromClause());
#         context.set(ColumnNameProvider.class, new ColumnNameProvider());
#         this.z$prepare$zSelectStatement(context);
#         final List<T> list = new LinkedList<T>();
#         final Query<T> query = this.z$create$zSelectStatement(context);
#         database.query(query, new IteratorCallback<Row>() {
#             public int iterate(final Row row) throws SQLException {
#                 list.add(query.extract(row));
#                 return 1;
#             }
#         });
#         return list;
#     }
#     */
# public String show() {
#     final SqlContext context = new SqlContext();
#     context.set(FromClause.class, new FromClause());
#     context.set(ColumnNameProvider.class, new ColumnNameProvider());
#     context.set(SqlFactory.class, new GenericSqlFactory());
#     z$prepare$zSelectStatement(context);
#     final String sqlText = z$create$zSelectStatement(context).getSqlText();
#     return sqlText.replaceAll("([.(])(\\s+)", "$1").replaceAll("(\\s+)(([.,)(]))", "$2");
# }
# }
# 
# 
# 

# # direct_zSelectStatement:_multiple_rows ::= zCursorSpecification
# # zCursorSpecification ::= zQueryExpression [ zOrderByClause ] [ updatability_clause ]
# # updatability_clause ::= FOR { READ ONLY | UPDATE [ OF column_name_list ] }
# 
# # Simqle re-defines this in the following way:
# # updateability_clause moves to zSelectStatement;
# # OF column_name_list is not supported in the current version (0.7)
# 
# forward references: CursorSpecification, AbstractCursorSpecification

<T> SelectStatement<T> ::=
    cspec:CursorSpecification<T> :: implicit {}
|
    cspec:CursorSpecification<T>  FOR READ ONLY ::
        import java.util.LinkedList;
        public AbstractCursorSpecification<T> forReadOnly {}
|
    cspec:CursorSpecification<T> FOR UPDATE
        :: public AbstractCursorSpecification<T> forUpdate {}
;


public interface CursorSpecification<T> : Query<T> {}

public class AbstractCursorSpecification<T> implements CursorSpecification<T> {}

# #zCursorSpecification ::= zQueryExpression [ zOrderByClause ] [ updatability_clause ]
# #updatability_clause moved to zSelectStatement
# 
# see QueryExpression.sdl, Sort.sdl

<T> CursorSpecification<T> ::=
    qe:QueryExpression<T> :: implicit {}
|
    qe:QueryExpression<T> obc:OrderByClause :: protected AbstractCursorSpecification<T> orderBy {}
;

::  public <T> AbstractCursorSpecification<T> orderBy(final QueryExpression<T> qe, final SortSpecification sort, final SortSpecification... additionalSort) {
    SortSpecificationList list = createSortSpecificationList(sort);
     for (SortSpecification add: additionalSort) {
         list = appendSortSpecification(list, add);
     }
     return  orderBy(qe, createOrderByClause(list));
}


#         {
#             public CursorSpecification<T> orderBy(zSortSpecification sort, zSortSpecification... additionalSort) {
#                 final SqlFactory factory = SqlFactory.getInstance();
#                 zSortSpecificationList sortList = factory.zSortSpecificationList_IS_zSortSpecification(sort);
#                 for (zSortSpecification sortSpec: additionalSort) {
#                     sortList = factory.zSortSpecificationList_IS_zSortSpecificationList_COMMA_zSortSpecification(sortList, sortSpec);
#                 }
#                 zOrderByClause orderBy = factory.zOrderByClause_IS_ORDER_BY_zSortSpecificationList(sortList);
#                 return new CursorSpecification<T>(factory.zCursorSpecification_IS_zQueryExpression_zOrderByClause(this, orderBy));
#             }
#         }


