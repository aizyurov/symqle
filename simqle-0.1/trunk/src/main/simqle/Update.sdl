# <update statement: searched> ::= UPDATE <target table> SET <set clause list> [ WHERE <search condition> ]
# <set clause list> ::= <set clause> [ { <comma> <set clause> }... ]
# <set clause> ::=
#		<multiple column assignment>
#	|	<set target> <equals operator> <update source>
#
# <set target> ::= <update target> | <mutated set clause>
#
# <multiple column assignment> ::= <set target list> <equals operator> <assigned row>
#
# <set target list> ::= <left paren> <set target> [ { <comma> <set target> }... ] <right paren>
#
# <assigned row> ::= <contextually typed row value expression>
#
# <update target> ::=
#		<object column>
#	|	<object column> <left bracket or trigraph> <simple value specification> <right bracket or trigraph>
#
# <object column> ::= <column name>
#
# <mutated set clause> ::= <mutated target> <period> <method name>
# <update source> ::= <value expression> | <contextually typed value specification>
# <contextually typed value specification> ::=
#  		<implicitly typed value specification> | <default specification>
#
#  <implicitly typed value specification> ::= <null specification> | <empty specification>
#
#  <null specification> ::= NULL
#  <default specification> ::= DEFAULT

public interface DataChangeStatement : Sql {}

:: private Sql prepareUpdate(final DataChangeStatement statement) {
    return statement.z$create$DataChangeStatement(new SqlContext());
}

:: public String show(final DataChangeStatement statement) {
    return beautifySql(prepareUpdate(statement).getSqlText());
}

:: public int execute(final DataChangeStatement statement, final DataSource datasource) throws SQLException {
     final Sql sql = prepareUpdate(statement);
     final Connection connection = datasource.getConnection();
     try {
         final PreparedStatement preparedStatement = connection.prepareStatement(beautifySql(sql.getSqlText()));
         try {
             sql.setParameters(new StatementParameters(preparedStatement));
             return preparedStatement.executeUpdate();
         } finally {
             preparedStatement.close();
         }
     } finally {
         connection.close();
     }

}

DataChangeStatement ::=
    s:UpdateStatement :: implicit {}
#|
#    s:InsertStatement :: implicit {}
#|
#    s:DeleteStatement :: implicit {}
;

public interface UpdateStatement : Sql {}

public class AbstractUpdateStatement implements UpdateStatement {}

UpdateStatement ::=
    b:UpdateStatementBase :: implicit {}
|
    b:UpdateStatementBase wc:WhereClause ::
        public AbstractUpdateStatement where {
            public Sql z$create$UpdateStatement(final SqlContext context) {
                // a trick here: z$create$UpdateStatementBase modifies uts argument
                final Sql base = b.z$create$UpdateStatementBase(context);
                final SqlContext inner = createInnerContext(context);
                final Sql where = wc.z$create$WhereClause(inner);
                return new CompositeSql(
                        base,
                        where
                    );
            }
        }
;

public interface UpdateStatementBase : Sql {}

public class AbstractUpdateStatementBase implements UpdateStatementBase {}

UpdateStatementBase ::=
    UPDATE t:TargetTable SET l:SetClauseList :: protected AbstractUpdateStatementBase createUpdate {
        public Sql z$create$UpdateStatementBase(final SqlContext context) {
            // Modifies outer context by setting TableRegistry!
            context.set(TableRegistry.class, new DataChangeTableRegistry(t));
            // no name provider
            return new CompositeSql(UPDATE, t.z$create$TargetTable(context), SET, l.z$create$SetClauseList(context));
        }
    }
;

public interface TargetTable : Sql {
    public String getName();
}

public interface SetClauseList : Sql {}

SetClauseList ::=
    c:SetClause :: protected SetClauseList initSetList {}
|
    l:SetClauseList COMMA c:SetClause :: protected SetClauseList appendSetList {}
;

:: public AbstractUpdateStatementBase update(final TargetTable t, final SetClause first, final SetClause... other) {
    SetClauseList l = initSetList(first);
    for (SetClause c: other) {
        l = appendSetList(l, c);
    }
    return createUpdate(t, l);
}

public interface SetClause : Sql {}

public class AbstractSetClause implements SetClause {}

<T> SetClause ::=
    c:ColumnName<T> EQ e:ValueExpression<T> :: public AbstractSetClause set {}
;

:: public <T> AbstractSetClause set(final ColumnName<T> column, final T value) {
    return set(column, DynamicParameter.create(column.getElementMapper(), value));
}

SetClause ::=
    c:ColumnName<?> EQ e:ValueExpression<?> :: public AbstractSetClause setIgnoreType {}
|
    c:ColumnName<?> EQ NULL :: public AbstractSetClause setNull {}
|
    c:ColumnName<?> EQ DEFAULT :: public AbstractSetClause setDefault {}
;


public interface ColumnName<T> extends Scalar<T> : Sql {}


public class Table extends TableOrView implements TargetTable {
    public Table(String name) {
        super(name);
    }

    public Sql z$create$TargetTable(final SqlContext context) {
        return new CustomSql(getName());
    }
}

import org.simqle.UniqueNameProvider;
import org.simqle.TableNameProvider;
class DataChangeTableRegistry implements TableRegistry {

    final TargetTable targetTable;
    final UniqueNameProvider nameProvider = new TableNameProvider();


    public DataChangeTableRegistry(final TargetTable targetTable) {
        this.targetTable = targetTable;
    }

    public String findCorrelationName(TableOrView table) {
        if (table.equals(targetTable)) {
            return targetTable.getName();
        } else {
            return null;
        }
    }


    public FromClause generateFromClause() {
        throw new RuntimeException("Operation not supported");
    }


    public String generateUniqueName() {
        return nameProvider.getUniqueName();
    }


    public String getCorrelationName(TableOrView table) {
        if (table.equals(targetTable)) {
            return targetTable.getName();
        } else {
            throw new IllegalArgumentException(table.getName() + " is not legal in this context");
        }
    }


    public boolean isInTestMode() {
        return false;
    }


    public void setTestMode(boolean test) {
        // do nothing
    }


}

# public interface InsertStatement : Sql {}



