public interface ValueExpression<T> extends Scalar<T> : Sql {}

public class AbstractValue<T> implements ValueExpression<T> {}

# Hierarchy of ValueExpression approximately follws SQL standard.
# For some interfaces type parameters are bounded
# <row value expression> is not considered being <value expression>
# it is not Scalar and we have different rules for RowValueExpression and ValueExpression

<T> ValueExpression<T> ::= cve:CommonValueExpression<T> :: implicit {}
;

# see BooleanValueExpression.sdl
ValueExpression<Boolean> ::=  bve:BooleanExpression :: implicit {}
;

# no abstract class: no methods
public interface CommonValueExpression<T> extends Scalar<T> : Sql {}

#
# public interface	zRoutineInvocation<T>  extends Scalar<T> : Sql
# {}
# 
# # there are no default implementations or zRoutineInvocation
# # should be created individually
# # as factory methods
# # to have type-check of arguments
# 
# /*
# <routine invocation> ::= <routine name> <SQL argument list>
# 
# <routine name> ::= [ <schema name> <period> ] <qualified identifier>
# 
# <SQL argument list> ::= <left paren> [ <SQL argument> [ { <comma> <SQL argument> }... ] ] <right paren>
# 
# <SQL argument> ::=
# 		<value expression>
# 	|	<generalized expression>
# 	|	<target specification>
# 
# Simplified, generalized expression and target specification not supported
# */
# 
# <T> zRoutineInvocation<T> ::= rn:zRoutineName<T> LEFT_PAREN al:zArgumentList RIGHT_PAREN
#     :: Function<T>
#     {
#         protected RoutineInvocation<T> apply(zValueExpression<?> firstArg, zValueExpression<?>... otherArgs) {
#                 zArgumentList al = SqlFactory.getInstance().zArgumentList_IS_zValueExpression(firstArg);
#                 for (zValueExpression ve: otherArgs) {
#                     al = SqlFactory.getInstance().zArgumentList_IS_zArgumentList_COMMA_zValueExpression(al, ve);
#                 }
#                 return new RoutineInvocation<T>(SqlFactory.getInstance().zRoutineInvocation_IS_zRoutineName_LEFT_PAREN_zArgumentList_RIGHT_PAREN(this, al));
#         }
#     }
# 
#     | rn:zRoutineName<T> LEFT_PAREN RIGHT_PAREN
#     :: Function<T>
#     {
#         protected RoutineInvocation<T> apply() {
#                 return new RoutineInvocation<T>(_APPLY_RULE_(this));
#         }
#     }
# ;
# 
# public interface zRoutineName<T> extends Scalar<T> : Sql
# {}
# 
# public interface zArgumentList : Sql
#  {}
# 
# # zArgumentList is used only internally by Function; no implementing class
# zArgumentList ::= ve:zValueExpression<?>
#     | al:zArgumentList COMMA ve:zValueExpression<?>
# ;
# 
# public class RoutineInvocation<T> implements zRoutineInvocation<T> with sqlBuilder
# {}
# 
# public abstract class Function<T> implements zRoutineName<T>
# {
#     private final zRoutineName routineName;
#     protected Function$(final String name) {
#         routineName = new zRoutineName<T>() {
#             @Override
#             public Sql z$create$zRoutineName(final SqlContext context) {
#                 return new Identifier(name);
#             }
# 
#             @Override
#             public void z$prepare$zRoutineName(final SqlContext context) {
#                 // do nothing
#             }
# 
#             @Override
#             public T value(final Element element) throws SQLException {
#                 return Function$.this.value(element);
#             }
#         };
#     }
# 
#     @Override
#     public final void z$prepare$zRoutineName(final SqlContext context) {
#        routineName.z$prepare$zRoutineName(context);
#     }
# 
#     @Override
#     public final Sql z$create$zRoutineName(final SqlContext context) {
#         return routineName.z$create$zRoutineName(context);
#     }
# 
# 
#         /**
#         * To be implemented in derived classes.
#         *
#         */
#     public abstract T value(final Element element) throws SQLException ;
# 
# }
# 
