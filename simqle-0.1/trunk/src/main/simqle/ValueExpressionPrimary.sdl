public interface ValueExpressionPrimary<T> extends Scalar<T> : Sql {}

<T> ValueExpressionPrimary<T> ::=
    LEFT_PAREN e:ValueExpression<T> RIGHT_PAREN :: implicit {}
|
    p:DynamicParameterSpecification<T> :: implicit {}
|
	c:ColumnReference<T> :: implicit {}
|
	s:ScalarSubquery<T> :: public AbstractValueExpressionPrimary<T> queryValue {}
|
    e:CaseExpression<T> :: implicit {}
|
	r:RoutineInvocation<T> :: implicit {}
;

public class AbstractValueExpressionPrimary<T> implements ValueExpressionPrimary<T> {}


public interface DynamicParameterSpecification<T> extends Scalar<T> : Sql {
}

import org.simqle.SqlParameter;
import org.simqle.SqlParameters;
public class DynamicParameter<T> implements DynamicParameterSpecification<T> {
    private final ElementMapper<T> mapper;
    private final T value;

    private DynamicParameter(final ElementMapper<T> mapper, T value) {
        this.mapper = mapper;
        this.value = value;
     }

     public static <T> DynamicParameter<T> create(final ElementMapper<T> mapper, final T value) {
        return new DynamicParameter<T>(mapper, value); 
     }

            /**
            * Creates an Sql representing <code>this</code>
            * @param context the Sql construction context
            * @return sql conforming to <code>this</code> syntax
            */
            public final Sql z$create$DynamicParameterSpecification(SqlContext context) {
                return new Sql() {
                    @Override
                    public String getSqlText() {
                        return "?";
                    }

                    @Override
                    public void setParameters(final SqlParameters p) throws SQLException {
                        mapper.setValue(p.next(), value);
                    }
                };
            }

            /**
            * Implement in derived classes
            */
             public final ElementMapper<T> getElementMapper() {
                return mapper;
             }

}

public interface ColumnReference<T> extends Scalar<T> : Sql {}

import org.simqle.CompositeSql;
import org.simqle.SqlTerm;
import org.simqle.ElementMapper;
public class Column<T> implements ColumnReference<T>, ColumnName<T> {
    private final Identifier columnName;
    private final TableOrView owner;
    private final ElementMapper mapper;

    Column(final ElementMapper mapper, final String name,  final TableOrView owner)  {
        this.mapper = mapper;
        this.columnName = new DefinedIdentifier(name);
        this.owner = owner;
     }

    public Sql z$create$ColumnReference(SqlContext context) {
        final String correlationName = context.get(TableRegistry.class).getCorrelationName(owner);
        return new CompositeSql(new DefinedIdentifier(correlationName).z$create$Identifier(context),
                            SqlTerm.PERIOD,
                            columnName.z$create$Identifier(context));

    }

    public Sql z$create$ColumnName(final SqlContext context) {
        // make sure that owner is valid in the context
        // by getting correlation name; the result is not used
        context.get(TableRegistry.class).getCorrelationName(owner);
        return columnName.z$create$Identifier(context);
    }

    public final ElementMapper<T> getElementMapper() {
        return mapper;
    }
}


public interface RoutineInvocation<T> extends Scalar<T> : Sql {}

public class AbstractRoutineInvocation<T> implements RoutineInvocation<T> {}

import java.util.Set;
import java.util.Collections;
<T> RoutineInvocation<T> ::=
    rn:RoutineName<T> LEFT_PAREN al:ArgumentList RIGHT_PAREN
        :: private AbstractRoutineInvocation<T> invoke {}
|
    rn:RoutineName<T> LEFT_PAREN RIGHT_PAREN
        :: private AbstractRoutineInvocation<T> invoke {}
;

:: public <T> AbstractRoutineInvocation<T> apply(RoutineName<T> routine, ValueExpression<?>... arg) {
    if (arg.length == 0) {
        return invoke(routine);
    } else {
        ArgumentList al = createArgument(arg[0]);
        int i;
        for (i=1; i<arg.length; i++) {
            al = appendArgument(al, arg[i]);
        }
        return invoke(routine, al);
    }
}

public interface RoutineName<T> extends Scalar<T> : Sql {}

public interface ArgumentList : Sql {}

ArgumentList ::=
    e:ValueExpression<?> :: protected ArgumentList createArgument {}
|
    al:ArgumentList COMMA e:ValueExpression<?>
        :: protected ArgumentList appendArgument {}
;

import org.simqle.CustomSql;
public class SqlFunction<T> implements RoutineName<T> {
    private final String name;
    private final ElementMapper<T> mapper;

    private SqlFunction(final String name, final ElementMapper<T> mapper) {
        this.name = name;
        this.mapper = mapper;
    }

    public Sql z$create$RoutineName(SqlContext context) {
        return new CustomSql(name);
    }

    public ElementMapper<T> getElementMapper() {
        return mapper;
    }

    public static <T> SqlFunction<T> create(final String name, final ElementMapper<T> mapper) {
        return new SqlFunction<T>(name, mapper);
    }

}


public interface CaseExpression<T> extends Scalar<T> : Sql {}

# Case abbreviations are not included here (considering them as functions, e.g nullIf)
# only <searched case> is supported
# <searched case> ::= CASE <searched when clause>... [ <else clause> ] END

<T> CaseExpression<T> ::= CASE l:SearchedWhenClauseList<T> END :: implicit {}
;

public interface SearchedWhenClauseList<T> extends Scalar<T> : Sql {}

public class AbstractSearchedWhenClauseList<T> implements SearchedWhenClauseList<T> {}

<T> SearchedWhenClauseList<T> ::=
    l:SearchedWhenClauseBaseList<T> :: implicit {}
|
    l:SearchedWhenClauseBaseList<T> e:ElseClause<T> :: public AbstractSearchedWhenClauseList<T> orElse {}
;

public interface SearchedWhenClauseBaseList<T> extends Scalar<T> : Sql {}
public class AbstractSearchedWhenClauseBaseList<T> implements SearchedWhenClauseBaseList<T> {}

<T> SearchedWhenClauseBaseList<T> ::=
    c:SearchedWhenClause<T> :: implicit {}
|
    l:SearchedWhenClauseBaseList<T> c:SearchedWhenClause<T> :: public AbstractSearchedWhenClauseBaseList<T> orWhen {}
|
    l:SearchedWhenClauseBaseList<T> c:ThenNullClause :: public AbstractSearchedWhenClauseBaseList<T> orWhen {}
;

public interface SearchedWhenClause<T> extends Scalar<T> : Sql {}
public class AbstractSearchedWhenClause<T> implements SearchedWhenClause<T> {}

<T> SearchedWhenClause<T> ::=
    WHEN cond:BooleanExpression THEN e:ValueExpression<T> :: public AbstractSearchedWhenClause<T> then {
        private final ElementMapper<T> mapper = e.getElementMapper();
        public final ElementMapper<T> getElementMapper() {
            return mapper;
        }
    }
;

public interface ThenNullClause : Sql {}

ThenNullClause ::= WHEN cond:BooleanExpression THEN NULL :: public ThenNullClause thenNull {}
;

public interface ElseClause<T> extends Scalar<T> : Sql {}

<T> ElseClause<T> ::= ELSE e:ValueExpression<T> :: implicit {}
;