public interface zFromClause : Sql
{}

import org.simqle.Sql;
import org.simqle.SqlContext;
/**
 * @author Alexander Izyurov
 */
public class ImplicitFromClause implements zFromClause {
    /**
     * Defines Sql produced by this syntactic element.
     * Implementations should produce Sql conforming to the productions specified above.
     *
     * @param context - construction context: dialect, tables available in this and enclosing contexts etc.
     * @return sql as required for zFromClause syntax
     */
    public Sql z$create$zFromClause(SqlContext context) {
        return context.get(FromClause.class).z$create$zFromClause(context);
    }

    public void z$prepare$zFromClause(SqlContext context) {
        // do nothing
    }
}

class FromClause implements zFromClause
import java.util.*;
import org.simqle.util.TSort;
{
    private final FromClause enclosingClause;
    private final NameGenerator nameGenerator;
    private final Map<zTable, Identifier> localTables = new HashMap<zTable, Identifier>();

    protected final NameGenerator getNameGenerator() {
        return nameGenerator;
    }

    public FromClause$(final FromClause enclosingClause) {
        this.enclosingClause = enclosingClause;
        this.nameGenerator = enclosingClause !=null ? enclosingClause.getNameGenerator() : new NameGenerator();
    }

    public FromClause$() {
        this(null);
     }

    public void z$prepare$zFromClause(SqlContext context) {
        throw new RuntimeException("This code should not be reachable");
    }

    public Sql z$create$zFromClause(final SqlContext context) {
        throw new RuntimeException("Not implemented");
    }

    public Identifier getCorrelationName(zTable table) {
        if (localTables.containsKey(table)) {
            Identifier name = localTables.get(table);
            if (name==null) {
                name = nameGenerator.generate();
                localTables.put(table, name);
            }
            return name;
        } else if (enclosingClause!=null) {
            return enclosingClause.getCorrelationName(table);
        } else {
            throw new IllegalStateException("Table "+table+" has not been registered in FromClause");
        }
    }

    public boolean addTable(zTable table) {
        if (!isAvailable(table)) {
            localTables.put(table, null);
            return true;
        } else {
            return false;
        }
    }

    public boolean isAvailable(zTable table) {
        return enclosingClause != null && enclosingClause.isAvailable(table) || localTables.containsKey(table);
    }

    public Set<zTable> getAllTables() {
        Set<zTable> allTables = new HashSet<zTable>(localTables.keySet());
        if (enclosingClause!=null) {
            allTables.addAll(enclosingClause.getAllTables());
        }
        return allTables;
    }

    private static class NameGenerator {
        private int counter=0;

        private Identifier generate() {
            return new Identifier("T"+(counter++));
        }
    }

}

zFromClause ::= FROM  tr:zTableReference
;

interface zTableReference : Sql
{}

# zTableReference is used internally by FromClause; no implementing class
zTableReference ::=  tp:zTablePrimary
     | tr:zTableReference jt:zTableJoin
;

public interface zTablePrimary : Sql
{}

# used internally by Table
# Correlation name is added automatically
# zTablePrimary ::= id:Identifier [ AS Identifier ]
# zTablePrimary ::= id:Identifier


public interface zTableJoin  : Sql
{}

public abstract class Table implements zTable
{
    private boolean isJoined = false;
    private zTableJoin tableJoin;
    private zTablePrimary tablePrimary;

    private void startJoin() {
        if (isJoined) {
            throw new IllegalStateException("Double join");
        }
        isJoined = true;
    }

    protected Table$(final String name) {
        tablePrimary = new zTablePrimary() {
            @Override
            public void z$prepare$zTablePrimary(final SqlContext context) {
            // do nothing
            }
            public Sql z$create$zTablePrimary(final SqlContext context) {
                return new Identifier(name);
            }
        };
    }

    public Sql z$create$zTable(final SqlContext context)          {
                return
                 isJoined ?
                z$create$zTableJoin(context) :
                z$create$zTablePrimary(context);
            }

    public Sql z$create$zTableJoin(final SqlContext context)          {
                return tableJoin.z$create$zTableJoin(context);
            }

    public void z$prepare$zTable(final SqlContext context)          {
                if (isJoined) {
                    z$prepare$zTableJoin(context);
                } else {
                    z$prepare$zTablePrimary(context);
                }
            }

    public void z$prepare$zTableJoin(final SqlContext context)          {
                final FromClause fromClause = context.get(FromClause.class);
                fromClause.addTable(this);
                // propagate to dependencies
                tableJoin.z$prepare$zTableJoin(context);
            }

    public void z$prepare$zTablePrimary(final SqlContext context)          {
                final FromClause fromClause = context.get(FromClause.class);
                fromClause.addTable(this);
                tablePrimary.z$prepare$zTablePrimary(context);
            }

    public Sql z$create$zTablePrimary(final SqlContext context) {
        final FromClause fromClause = context.get(FromClause.class);
        final Sql name = tablePrimary.z$create$zTablePrimary(context);
        final Sql correlationName = fromClause.getCorrelationName(this);
        return new CompositeSql(name, SqlTerminal.AS, correlationName);
    }

}

public interface zTable extends zTablePrimary, zTableJoin : Sql
{}





zTableJoin ::=
      CROSS JOIN tp:zTablePrimary
      :: Table
      {
        public void crossJoin() {
            startJoin();
            tableJoin = _APPLY_RULE_(this);
        }
      }
|     INNER JOIN tp:zTablePrimary js:zJoinSpecification
      :: Table
      {
        public void innerJoin(final zJoinSpecification js) {
            startJoin();
            tableJoin = _APPLY_RULE_(this, js);
        }
      }
|     OUTER JOIN tp:zTablePrimary js:zJoinSpecification
      :: Table
      {
        public void outerJoin(final zJoinSpecification js) {
            startJoin();
            tableJoin = _APPLY_RULE_(this, js);
        }
      }
|     LEFT OUTER JOIN tp:zTablePrimary js:zJoinSpecification
      :: Table
      {
        public void leftJoin(final zJoinSpecification js) {
            startJoin();
            tableJoin = _APPLY_RULE_(this, js);
        }
      }
|
      RIGHT OUTER JOIN tp:zTablePrimary js:zJoinSpecification
      :: Table
      {
        public void rightJoin(final zJoinSpecification js) {
            startJoin();
            tableJoin = _APPLY_RULE_(this, js);
        }
      }
;


interface zJoinSpecification : Sql
{}


# zJoinSpecification ::= join_condition | named_columns_join
# join_condition ::= ON search_condition

# We do not support named_columns_join

zJoinSpecification ::= ON e:boolean_value_expression
    :: BooleanValueExpression mimics JoinSpecification
    {}
;

class JoinSpecification implements zJoinSpecification with builder
{}

