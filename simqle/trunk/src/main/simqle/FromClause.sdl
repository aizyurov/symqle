public interface zFromClause : Sql
{}

import org.simqle.Sql;
import org.simqle.SqlContext;
/**
 * @author Alexander Izyurov
 */
public class ImplicitFromClause implements zFromClause {
    /**
     * Defines Sql produced by this syntactic element.
     * Implementations should produce Sql conforming to the productions specified above.
     *
     * @param context - construction context: dialect, tables available in this and enclosing contexts etc.
     * @return sql as required for zFromClause syntax
     */
    public Sql z$create$zFromClause(SqlContext context) {
        return context.get(FromClause.class).z$create$zFromClause(context);
    }

    public void z$prepare$zFromClause(SqlContext context) {
        // do nothing
    }
}

class FromClause implements zFromClause
import java.util.*;
import org.simqle.util.TSort;
{
    private final FromClause enclosingClause;
    private final NameGenerator nameGenerator;
    private final Map<zTable, Identifier> localTables = new HashMap<zTable, Identifier>();

    protected final NameGenerator getNameGenerator() {
        return nameGenerator;
    }

    public FromClause$(final FromClause enclosingClause) {
        this.enclosingClause = enclosingClause;
        this.nameGenerator = enclosingClause !=null ? enclosingClause.getNameGenerator() : new NameGenerator();
    }

    public FromClause$() {
        this(null);
     }

    public void z$prepare$zFromClause(SqlContext context) {
        throw new RuntimeException("This code should not be reachable");
    }

    public Sql z$create$zFromClause(final SqlContext context) {
        throw new RuntimeException("Not implemented");
    }

    public Identifier getCorrelationName(zTable table) {
        if (localTables.containsKey(table)) {
            Identifier name = localTables.get(table);
            if (name==null) {
                name = nameGenerator.generate();
                localTables.put(table, name);
            }
            return name;
        } else if (enclosingClause!=null) {
            return enclosingClause.getCorrelationName(table);
        } else {
            throw new IllegalStateException("Table "+table+" has not been registered in FromClause");
        }
    }

    public boolean addTable(zTable table) {
        if (!isAvailable(table)) {
            localTables.put(table, null);
            return true;
        } else {
            return false;
        }
    }

    public boolean isAvailable(zTable table) {
        return enclosingClause != null && enclosingClause.isAvailable(table) || localTables.containsKey(table);
    }

    public Set<zTable> getAllTables() {
        Set<zTable> allTables = new HashSet<zTable>(localTables.keySet());
        if (enclosingClause!=null) {
            allTables.addAll(enclosingClause.getAllTables());
        }
        return allTables;
    }

    private static class NameGenerator {
        private int counter=0;

        private Identifier generate() {
            return new Identifier("T"+(counter++));
        }
    }

}

zFromClause ::= FROM  tr:zTableReference
;

interface zTableReference : Sql
{}

# zTableReference is used internally by FromClause; no implementing class
zTableReference ::=  tp:table_primary
     | tr:zTableReference jt:joined_table
;

public interface table_primary : Sql
{}

public interface joined_table  : Sql
{}

public class Table implements zTable with sqlBuilder
{}

public interface zTable extends table_primary, joined_table : Sql
{}


/*
joined_table ::=
      CROSS JOIN tp:table_primary
      {
        return new AbstractJoinedTable() {
            @Override
            public void z$prepare$joined_table(final SqlContext context) {
                 tp.z$prepare$table_primary(context);
            }
            @Override
            public Sql z$create$joined_table(final SqlContext context) {
                return new CompositeSql(CROSS, JOIN, tp.z$create$table_primary(context));
            }
        };
      }
      :: Table
      {
        public JoinedTable crossJoin() {
            return new JoinedTable(_APPLY_RULE_(this));
        }
      }
|     INNER JOIN tp:table_primary js:join_specification
      {
        return new AbstractJoinedTableWithCondition(tp, js) {
            @Override
            public Sql z$create$joined_table(final SqlContext context) {
                return new CompositeSql(INNER, JOIN, tp.z$create$table_primary(context), js.z$create$join_specification(context));
            }
        };


      }
      :: Table
      {
        public JoinedTable innerJoin(join_specification js) {
            return new JoinedTable(_APPLY_RULE_(this, js));
        }
      }
|     OUTER JOIN tp:table_primary js:join_specification
      {
        return new AbstractJoinedTableWithCondition(tp, js) {
            @Override
            public Sql z$create$joined_table(final SqlContext context) {
                return new CompositeSql(OUTER, JOIN, tp.z$create$table_primary(context), js.z$create$join_specification(context));
            }
        };

      }
      :: Table
      {
        public JoinedTable outerJoin(join_specification js) {
            return new JoinedTable(_APPLY_RULE_(this, js));
        }
      }
|     LEFT OUTER JOIN tp:table_primary js:join_specification
      {
        return new AbstractJoinedTableWithCondition(tp, js) {
            @Override
            public Sql z$create$joined_table(final SqlContext context) {
                return new CompositeSql(LEFT, OUTER, JOIN, tp.z$create$table_primary(context), js.z$create$join_specification(context));
            }
        };

      }
      :: Table
      {
        public JoinedTable leftJoin(join_specification js) {
            return new JoinedTable(_APPLY_RULE_(this, js));
        }
      }
|
      RIGHT OUTER JOIN tp:table_primary js:join_specification
      {
        return new AbstractJoinedTableWithCondition(tp, js) {
            @Override
            public Sql z$create$joined_table(final SqlContext context) {
                return new CompositeSql(RIGHT, OUTER, JOIN, tp.z$create$table_primary(context), js.z$create$join_specification(context));
            }
        };

      }
      :: Table
      {
        public JoinedTable rightJoin(join_specification js) {
            return new JoinedTable(_APPLY_RULE_(this, js));
        }
      }
;
*/


interface join_specification : Sql
{}


# join_specification ::= join_condition | named_columns_join
# join_condition ::= ON search_condition

# We do not support named_columns_join

join_specification ::= ON e:boolean_value_expression
    :: BooleanValueExpression mimics JoinSpecification
    {}
;

class JoinSpecification implements join_specification with builder
{}

