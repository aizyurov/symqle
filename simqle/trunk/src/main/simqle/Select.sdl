# corresponds to direct_select-statement in Sql-2003.2
public interface select_statement<T> : Query<T> {}

class SelectStatement<T> implements select_statement<T> with sqlBuilder
import java.util.List;
import java.util.LinkedList;
import java.sql.SQLException;
{
    // TODO add scroll
    // TODO uncomment when ready (requires FromClause)
    /*
    public List<T> list(final Database database)  throws SQLException {
        final SqlContext context = new SqlContext();
        context.set(FromClause.class, new FromClause());
        context.set(ColumnNameProvider.class, new ColumnNameProvider());
        this.z$prepare$select_statement(context);
        final List<T> list = new LinkedList<T>();
        final Query<T> query = this.z$create$select_statement(context);
        database.query(query, new IteratorCallback<Row>() {
            public int iterate(final Row row) throws SQLException {
                list.add(query.extract(row));
                return 1;
            }
        });
        return list;
    }
    */
}



# direct_select_statement:_multiple_rows ::= cursor_specification
# cursor_specification ::= query_expression [ order_by_clause ] [ updatability_clause ]
# updatability_clause ::= FOR { READ ONLY | UPDATE [ OF column_name_list ] }

# Simqle re-defines this in the following way:
# updateability_clause moves to select_statement;
# OF column_name_list is not supported in the current version (0.7)

<T> select_statement<T> ::= cspec:cursor_specification<T>
    :: CursorSpecification<T> mimics SelectStatement<T> {}

| cspec:cursor_specification<T>  FOR READ ONLY
    :: CursorSpecification<T>
    {
        public SelectStatement<T> forReadOnly() {
            return new SelectStatement<T>(_APPLY_RULE_(this));
        }
    }

| cspec:cursor_specification<T> FOR UPDATE
    :: CursorSpecification<T>
    {
        public SelectStatement<T> forUpdate() {
            return new SelectStatement<T>(_APPLY_RULE_(this));
        }
    }
;

interface cursor_specification<T> : Query<T> {}

class CursorSpecification<T> implements cursor_specification<T> with sqlBuilder
{}

#cursor_specification ::= query_expression [ order_by_clause ] [ updatability_clause ]
#updatability_clause moved to select_statement
#cursor_specification_scalar introduced

<T> cursor_specification<T> ::= cspec:cursor_specification_scalar<T>
    :: CursorSpecificationScalar<T> mimics CursorSpecification<T>
    {}
| qe:query_expression<T>
    ::  QueryExpression<T> mimics CursorSpecification<T>
    {}

| qe:query_expression<T> obc:order_by_clause
    :: QueryExpression<T>
        {
            public CursorSpecification<T> orderBy(sort_specification sort, sort_specification... additionalSort) {
                final SqlFactory factory = SqlFactory.getInstance();
                sort_specification_list sortList = factory.sort_specification_list_IS_sort_specification(sort);
                for (sort_specification sortSpec: additionalSort) {
                    sortList = factory.sort_specification_list_IS_sort_specification_list_COMMA_sort_specification(sortList, sortSpec);
                }
                order_by_clause orderBy = factory.order_by_clause_IS_ORDER_BY_sort_specification_list(sortList);
                return new CursorSpecification<T>(factory.cursor_specification_IS_query_expression_order_by_clause(this, orderBy));
            }
        }
;

public interface cursor_specification_scalar<T> extends Scalar<T> : Query<T>
 {}

public class CursorSpecificationScalar<T> implements cursor_specification_scalar<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{}

public interface query_expression<T> : Query<T>
{}

public class QueryExpression<T> implements query_expression<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{}


<T> cursor_specification_scalar<T> ::= qe:query_expression_scalar<T>
      :: QueryExpressionScalar<T> mimics CursorSpecificationScalar<T>
      {}
| qu:query_expression_scalar<T> obc:order_by_clause
        :: QueryExpressionScalar<T>
        {
            public CursorSpecificationScalar<T> orderBy(sort_specification sort, sort_specification... additionalSort) {
                final SqlFactory factory = SqlFactory.getInstance();
                sort_specification_list sortList = factory.sort_specification_list_IS_sort_specification(sort);
                for (sort_specification sortSpec: additionalSort) {
                    sortList = factory.sort_specification_list_IS_sort_specification_list_COMMA_sort_specification(sortList, sortSpec);
                }
                order_by_clause orderBy = factory.order_by_clause_IS_ORDER_BY_sort_specification_list(sortList);
                return new CursorSpecificationScalar<T>(factory.cursor_specification_scalar_IS_query_expression_scalar_order_by_clause(this, orderBy));
            }
        }
;


public interface query_expression_scalar<T> extends Scalar<T> : Query<T>
{}

public class QueryExpressionScalar<T> implements query_expression_scalar<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{}

# we have different rules for query_expression and query_expression-scalar
# the first one is just query_base with (maybe) where clause
# the second one is really an expression, which may include union, intersection etc.

<T> query_expression<T> ::= qb:query_base<T>
    :: QueryBase<T> mimics QueryExpression<T>
    {}

|   qb:query_base<T> wc:where_clause
    :: QueryBase<T>
    {
        public QueryExpression<T> where(where_clause condition) {
            return new QueryExpression<T>(_APPLY_RULE_(this, condition));
        }
    }
;

public interface query_base<T> : Query<T>
{}

public class QueryBase<T> implements query_base<T> with sqlBuilder
{}


<T> query_expression_scalar<T> ::= qt:query_term<T>
    :: QueryTerm<T> mimics QueryExpressionScalar<T>
     {}

|    qe:query_expression_scalar<T> UNION ALL qt:query_term<T>
    :: QueryExpressionScalar<T>
    {
    public QueryExpressionScalar<T> unionAll(query_term<T> queryTerm) {
        return new QueryExpressionScalar<T>(_APPLY_RULE_(this, queryTerm));
        }
    }

|    qe:query_expression_scalar<T> UNION DISTINCT qt:query_term<T>
    :: QueryExpressionScalar<T>
    {
    public QueryExpressionScalar<T> unionDistinct(query_term<T> queryTerm) {
        return new QueryExpressionScalar<T>(_APPLY_RULE_(this, queryTerm));
        }
    }

|    qe:query_expression_scalar<T> EXCEPT ALL qt:query_term<T>
    :: QueryExpressionScalar<T>
    {
    public QueryExpressionScalar<T> exceptAll(query_term<T> queryTerm) {
        return new QueryExpressionScalar<T>(_APPLY_RULE_(this, queryTerm));
        }
    }

|    qe:query_expression_scalar<T> EXCEPT DISTINCT qt:query_term<T>
    :: QueryExpressionScalar<T>
    {
    public QueryExpressionScalar<T> exceptDistinct(query_term<T> queryTerm) {
        return new QueryExpressionScalar<T>(_APPLY_RULE_(this, queryTerm));
        }
    }
;

public interface query_term<T> extends Scalar<T> :  Query<T>
{}

public class QueryTerm<T> implements query_term<T> with SqlBuilder
{}







