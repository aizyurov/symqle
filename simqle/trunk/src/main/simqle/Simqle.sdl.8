/* this is for reference, we start from these targets
direct_SQL_data_statement ::=
// delete_statement:_searched
		delete_statement
// direct_select_statement:_multiple_rows
	|	select_statement
	|	insert_statement
// update_statement:_searched
	|	update_statement
// to be supported in the next version
	|	merge_statement
// not supported
	|	temporary_table_declaration
*/

interface select_statement<T> (Query<T>) ;

class SelectStatement<T> implements select_statement<T> with sqlBuilder
import java.util.List;
import java.util.LinkedList;
import java.sql.SQLException;
{
    // TODO add scroll
    public List<T> list(final Database database)  throws SQLException {
        final SqlContext context = new SqlContext();
        context.set(FromClause.class, new FromClause());
        context.set(ColumnNameProvider.class, new ColumnNameProvider());
        this.z$prepare$select_statement(context);
        final List<T> list = new LinkedList<T>();
        final Query<T> query = this.z$create$select_statement(context);
        database.query(query, new IteratorCallback<Row>() {
            public int iterate(final Row row) throws SQLException {
                list.add(query.extract(row));
                return 1;
            }
        });
        return list;
    }
}
;


/*
direct_select_statement:_multiple_rows ::= cursor_specification
cursor_specification ::= query_expression [ order_by_clause ] [ updatability_clause ]
updatability_clause ::= FOR { READ ONLY | UPDATE [ OF column_name_list ] }

Simqle re-defines this in the following way:
updateability_clause moves to select_statement;
OF column_name_list is not supported in the current version (0.7)
*/
<T> select_statement<T> ::= cursor_specification<T>
    ( SelectStatement<T> ::= CursorSpecification<T> )

| cursor_specification<T>  FOR READ ONLY
    ( + CursorSpecification<T> )
    {
        public SelectStatement<T> forReadOnly() {
            final SqlFactory factory = SqlFactory.getInstance();
            return new SelectStatement<T>(factory._THIS_PRODUCTION_(this));
        }
    }

| cursor_specification<T> FOR UPDATE
    ( + CursorSpecification<T> )
    {
        public SelectStatement<T> forUpdate() {
            final SqlFactory factory = SqlFactory.getInstance();
            return new SelectStatement<T>(factory._THIS_PRODUCTION_(this));
        }
    }
;

interface cursor_specification<T> (Query<T>) ;

class CursorSpecification<T> implements cursor_specification<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{};

/*
cursor_specification ::= query_expression [ order_by_clause ] [ updatability_clause ]
updatability_clause moved to select_statement
cursor_specification_scalar introduced
*/

<T> cursor_specification<T> ::= cursor_specification_scalar<T>
    ( CursorSpecification<T> ::= CursorSpecificationScalar<T> )

| query_expression<T>
      ( CursorSpecification<T> ::= QueryExpression<T> )

| query_expression<T> order_by_clause
        ( + QueryExpression<T> )
        {
            // TODO: add arguments and implement
            CursorSpecification<T> orderBy() {
                throw new RuntimeException("FIXME");
            }
        }
;


interface cursor_specification_scalar<T> (Query<T>) extends Scalar<T> ;

class CursorSpecificationScalar<T> implements cursor_specification_scalar<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{};

interface query_expression<T> (Query<T>) ;

class QueryExpression<T> implements query_expression<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{};


/*
query_expression_scalar introduced
It does not have its own orderBy;
 it is inherited from query_expression
 ( and scalar context is lost)

*/
<T> cursor_specification_scalar<T> ::= query_expression_scalar<T>
      ( CursorSpecificationScalar<T> ::= QueryExpressionScalar<T> )

| query_expression_scalar<T> order_by_clause
        ( + QueryExpressionScalar<T> )
        {
            // TODO: add arguments and implement
            CursorSpecificationScalar<T> orderBy() {
                throw new RuntimeException("FIXME");
            }
        }
;


interface query_expression_scalar<T> (Query<T>) extends Scalar<T> ;

class QueryExpressionScalar<T> implements query_expression_scalar<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{};

/*
query_expression ::= [ with_clause ] query_expression_body
query_expression_body ::= non-join_query_expression | joined_table

with_clause and joined_table are not supported (not needed)
union, intersect and except are supported only for scalars
so, the syntax is simplified
*/


<T> query_expression<T> ::= query_expression_scalar<T>
    ( QueryExpression<T> ::= QueryExpressionScalar<T> )

|  query_primary<T>
    ( QueryExpression<T> ::= QueryPrimary<T> )
;

/*
non-join_query_expression ::=
		non-join_query_term
	|	query_expression_body UNION [ ALL | DISTINCT ] [ corresponding_spec ] query_term
	|	query_expression_body EXCEPT [ ALL | DISTINCT ] [ corresponding_spec ] query_term
*/

<T> query_expression_scalar<T> ::= query_term<T>
    ( QueryExpressionScalar<T> ::= QueryTerm<T> )

|    query_expression_scalar<T> UNION ALL query_term<T>
    ( + QueryExpressionScalar<T> )
    {
    public QueryExpressionScalar<T> unionAll(query_term<T> queryTerm) {
        return new QueryExpressionScalar<T>(
            SqlFactory.getInstance()._THIS_PRODUCTION_(this, queryTerm)
            );
        }
    }

|    query_expression_scalar<T> UNION DISTINCT query_term<T>
    ( + QueryExpressionScalar<T> )
    {
    public QueryExpressionScalar<T> unionDistinct(query_term<T> queryTerm) {
        return new QueryExpressionScalar<T>(
            SqlFactory.getInstance()._THIS_PRODUCTION_(this, queryTerm)
            );
        }
    }

|    query_expression_scalar<T> EXCEPT ALL query_term<T>
    ( + QueryExpressionScalar<T> )
    {
    public QueryExpressionScalar<T> exceptAll(query_term<T> queryTerm) {
        return new QueryExpressionScalar<T>(
            SqlFactory.getInstance()._THIS_PRODUCTION_(this, queryTerm)
            );
        }
    }

|    query_expression_scalar<T> EXCEPT DISTINCT query_term<T>
    ( + QueryExpressionScalar<T> )
    {
    public QueryExpressionScalar<T> exceptDistinct(query_term<T> queryTerm) {
        return new QueryExpressionScalar<T>(
            SqlFactory.getInstance()._THIS_PRODUCTION_(this, queryTerm)
            );
        }
    }
;

interface query_term<T> (Query<T>) extends Scalar<T> ;

class QueryTerm<T> implements query_term<T> with SqlBuilder
 import java.util.List;
 import java.sql.SQLException;
{};

<T> query_term<T> ::= query_primary_scalar<T>
    ( QueryTerm<T> ::= QueryPrimaryScalar<T> )

|   query_term<T> INTERSECT ALL query_primary_scalar<T>
    ( + QueryTerm<T> )
     {
         public QueryTerm<T> intersectAll(final query_primary_scalar<T> qps) {
            return new QueryTerm<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, qps));
         }
     }

|   query_term<T> INTERSECT DISTINCT query_primary_scalar<T>
    ( + QueryTerm<T> )
     {
         public QueryTerm<T> intersectDistinct(final query_primary_scalar<T> qps) {
            return new QueryTerm<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, qps));
         }
     }
;

interface query_primary<T> (Query<T>) ;
class QueryPrimary<T> implements query_primary<T> with sqlBuilder
 import java.util.List;
 import java.sql.SQLException;
{};

/*
query_primary ::= non-join_query_primary | joined_table

non-join_query_primary ::= simple_table | left_paren non-join_query_expression right_paren

simple_table ::=
		query_specification
	|	table_value_constructor
	|	explicit_table
Only simple_table -> query_specification is supported
*/

<T> query_primary<T> ::= query_specification<T>
    ( QueryPrimary<T> ::= QuerySpecification<T> )
;


interface query_primary_scalar<T> (Query<T>) extends Scalar<T> ;

class QueryPrimaryScalar<T> implements query_primary_scalar<T> with sqlBuilder ;

<T> query_primary_scalar<T> ::= query_specification_scalar<T>
    ( QueryPrimaryScalar<T> ::= QuerySpecificationScalar<T> )

|  LEFT_PAREN query_expression_scalar<T> RIGHT_PAREN
{
public Query<T> z$create$query_primary_scalar(SqlContext context) {
    final Query<T> base = arg0.z$create$query_expression_scalar(context);
    return new CompoundQuery<T>(base, new CompositeSql(LEFT_PAREN, base, RIGHT_PAREN));
        }
}
    ( QueryPrimaryScalar<T> ::= QueryExpressionScalar<T> )
;


interface query_specification<T> (Query<T>) ;

class QuerySpecification<T> implements query_specification<T> with sqlBuilder ;

interface query_specification_scalar<T> (Query<T>) extends Scalar<T> ;

class QuerySpecificationScalar<T> implements query_specification_scalar<T> with sqlBuilder ;

/*
query_specification ::= SELECT [ set_quantifier ] select_list table_expression
set_quantifier ::= DISTINCT | ALL


table_expression ::=
		from_clause
		[ where_clause ]
		[ group_by_clause ]
		[ having_clause ]
		[ window_clause ]

This has been reformulated as follows:
1. Remove group_by_clause, having_clause, window_clause - not supported
2. Inline table_expression
query_specification ::= SELECT [ set_quantifier ] select_list from_clause [where_clause]
3. Introduce new non-terminal:
query_base ::= SELECT [ set_quantifier ] select_list from_clause
query_specification ::= query_base
 		|  query_base where_clause
4. Inline set_quantifier in query_base

Scalar counterparts productions are alike.
*/

<T> query_specification<T> ::= query_base<T>
    ( QuerySpecification<T> ::= QueryBase<T> )

  |  query_base<T> where_clause
    ( + QueryBase<T> )
    {
        public QuerySpecification<T> where(where_clause condition) {
            return new QuerySpecification<T>(
                SqlFactory.getInstance()._THIS_PRODUCTION_(this, condition)
                );
        }
    }
;

<T> query_specification_scalar<T> ::= query_base_scalar<T>
    ( QuerySpecificationScalar<T> ::= QueryBaseScalar<T> )

  |  query_base_scalar<T> where_clause
    ( + QueryBaseScalar<T> )
    {
        public QuerySpecificationScalar<T> where(where_clause condition) {
            return new QuerySpecificationScalar<T>(
                SqlFactory.getInstance()._THIS_PRODUCTION_(this, condition)
                );
        }
    }
;

interface query_base<T> (Query<T>) ;
interface query_base_scalar<T> (Query<T>) extends Scalar<T>;

class QueryBase<T> implements query_base<T> with sqlBuilder;

class QueryBaseScalar<T> implements query_base_scalar<T> with sqlBuilder;

<T> query_base<T> ::= SELECT select_list<T> from_clause
{
public Query<T> z$create$query_base(SqlContext context) {
    final Query<T> selectListQuery = arg0.z$create$select_list(context);
    return new CompoundQuery<T>(selectListQuery, new CompositeSql(SELECT, selectListQuery, arg1.z$create$from_clause(context)));
        }
}
    ( QueryBase<T> ::= RowValue<T> ) {
    // this is a tricky part. The user never supplies from_clause,
    // we are extracting it from Sqlcontext. So, we have only one argument
    // and can implement it transparently
    // but we have to write code of toQueryBase manually
    // providing an instance of ImplicitFromClause
        private final QueryBase<T> toQueryBase() {
            from_clause fromClause = new ImplicitFromClause();
            return new QueryBase<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
    }

| SELECT ALL select_list<T> from_clause
{
public Query<T> z$create$query_base(SqlContext context) {
    final Query<T> selectListQuery = arg0.z$create$select_list(context);
    return new CompoundQuery<T>(selectListQuery, new CompositeSql(SELECT, ALL, selectListQuery, arg1.z$create$from_clause(context)));
        }
}
     ( + RowValue<T> )
     {
        public QueryBase<T> all() {
            from_clause fromClause = new ImplicitFromClause();
            return new QueryBase<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
     }

| SELECT DISTINCT select_list<T> from_clause
{
public Query<T> z$create$query_base(SqlContext context) {
    final Query<T> selectListQuery = arg0.z$create$select_list(context);
    return new CompoundQuery<T>(selectListQuery, new CompositeSql(SELECT, ALL, selectListQuery, arg1.z$create$from_clause(context)));
        }
}
     ( + RowValue<T> )
     {
        public QueryBase<T> distinct() {
            from_clause fromClause = new ImplicitFromClause();
            return new QueryBase<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
     }
;

#################  stopped here

/* scalar counterpart of select_list is select_sublist rather than select_list_scalar */

<T> query_base_scalar<T> ::= SELECT select_sublist<T> from_clause
{
public Query<T> z$create$query_base_scalar(SqlContext context) {
    final Query<T> sql0 = arg0.z$create$select_sublist(context);
    final Sql sql1 = arg1.z$create$from_clause(context);
    return new CompoundQuery<T>(sql0, new CompositeSql(SELECT, sql0, sql1));
        }
}
    ( QueryBaseScalar<T> ::= SelectSublist<T> ) {
    // see comments to RowValue#toQueryBase()
        private final QueryBaseScalar<T> toQueryBaseScalar() {
            from_clause fromClause = new ImplicitFromClause();
            return new QueryBaseScalar<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
    }

| SELECT ALL select_sublist<T> from_clause
{
public Query<T> z$create$query_base_scalar(SqlContext context) {
    final Query<T> sql0 = arg0.z$create$select_sublist(context);
    final Sql sql1 = arg1.z$create$from_clause(context);
    return new CompoundQuery<T>(sql0, new CompositeSql(SELECT, ALL, sql0, sql1));
        }
}
     ( + Value<T> )
     {
        public QueryBaseScalar<T> all() {
            from_clause fromClause = new ImplicitFromClause();
            return new QueryBaseScalar<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
     }

| SELECT DISTINCT select_sublist<T> from_clause
{
public Query<T> z$create$query_base_scalar(SqlContext context) {
    final Query<T> sql0 = arg0.z$create$select_sublist(context);
    final Sql sql1 = arg1.z$create$from_clause(context);
    return new CompoundQuery<T>(sql0, new CompositeSql(SELECT, DISTINCT, sql0, sql1));
        }
}
     ( + Value<T> )
     {
        public QueryBaseScalar<T> distinct() {
            from_clause fromClause = new ImplicitFromClause();
            return new QueryBaseScalar<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
     }
;


interface select_list<T> (Query<T>) ;

/*
A single class RowValue represents both select_list and row_value_expression.
A more expressive and neutral name given.
*/

class RowValue<T> implements select_list<T> with selectList, row_value_expression<T>
 {
    public Sql z$create$row_value_expression(final SqlContext context) {
        // This is tricky: we form a new SqlContext without
        // ColumnNameProvider
        // then delegate to selectList
        // with this fake context AS ... are not generate,
        // so we get exactly what we need
        SqlContext fakeContext = new SqlContext();
        fakeContext.set(SqlFactory.class, context.get(SqlFactory.class));
        fakeContext.set(FromClause.class, context.get(FromClause.class));
        return this.selectList.z$create$select_list(fakeContext);
    }

    public void z$prepare$row_value_expression(final SqlContext context) {
        // same as prepare context wof select_list
        z$prepare$select_list(context);
    }
}
;


/**
select_list ::= asterisk | select_sublist [ { comma select_sublist }... ]

the first rule is not supported (used internally bypassing the API)
The last one is translated to equivalent non-deterministic rule (but we do not care)
*/

<T> select_list<T> ::= select_sublist<T>
    ( RowValue<T> ::= SelectSublist<T> )
;

<T,U> select_list<Pair<T,U>> ::= select_list<T> COMMA select_list<U>
{
    public Query<Pair<T,U>> z$create$select_list(final SqlContext context) {
        final Query<T> sql0 = arg0.z$create$select_list(context);
        final Query<U> sql1 = arg1.z$create$select_list(context);
        DataExtractor<Pair<T,U>> extractor = new DataExtractor<Pair<T, U>>() {
            public Pair<T, U> extract(final Row row) throws SQLException {
                final T first = sql0.extract(row);
                final U second = sql1.extract(row);
                return Pair.of(first, second);
            }
        };
        return new CompoundQuery<Pair<T,U>>(extractor, new CompositeSql(sql0, SqlTerminal.COMMA, sql1));
    }
}
 // more naturally implemented as static method of Values class:
 // RowValue<Pair<L,R> pairOf(RowValue<L> l, RowValue<R> r);
 // so no class member method is defined for this production
;

interface select_sublist<T> (Query<T>) extends Scalar<T> ;
class SelectSublist<T> implements select_sublist<T> with builder;

/*
select_sublist ::= derived_column | qualified_asterisk
derived_column ::= value_expression [ as_clause ]
as_clause ::= [ AS ] column_name
column_name ::= identifier

qualified asterisk not used, so we may skip derived_column
inline as_clause, column_name. We may choose to use or not to use AS. Adding it to GenericSqlFactory,
may override in dialects.
*/

<T> select_sublist<T> ::= value_expression<T> AS Identifier
{
    public void z$prepare$select_sublist(SqlContext context) {
    arg0.z$prepare$value_expression(context);
    }

    public Query<T> _GET_SQL_(SqlContext context) {
        DataExtractor<T> extractor = new DataExtractor<T>() {
            public T extract(final Row row) throws SQLException {
                return value(row.getValue(arg1.toString()));
            }
        };
        return new CompoundQuery<T>(extractor,
            new CompositeSql(arg0.z$create$value_expression(context), SqlTerminal.AS, arg1));
    }
}

|  value_expression<T>
{
public Query<T> _GET_SQL_(SqlContext context) {
    final ColumnNameProvider columnNameProvider = context.get(ColumnNameProvider.class);
        Identifier identifier = columnNameProvider.getUniqueName();
        if (identifier!=null) {
            return select_sublist_is_value_expression_AS_Identifier(arg0,
            identifier).z$create$select_sublist(context);
        } else {
            return new CompoundQuery<T>(new NullDataExtractor<T>(), arg0.z$create$value_expression(context));
        }
    }
}
    ( SelectSublist<T> ::= Value<T> )
;

interface value_expression<T> extends Scalar<T> ; // not Query<T>!


// A single class Value implements both select_sublist and value_expressin

class Value<T> implements value_expression<T> with valueExpression ;

/*************

value_expression ::=
		common_value_expression
	|	boolean_value_expression
	|	row_value_expression
etc.

Simqle syntax is quite different. We do not separate value expression types.
row_value_expression is not value_expression. Instead of
select_list ::= select_sublist ::= row_value_expression
we have RowValue<T> extends row_value_expression<T> directly - TODO
all common_value_expression are alike, we do not distinct them.
Both common_value_expression
*/

<T> value_expression<T> ::=
		common_value_expression<T>
		( Value<T> ::= CommonValueExpression<T> )

	|	boolean_value_expression<T>
	    ( Value<T> ::= BooleanValueExpression<T> )
;

interface common_value_expression<T> extends Scalar<T> ;
class CommonValueExpression<T> implements common_value_expression<T> with sqlBuilder;


/*
 Most instances will be <Boolean>, but SQL allows any valid primary_value_expression
 and database boolean value may be mapped to another type in Java
 */
interface boolean_value_expression<T> extends Scalar<T> ;
class BooleanValueExpression<T> implements boolean_value_expression<T> with sqlBuilder;


<T> common_value_expression<T> ::=  LEFT_PAREN value_expression<T> RIGHT_PAREN
    ( CommonValueExpression<T> ::= Value<T> )
    | value_expression_primary<T>
    ( CommonValueExpression<T> ::= ValueExpressionPrimary<T> )
;


/*
For boolean_value_expression syntax is very close to sql-2003
But not type paremeters: all methods do not have
type parametes, return type is <Boolean> and arguments are <?>
*/


<T> boolean_value_expression<T> ::= boolean_term<T>
		    ( BooleanValueExpression<T> ::= BooleanTerm<T> )
;
boolean_value_expression<Boolean> ::=	boolean_value_expression<?> OR boolean_term<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
		( + BooleanValueExpression ) {
		    public BooleanValueExpression<Boolean> or(boolean_term<?> term) {
		        return new BooleanValueExpression<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, term));
		    }
		}
;

interface boolean_term<T> extends Scalar<T> ;
class BooleanTerm<T> implements boolean_term<T> with sqlBuilder ;


<T> boolean_term<T> ::= boolean_factor<T>
    ( BooleanTerm<T> ::= BooleanFactor<T> )
;
boolean_term<Boolean> ::= boolean_term<?> AND boolean_factor<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
	( + BooleanTerm<T> ) {
	    public BooleanTerm<Boolean> and(BooleanFactor<?> factor) {
		        return new BooleanTerm<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, factor));
	    }
	}
;

interface boolean_factor<T> extends Scalar<T> ;
class BooleanFactor<T> implements boolean_factor<T> with sqlBuilder ;


<T> boolean_factor<T> ::= boolean_test<T>
    ( BooleanFactor<T> ::= BooleanTest<T> )

  | NOT boolean_test<T>
    ( + BooleanTest<T> )
    {
        BooleanFactor<T> negate() {
            return new BooleanFactor<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }
;

interface boolean_test<T> extends Scalar<T> ;
class BooleanTest<T> implements boolean_test<T> with sqlBuilder ;

<T> boolean_test<T> ::= boolean_primary<T>
    ( BooleanTest<T> ::= BooleanPrimary<T> )
;

interface boolean_primary<T> extends Scalar<T> ;
class BooleanPrimary<T> implements boolean_primary<T> with sqlBuilder ;



boolean_test<Boolean> ::= boolean_primary<?>  IS  NOT  TRUE
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isNotTrue() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }

|  boolean_primary<?>  IS  TRUE
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isTrue() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }

| boolean_primary<?>  IS  NOT  FALSE
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isNotFalse() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }

|  boolean_primary<?>  IS  FALSE
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isFalse() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }

| boolean_primary<?>  IS  NOT  UNKNOWN
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isNotUnknown() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }

|  boolean_primary<?>  IS  UNKNOWN
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isUnknown() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }
;

/*
truth_value ::= TRUE | FALSE | UNKNOWN
*/


/*
boolean_primary ::= predicate | boolean_predicand

boolean_predicand ::=
		parenthesized_boolean_value_expression
	|	value_expression_primary

parenthesized_boolean_value_expression ::= left_paren boolean_value_expression right_paren

simplified by inlining
*/


<T> boolean_primary<T> ::= predicate<T>
    ( BooleanPrimary<T> ::= Predicate<T> )
  | LEFT_PAREN boolean_value_expression<T> RIGHT_PAREN
    ( BooleanPrimary<T> ::= BooleanValueExpression<T> )
  | value_expression_primary<T>
    ( BooleanPrimary<T> ::= ValueExpressionPrimary<T> )
;

interface predicate<T> extends Scalar<T> ;
class Predicate<T> implements predicate<T> with sqlBuilder;

/**
predicate ::=
		comparison_predicate
	|	between_predicate - full release
	|	in_predicate
	|	like_predicate - full release
	|	similar_predicate -- not supported by MySql; skipped
	|	null_predicate
	|	quantified_comparison_predicate - full release
	|	exists_predicate
	|	unique_predicate - full release
	|	normalized_predicate - not supported
	|	match_predicate - full release
	|	overlaps_predicate- not supported
	|	distinct_predicate- not supported
	|	member_predicate- not supported
	|	submultiset_predicate- not supported
	|	set_predicate- not supported
	|	type_predicate- not supported
*/

<T> predicate<T> ::=
		comparison_predicate<T>
		( Predicate<T> ::= ComparisonPredicate<T> )
	|	in_predicate<T>
		( Predicate<T> ::= InPredicate<T> )
	|	null_predicate<T>
		( Predicate<T> ::= NullPredicate<T> )
	|	exists_predicate<T>
		( Predicate<T> ::= ExistsPredicate<T> )
;

interface comparison_predicate<T> extends Scalar<T> ;
interface in_predicate<T> extends Scalar<T> ;
interface null_predicate<T> extends Scalar<T> ;
interface exists_predicate<T> extends Scalar<T> ;

class ComparisonPredicate<T> implements comparison_predicate<T> with SqlBuilder;
class InPredicate<T> implements in_predicate<T> with SqlBuilder;
class NullPredicate<T> implements null_predicate<T> with SqlBuilder;
class ExistsPredicate<T> implements exists_predicate<T> with SqlBuilder;


/*
comparison_predicate ::= row_value_predicand comparison_predicate_part_2

comparison_predicate_part_2 ::= comp_op row_value_predicand

comp_op ::=
		equals_operator
	|	not_equals_operator
	|	less_than_operator
	|	greater_than_operator
	|	less_than_or_equals_operator
	|	greater_than_or_equals_operator

*/

comparison_predicate<Boolean> ::=
    row_value_predicand<?> EQ row_value_predicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> equal(row_value_predicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
  | row_value_predicand<?> NE row_value_predicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> notEqual(row_value_predicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
  | row_value_predicand<?> LT row_value_predicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> less(row_value_predicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
  | row_value_predicand<?> GT row_value_predicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> greater(row_value_predicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
  | row_value_predicand<?> LE row_value_predicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> lessOrEqual(row_value_predicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
  | row_value_predicand<?> GE row_value_predicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> greaterOrEqual(row_value_predicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
;



interface row_value_predicand<T> ;
class RowValuePredicand<T> implements row_value_predicand with sqlBuilder ;

/*
row_value_predicand ::=
		row_value_special_case
	|	row_value_constructor_predicand

row_value_special_case ::= nonparenthesized_value_expression_primary

row_value_constructor_predicand ::=
		common_value_expression
	|	boolean_predicand
	|	explicit_row_value_constructor

Removed unnecessary mediators
common_value_expression<T> includes value_expression_primary<T>, so "special_case" is covered by it
*/
<T> row_value_predicand<T> ::= common_value_expression<T>
    ( RowValuePredicand<T> ::= CommonValueExpression<T> )

    | LEFT_PAREN boolean_value_expression<T> RIGHT_PAREN
        ( RowValuePredicand<T> ::= BooleanValueExpression<T> )

	|	explicit_row_value_constructor<T>
	    ( RowValuePredicand<T> ::= ExplicitRowValueConstructor<T> )
;


/********** TODO **********/

/*
row_value_expression ::=
		row_value_special_case
	|	explicit_row_value_constructor

row_value_special_case ::= nonparenthesized_value_expression_primary

explicit_row_value_constructor ::=
		left_paren row_value_constructor_element comma row_value_constructor_element_list right_paren
	|	ROW left_paren row_value_constructor_element_list right_paren
	|	row_subquery

row_value_constructor_element_list ::=
		row_value_constructor_element [ { comma row_value_constructor_element }... ]

row_value_constructor_element ::= value_expression

row_subquery ::= subquery

Changes:
1. inline row_value_special_case, row_value_constructor_element, row_subquery
2. change right recursion to left explicit_row_value_constructor
3. Allow row_value_constructor_element to be row_value_constructor_element_list
   and allow both members to be row
We have 2 possibilites for construction of row_value_expression from value_expression: as special case and with
ROW. Choosing the first one; the second not needed.

*/

interface row_value_expression<T> ;

<T> row_value_expression<T> ::= value_expression<T>
    |  explicit_row_value_constructor<T> ;

<T,U> explicit_row_value_constructor<Pair<T,U>> ::=
		LEFT_PAREN row_value_constructor_element_list<T> COMMA row_value_constructor_element_list<U> RIGHT_PAREN
// this is used by Values.pairOf(...) method

	|	subquery<T>

;

interface row_value_constructor_element_list<T> ;
class RowValueConstructorElementList<T> implements row_value_constructor_element_list<T> with sqlBuilder;

<T> row_value_constructor_element_list<T> ::= value_expression<T>
    ( RowValueConstructorElementList<T> ::= Value<T> )

  |  explicit_row_value_constructor<T>
        (  RowValueConstructorElementList<T> ::= ExplicitRowValueConstructor<T> )
;

interface explicit_row_value_constructor<T> ;
class ExplicitRowValueConstructor<T> implements explicit_row_value_constructor<T> with sqlBuilder;


interface value_expression_primary<T> extends Scalar<T> ;
class ValueExpressionPrimary<T> implements value_expression_primary<T>  with sqlBuilder;

/**************************** TODO *********************/

/*
nonparenthesized_value_expression_primary ::=
		unsigned_value_specification
	|	column_reference
	|	set_function_specification
	|	window_function
	|	scalar_subquery
	|	case_expression
	|	cast_specification
	|	field_reference
	|	subtype_treatment
	|	method_invocation
	|	static_method_invocation
	|	new_specification
	|	attribute_or_method_reference
	|	reference_resolution
	|	collection_value_constructor
	|	array_element_reference
	|	multiset_element_reference
	|	routine_invocation
	|	next_value_expression

*/


<T> value_expression_primary<T> ::=
		dynamic_parameter_specification<T>
	|	column_reference<T>
	    (ValueExpressionPrimary<T> ::= Column<T> )
	|	scalar_subquery<T>
	    ( ValueExpressionPrimary<T> ::= ScalarSubquery<T> )
	|	routine_invocation<T>
	|	next_value_expression<T>
;

// TODO abstract classes!

interface	dynamic_parameter_specification<T> extends Scalar<T> ;
abstract class DynamicParameter<T> implements dynamic_parameter_specification<T> with sqlBuilder;
interface	column_reference<T> extends Scalar<T> ;
abstract class Column<T> implements column_reference<T>
{
    private final Identifier name;
    private final Table owner;

    protected Column(String name, Table owner) {
        this.name = new Identifier(name);
        this.owner = owner;
    }

    public void z$prepare$column_reference(SqlContext context) {
        owner.z$prepare$table_reference(context);
    }

    /**
     * Defines Sql produced by this syntactic element.
     * Implementations should produce Sql conforming to the productions specified above.
     *
     * @param context - construction context: dialect, tables available in this and enclosing contexts etc.
     * @return sql as required for column_reference syntax
     */
    public Sql z$create$column_reference(SqlContext context) {
        final FromClause fromClause = context.get(FromClause.class);
        final Identifier tableCorrelationName = fromClause.getCorrelationName(owner);
        return new CompositeSql(tableCorrelationName, SqlTerminal.PERIOD, name);
    }
}
;
interface	scalar_subquery<T> extends Scalar<T> ;
class ScalarSubquery<T> implements scalar_subquery<T> with sqlBuilder;
interface	routine_invocation<T>  extends Scalar<T> ;
class RoutineInvocation<T> implements routine_invocation<T> with sqlBuilder;
interface	next_value_expression<T>  extends Scalar<T> ;
class NextValueExpression<T> implements next_value_expression<T> with sqlBuilder;


<T> scalar_subquery<T> ::= LEFT_PAREN query_expression_scalar<T> RIGHT_PAREN
{
    public Sql z$create$scalar_subquery(SqlContext context) {
        SqlContext innerContext = new SqlContext();
        innerContext.set(ColumnNameProvider.class, new NullColumnNameProvider());
        innerContext.set(SqlFactory.class, context.get(SqlFactory.class));
        // create an empty FromClase for query_expression_scalar with current FromClause as enclosing
        innerContext.set(FromClause.class, new FromClause(context.get(FromClause.class)));
        arg0.z$prepare$query_expression_scalar(innerContext);
        final Query<T> base = arg0.z$create$query_expression_scalar(innerContext);
        return new CompoundQuery(base, new CompositeSql(LEFT_PAREN, base, RIGHT_PAREN));
    }

    public void z$prepare$scalar_subquery(SqlContext context) {
        // do nothing
    }
}
    ( ScalarSubquery<T> ::= QueryExpressionScalar<T> )
;

interface subquery<T> ;
class Subquery<T> implements subquery<T> with sqlBuilder ;

interface where_clause ;

interface from_clause ;

/*
from_clause ::= FROM table_reference_list
table_reference_list ::= table_reference [ { comma table_reference }... ]
table_reference ::= table_primary_or_joined_table [ sample_clause ]
table_primary_or_joined_table ::= table_primary | joined_table

table_primary ::=
		table_or_query_name [ [ AS ] correlation_name [ left_paren derived_column_list right_paren ] ]
	|	derived_table [ AS ] correlation_name [ left_paren derived_column_list right_paren ]
	|	lateral_derived_table [ AS ] correlation_name [ left_paren derived_column_list right_paren ]
	|	collection_derived_table [ AS ] correlation_name [ left_paren derived_column_list right_paren ]
	|	table_function_derived_table [ AS ] correlation_name [ left_paren derived_column_list right_paren ]
	|	only_spec [ [ AS ] correlation_name [ left_paren derived_column_list right_paren ] ]
	|	left_paren joined_table right_paren

joined_table ::=
		cross_join
	|	qualified_join
	|	natural_join
	|	union_join

cross_join ::= table_reference CROSS JOIN table_primary

qualified_join ::= table_reference [ join_type ] JOIN table_reference join_specification

natural_join ::= table_reference NATURAL [ join_type ] JOIN table_primary

union_join ::= table_reference UNION JOIN table_primary

*** Changes:
1. implicitt cross joins are not supported, so table_reference_list can be only table_reference
2. table_or_query_name is the only supported variant of table_primary
3. qualified_join is re-formulated to contain only table_brinary after join type
4. natural joins are not supported (not needed)
5. union joins are not supported (mostly not supported by popular RDBMS)
6. Sample_clause not supported
7. projections (derived_column_list) not supported
8. table_or_query_name [ [ AS ] correlation_name - both are just Identifier, AS omitted

*/

from_clause ::= FROM  table_reference ;
interface table_reference ;

table_reference ::=  table_primary
    ( TableReference ::= Table )
     | joined_table
     ( TableReference ::= JoinedTable )
;

class TableReference implements table_reference with builder ;

interface table_primary ;
interface joined_table;

class FromClause implements from_clause
import java.util.*;
import org.simqle.util.TSort;


{

    private final Map<Table, Identifier> localTables = new HashMap<Table, Identifier>();

    private final FromClause enclosingClause;
    private final NameGenerator nameGenerator;

    private int tableCounter = 0;
    private final String correlationNameFormat = "T%d";

    public Identifier getCorrelationName(Table table) {
        if (localTables.containsKey(table)) {
            Identifier name = localTables.get(table);
            if (name==null) {
                name = nameGenerator.generate();
                localTables.put(table, name);
            }
            return name;
        } else if (enclosingClause!=null) {
            return enclosingClause.getCorrelationName(table);
        } else {
            throw new IllegalStateException("Table "+table+" has not been registered in FromClause");
        }
    }

    public FromClause(final FromClause enclosingClause) {
        this.enclosingClause = enclosingClause;
        this.nameGenerator = enclosingClause !=null ? enclosingClause.nameGenerator : new NameGenerator();
    }

    public FromClause() {
        this(null);
     }

    public void z$prepare$from_clause(SqlContext context) {
        throw new RuntimeException("This code should not be reachable");
    }

    public boolean addTable(Table table) {
        if (!isAvailable(table)) {
            localTables.put(table, null);
            return true;
        } else {
            return false;
        }
    }

    public Sql z$create$from_clause(final SqlContext context) {
        TSort<Table> tSort = new TSort<Table>();
        // TODO some RDBMS allow emtry FromClause
        if (localTables.size()==0) {
            throw new IllegalStateException("No referenced tables");
        }
        for (Table table: localTables.keySet()) {
            tSort.add(table);

            SqlContext probeContext = new SqlContext();
            probeContext.set(FromClause.class, new FromClause());
            probeContext.set(SqlFactory.class, context.get(SqlFactory.class));
            table.z$prepare$table_reference(probeContext);
            final Set<Table> dependencies = new HashSet<Table>(
                    probeContext.get(FromClause.class).localTables.keySet()
                    );
            // remove self-dependency
            dependencies.remove(table);
            for (Table dependency: dependencies) {
                tSort.add(table, dependency);
            }
        }
        // TODO better diagnostics on IllegalSTateException
        // cyclic dependency
        final List<Table> sortedTables = tSort.sort();
        table_reference tableReference = sortedTables.get(0);
        for (int i = 1; i< sortedTables.size(); i++) {
            final Table t = sortedTables.get(i);
            tableReference = t.makeJoinedTable(tableReference);
        }
        // TODO take SqlFactory from the context
        return SqlFactory.getInstance().from_clause_is_FROM_table_reference(tableReference).z$create$from_clause(context);
    }

    private boolean isAvailable(Table table) {
        if (enclosingClause!=null && enclosingClause.isAvailable(table)) {
            return true;
        } else {
            return localTables.containsKey(table);
        }
    }

    private static class NameGenerator {
        private int counter=0;

        private Identifier generate() {
            return new Identifier("T"+(counter++));
        }
    }

}
;

class Table implements table_primary {
    private final Identifier tableOrQueryName;
    public Table(String name) {
        tableOrQueryName = new Identifier(name);
    }
    private enum JoinType {
        cross,
        inner,
        outer,
        left,
        right
    }
    private join_specification joinSpecification = null;
    private JoinType joinType = null;

    private void setJoinType(JoinType joinType) {
        if (this.joinType!=null) {
            throw new IllegalStateException("Already joined");
        }
        this.joinType = joinType;
    }
    public void joinCross() {
        setJoinType(joinType.cross);
    }
    public void joinLeft(join_specification joinSpecification) {
        setJoinType(joinType.left);
        this.joinSpecification = joinSpecification;
    }


    public Sql z$create$table_primary(final SqlContext context) {
        final FromClause fromClause = context.get(FromClause.class);
        final Identifier correlationName = fromClause.getCorrelationName(this);
        return new CompositeSql(tableOrQueryName, correlationName);
    }

    protected JoinedTable makeJoinedTable(table_reference tableReference) {
        if (joinType==null) {
            throw new IllegalStateException("No join defined for this table"+tableOrQueryName);
        }
        final joined_table.Builder joinedTableBuilder;
        switch (joinType) {
            case cross:
                joinedTableBuilder = SqlFactory.getInstance().joined_table_is_table_reference_CROSS_JOIN_table_primary(tableReference, this);
                break;
            case left:
                joinedTableBuilder = SqlFactory.getInstance()
                .joined_table_is_table_reference_LEFT_OUTER_JOIN_table_primary_join_specification(tableReference, this, joinSpecification);
                break;
            default:
                throw new IllegalStateException("Unexpected join type "+joinType);
        }
        return new JoinedTable(joinedTableBuilder);
    }

    public void z$prepare$table_primary(SqlContext context) {
        final FromClause fromClause = context.get(FromClause.class);
        if (fromClause.addTable(this) && joinSpecification!=null) {
            joinSpecification.z$prepare$join_specification(context);
        }
    }
}
;

table_primary ::= Identifier AS Identifier ;

/*
see Table.join(table_reference)
*/
joined_table ::=
      table_reference CROSS JOIN table_primary
|     table_reference INNER JOIN table_primary join_specification
|     table_reference OUTER JOIN table_primary join_specification
|     table_reference LEFT OUTER JOIN table_primary join_specification
|     table_reference RIGHT OUTER JOIN table_primary join_specification ;


class JoinedTable implements joined_table with builder;

interface join_specification;

/*
join_specification ::= join_condition | named_columns_join
join_condition ::= ON search_condition

We do not support named_columns_join
*/

join_specification ::= ON search_condition
    ( JoinSpecification ::= SearchCondition )
;

class JoinSpecification implements join_specification with builder;

interface search_condition ;

class SearchCondition implements search_condition with builder;

search_condition ::= boolean_value_expression
    ( SearchCondition ::= BooleanValueExpression )
;

class WhereClause implements where_clause with builder;

where_clause ::= WHERE search_condition
        ( WhereClause ::= SearchCondition )
;



interface order_by_clause ;

// no class OrderByClause!

