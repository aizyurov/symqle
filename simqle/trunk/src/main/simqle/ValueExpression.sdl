public interface value_expression<T> extends Scalar<T> : Sql
{}

public class Value<T> implements value_expression<T> with valueExpression
{}


<T> value_expression<T> ::=
		cve:common_value_expression<T>
		:: CommonValueExpression<T> mimics Value<T>
		{}
;
value_expression<Boolean> ::= bve: boolean_value_expression
	    :: BooleanValueExpression mimics Value<Boolean>
	    {}
;

public interface common_value_expression<T> extends Scalar<T> : Sql
{}

public class CommonValueExpression<T> implements common_value_expression<T> with sqlBuilder
{}


/*
 Most instances will be <Boolean>, but SQL allows any valid primary_value_expression
 and database boolean value may be mapped to another type in Java
 */
public interface boolean_value_expression extends Scalar<Boolean> : Sql
{}

public class BooleanValueExpression implements boolean_value_expression with sqlBuilder
{}

# common_value_expression
<T> common_value_expression<T> ::=  LEFT_PAREN ve:value_expression<T> RIGHT_PAREN
    :: Value<T> mimics CommonValueExpression<T>
    {}

    | vep: value_expression_primary<T>
    :: ValueExpressionPrimary<T> mimics CommonValueExpression<T>
    {}
;


# For boolean_value_expression syntax is very close to sql-2003
# But not type paremeters: all methods do not have
# type parametes, return type is <Boolean> and arguments are <?>

boolean_value_expression ::= bt:boolean_term
		    :: BooleanTerm mimics BooleanValueExpression
		    {}

    |   bve:boolean_value_expression OR bvt:boolean_term
		:: BooleanValueExpression {
		    public BooleanValueExpression or(boolean_term term) {
		        return new BooleanValueExpression(_APPLY_RULE_(this, term));
		    }
		}
;

public interface boolean_term extends Scalar<Boolean> : Sql
{}

public class BooleanTerm implements boolean_term with sqlBuilder
{}

boolean_term ::= bf:boolean_factor
    :: BooleanFactor mimics BooleanTerm
    {}

   |  bt:boolean_term AND bf:boolean_factor
	::BooleanTerm {
	    public BooleanTerm and(BooleanFactor factor) {
		        return new BooleanTerm(_APPLY_RULE_(this, factor));
	    }
	}
;

public interface boolean_factor extends Scalar<Boolean> : Sql
{}

public class BooleanFactor implements boolean_factor with sqlBuilder
{}

boolean_factor ::= bt:boolean_test
    :: BooleanTest mimics BooleanFactor
    {}

  | NOT bt:boolean_test
    :: BooleanTest
    {
        BooleanFactor negate() {
            return new BooleanFactor(_APPLY_RULE_(this));
        }
    }
;

public interface boolean_test extends Scalar<Boolean> : Sql
{}

public class BooleanTest implements boolean_test with sqlBuilder
{}


boolean_test ::= bp:boolean_primary
    :: BooleanPrimary mimics BooleanTest
    {}

|  bp:boolean_primary  IS  NOT  TRUE
    :: BooleanPrimary
    {
        public BooleanTest isNotTrue() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }

|  bp:boolean_primary  IS  TRUE
    :: BooleanPrimary
    {
        public BooleanTest isTrue() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }

| bp:boolean_primary  IS  NOT  FALSE
    :: BooleanPrimary
    {
        public BooleanTest isNotFalse() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }

|  bp:boolean_primary  IS  FALSE
    :: BooleanPrimary
    {
        public BooleanTest isFalse() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }

| bp:boolean_primary  IS  NOT  UNKNOWN
    :: BooleanPrimary
    {
        public BooleanTest isNotUnknown() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }

|  bp:boolean_primary  IS  UNKNOWN
    :: BooleanPrimary
    {
        public BooleanTest isUnknown() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }
;

interface boolean_primary extends Scalar<Boolean> : Sql
{}

class BooleanPrimary implements boolean_primary with sqlBuilder
{}




public interface value_expression_primary<T> extends Scalar<T> : Sql
{}

public class ValueExpressionPrimary<T> implements value_expression_primary<T>  with sqlBuilder
{}



