public interface value_expression<T> extends Scalar<T> : Sql
{}

public class Value<T> implements value_expression<T> with valueExpression
{}


<T> value_expression<T> ::=
		cve:common_value_expression<T>
		:: CommonValueExpression<T> mimics Value<T>
		{}
;
value_expression<Boolean> ::= bve: boolean_value_expression
	    :: BooleanValueExpression mimics Value<Boolean>
	    {}
;

public interface common_value_expression<T> extends Scalar<T> : Sql
{}

public class CommonValueExpression<T> implements common_value_expression<T> with sqlBuilder
{}


/*
 Most instances will be <Boolean>, but SQL allows any valid primary_value_expression
 and database boolean value may be mapped to another type in Java
 */
public interface boolean_value_expression extends Scalar<Boolean> : Sql
{}

public class BooleanValueExpression implements boolean_value_expression with sqlBuilder
{}

# common_value_expression
<T> common_value_expression<T> ::=  LEFT_PAREN ve:value_expression<T> RIGHT_PAREN
    :: Value<T> mimics CommonValueExpression<T>
    {}

    | vep: value_expression_primary<T>
    :: ValueExpressionPrimary<T> mimics CommonValueExpression<T>
    {}
;


# For boolean_value_expression syntax is very close to sql-2003
# But not type paremeters: all methods do not have
# type parametes, return type is <Boolean> and arguments are <?>

boolean_value_expression ::= bt:boolean_term
		    :: BooleanTerm mimics BooleanValueExpression
		    {}

    |   bve:boolean_value_expression OR bvt:boolean_term
		:: BooleanValueExpression {
		    public BooleanValueExpression or(boolean_term term) {
		        return new BooleanValueExpression(_APPLY_RULE_(this, term));
		    }
		}
;

interface boolean_term extends Scalar<Boolean> : Sql
{}

class BooleanTerm implements boolean_term with sqlBuilder
{}


public interface value_expression_primary<T> extends Scalar<T> : Sql
{}

public class ValueExpressionPrimary<T> implements value_expression_primary<T>  with sqlBuilder
{}



