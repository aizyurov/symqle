# This file contains templates for Symqle, Dialect and GenericDialect.
# Methods are added to the classes during code generation

# Scalar interface is also defined here, because code generator should know it

import java.sql.*;
import java.util.*;
import javax.sql.DataSource;
import org.symqle.common.*;
import org.symqle.querybuilder.*;
import org.symqle.jdbc.Configuration;
import org.symqle.jdbc.UpdatableConfiguration;
import static org.symqle.common.SqlContext.Builder;
public final class Symqle  {
    private Symqle() {
    }

    static {
        // for 100% coverage
        new Symqle();
    }

    protected static SqlContext makeLearningContext(final SqlContext context) {
        return context.newBuilder().
                put(Dialect.class, new DebugDialect()).
                put(Configuration.class, getDebugConfiguration()).
                put(ColumnNameGenerator.class, new UniqueColumnNameGenerator()).
                toSqlContext();
    }

}


import org.symqle.common.Sql;
/** This interface declares methods for construction of SQL nonterminal symbols.
*   Each method corresponds to one syntactic rule. Method arguments are nonterminal symbols
* from the right part. Terminal symbols are not parameters; they have fixed values.
*/
public interface Dialect  {
    /**
     * Name of this dialect.
     * Typically names returned by {@link java.sql.DatabaseMetaData#getDatabaseProductName()} are used
     * as dialect names.
     * @return dialect name
     */
    String getName();
    /**
     * Name of table (or view), which is guaranteed to have exactly one row.
     * E.g. Oracle dialect returns "dual".
     * Used to create FROM clause if there are no tables in current context.
     * @return table/view name, null if no such table is available.
     */
    String fallbackTableName();
    /**
    * Formats an SQL statement as appropriate for this dialect.
    * For example, removes extra whitespace
    * @param source the raw SQL statement
    * @return formatted statement
    */
    String formatSql(String source);
}


import java.sql.SQLException;
import java.util.regex.Pattern;
import org.symqle.common.SqlParameters;
import org.symqle.common.Sql;
import org.symqle.common.CompositeSql;
import org.symqle.common.MalformedStatementException;
import static org.symqle.querybuilder.SqlTerm.*;
/**
* A standard straighforward implementation of Dialect.
* Each nonterminal symbol is constructed exactly as required by the rule.
* Subclasses may override methods preserving semantics.
* e.g. replace {@code concat(qe, EXCEPT, qt)} for {@code concat(qe, MINUS, qt)}
* in {@link #QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_EXCEPT_QueryTerm(org.symqle.common.Sql, org.symqle.common.Sql)}
*/
public class GenericDialect implements Dialect {

    public String getName() {
        return "Generic";
    }

    @Override
    public String fallbackTableName() {
        throw new MalformedStatementException(getName() + " dialect does not support selects with no tables");
    }

    protected final Sql concat(final Sql first, final Sql... other) {
        return new CompositeSql(first, other);
    }

    /**
    * Removes extra whitespace.
    * Whitespace is removed before [,.()] and after [.(]
    * Descendants may use different formatting
    */
    public String formatSql(String source) {
        String s = REPEATING_WHITESPACE.matcher(source).replaceAll(" ");
        s = UNNEEDED_SPACE_AFTER.matcher(s).replaceAll("");
        s = UNNEEDED_SPACE_BEFORE.matcher(s).replaceAll("");
        return s.trim();
    }

    private final static Pattern REPEATING_WHITESPACE = Pattern.compile("\\s+");
    private final static Pattern UNNEEDED_SPACE_AFTER = Pattern.compile("(?<=[(.]) ");
    private final static Pattern UNNEEDED_SPACE_BEFORE = Pattern.compile(" (?=[().,])");
}

import org.symqle.common.Sql;
public class DebugDialect extends GenericDialect {

    public DebugDialect() {}

    @Override
    public String fallbackTableName() {
        return null;
    }

}


import org.symqle.common.Mapper;

/**
 * Scalar corresponds to one element of a tuple.
 * It can be mapped to some Java type: values of this type
 * can be retrieved from a definite column of a ResultSet and may be set as SQL parameters.
 * @author lvovich
 * @param <T> the Java type to which this Scalar is mapped.
 */
public interface Scalar<T> {

    /**
     * Mapper for this Scalar.
     * @return the mapper
     */
    Mapper<T> getMapper();

}

