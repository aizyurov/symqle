# This file contains templates for Symqle, Dialect and GenericDialect.
# Methods are added to the classes during code generation

# Scalar interface is also defined here, because code generator should know it

import org.symqle.common.*;
import org.symqle.jdbc.*;
import org.symqle.querybuilder.*;

import java.sql.Date;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import static org.symqle.common.SqlContext.Builder;
/**
* This class contains the logic of sql building. Other org.symqle.sql classes call its methods to construct
* more complex clauses.
*/
public final class Symqle  {
    private Symqle() {
    }

    static {
        // for 100% coverage
        new Symqle();
    }

    protected static SqlContext makeLearningContext(final SqlContext context) {
        return context.newBuilder().
                put(Dialect.class, new DebugDialect()).
                put(Configuration.class, getDebugConfiguration()).
                put(ColumnNameGenerator.class, new UniqueColumnNameGenerator()).
                toSqlContext();
    }

}


import org.symqle.common.Sql;
/** This interface declares methods for construction of SQL nonterminal symbols.
*   Each method corresponds to one syntactic rule. Method arguments are nonterminal symbols
* from the right part. Terminal symbols are not parameters; they have fixed values.
*/
public interface Dialect  {
    /**
     * Name of this dialect.
     * Typically names returned by {@link java.sql.DatabaseMetaData#getDatabaseProductName()} are used
     * as dialect names.
     * @return dialect name
     */
    String getName();
    /**
     * Name of table (or view), which is guaranteed to have exactly one row.
     * E.g. Oracle dialect returns "dual".
     * Used to create FROM clause if there are no tables in current context.
     * @return table/view name, null if no such table is available.
     */
    String fallbackTableName();
}


import org.symqle.common.Sql;
import org.symqle.common.CompositeSql;
import org.symqle.common.MalformedStatementException;
import static org.symqle.querybuilder.SqlTerm.*;
/**
* A standard straighforward implementation of Dialect.
* Each nonterminal symbol is constructed exactly as required by the rule.
* Subclasses may override methods preserving semantics.
* e.g. replace {@code concat(qe, EXCEPT, qt)} for {@code concat(qe, MINUS, qt)}
* in {@link #QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_EXCEPT_QueryTerm(org.symqle.common.Sql, org.symqle.common.Sql)}
*/
public class GenericDialect implements Dialect {

    /**
    * Name of this dialect.
    * Subclasses must override.
    * @return "Generic"
    */
    public String getName() {
        return "Generic";
    }

    /**
     * Generic dialect does not allow no FROM clause and has no replacement.
     * @return never; always throws MalformedStatementException
     */
    @Override
    public String fallbackTableName() {
        throw new MalformedStatementException(
              getName() + " dialect does not support selects with no tables");
    }

    /**
    * A shortcut for new CompositeSql(first, other).
    * @param first the first Sql
    * @param other zero or more other Sqls
    * @return concatenation of arguments
    */
    protected final Sql concat(final Sql first, final Sql... other) {
        return new CompositeSql(first, other);
    }

}

/**
* A Dialect suitable for debugging. It allows not tables in FROM clause, all other methods behave as GenericDialect.
*/
public class DebugDialect extends GenericDialect {

    /**
     * Debug dialect allows no FROM clause.
     * @return null
     */
    @Override
    public final String fallbackTableName() {
        return null;
    }

}


import org.symqle.common.Mapper;

/**
 * Scalar corresponds to one element of a tuple.
 * It can be mapped to some Java type: values of this type
 * can be retrieved from a definite column of a ResultSet and may be set as SQL parameters.
 * @author lvovich
 * @param <T> the Java type to which this Scalar is mapped.
 */
public interface Scalar<T> {

    /**
     * Mapper for this Scalar.
     * @return the mapper
     */
    Mapper<T> getMapper();

}

