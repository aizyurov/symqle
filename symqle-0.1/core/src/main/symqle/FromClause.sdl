public interface FromClause : SqlBuilder {}

# <from clause> ::= FROM <table reference list>
#
# <table reference list> ::= <table reference> [ { <comma> <table reference> }... ]

FromClause ::= FROM t:TableReferenceList :: protected FromClause createFrom {}
;

public interface TableReferenceList : SqlBuilder {}

# used by FromClauseBuilder, protected methods
TableReferenceList ::= r:TableReference :: protected TableReferenceList createTableReferenceList {}
|
    l:TableReferenceList COMMA r:TableReference :: protected TableReferenceList appendTableReferenceList {}
;

# <table reference> ::= <table primary or joined table> [ <sample clause> ]
# Symqle does not support <sample clause>, so we are omitting <tableprimary or joined table>

# <joined table> ::=
#		<cross join>
#	|	<qualified join>
#	|	<natural join>
#	|	<union join>
#
# <cross join> ::= <table reference> CROSS JOIN <table primary>
#
# <qualified join> ::= <table reference> [ <join type> ] JOIN <table reference> <join specification>
#
# <natural join> ::= <table reference> NATURAL [ <join type> ] JOIN <table primary>
#
# <union join> ::= <table reference> UNION JOIN <table primary>
#
# Symqle supports only cross join and qualified join. We are introducing
# intermediate non-terminal Join, which is CROSS JOIN <table primary> or <join type> JOIN <table reference> <join specification>
# a limitation: in qualified join the second <table reference> can be only <table primary>
#
# <join specification> ::= <join condition> | <named columns join>
# Symqle does not support/use <named columns join>, so we are inlining <join condition> in Join productions
# Additionally, JoinedTable is also expanded inline as TableReference
# methods are used internally by TableOrView, they are not public


public interface TableReference : SqlBuilder {}

TableReference ::=
    t:TablePrimary :: protected TableReference asTableReference {}
|
    l:TableReference LEFT JOIN r:TableReference ON c:BooleanExpression :: protected TableReference leftJoin {}
|
    l:TableReference RIGHT JOIN r:TableReference ON c:BooleanExpression :: protected TableReference rightJoin {}
|
    l:TableReference INNER JOIN r:TableReference ON c:BooleanExpression :: protected TableReference innerJoin {}
|
    l:TableReference OUTER JOIN r:TableReference ON c:BooleanExpression :: protected TableReference outerJoin {}
;

# unused
# public interface JoinedTable : SqlBuilder {}

# <table primary> ::=
#		<table or query name> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
#	|	<derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
#	|	<lateral derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
#	|	<collection derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
#	|	<table function derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
#	|	<only spec> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
#	|	<left paren> <joined table> <right paren>
#
# only the first one is supported, AS <correlation name> is always used <correlation name> is just Identifier

public interface TablePrimary : SqlBuilder {}

TablePrimary ::= t:TableName AS id:Identifier
;

# <table reference list> ::= <table reference> [ { <comma> <table reference> }... ]
# <table reference> ::= <table primary or joined table> [ <sample clause> ]
# (symqle) <table reference> ::= <table primary>
# <derived table> ::= <table subquery>
# <table subquery> ::= <left paren> <query expression> <right paren>
# combine all that whe single <table reference> in the list:

TablePrimary ::=
    LEFT_PAREN qe:QueryExpression<?> RIGHT_PAREN :: private TablePrimary derivedTable
;

class DerivedTable extends TableOrView {
    private String sql;

    void setSql(final String sql) {
        this.sql = sql;
    }

    @Override
    public String getTableName() {
        return sql;
    }
}

import java.util.Collection;
:: public AbstractAggregateQuerySpecification<Integer> countRows(final QueryExpression<?> qe) {
    final AbstractAggregateFunction<Integer> count = new AbstractAggregateFunction<Integer>() {
        private final AggregateFunction<Integer> delegate = countAsterisk();
        private final DerivedTable derivedTable = new DerivedTable();
        @Override
        public Mapper<Integer> getMapper() {
            return delegate.getMapper();
        }

        @Override
        public SqlBuilder z$sqlOfAggregateFunction(final SqlContext context) {
            final TablePrimary tablePrimary = derivedTable(qe);
            final TableRegistry myTableRegistry = context.get(TableRegistry.class);
            final TableRegistry innerRegistry = new ChildSelectTableRegistry(myTableRegistry);
            final SqlContext innerContext = context.newBuilder().
                     put(ColumnNameGenerator.class, null).
                     put(TableRegistry.class, innerRegistry).toSqlContext();
            qe.z$sqlOfQueryExpression(makeLearningContext(innerContext));
            final SqlBuilder queryBuilder = tablePrimary.z$sqlOfTablePrimary(innerContext);
            final StringBuilder innerSqlBuilder = new StringBuilder();
            queryBuilder.appendTo(innerSqlBuilder);
            final String innerSql = innerSqlBuilder.toString();
            derivedTable.setSql(innerSql);
            // make sure derived table is in the context;
            derivedTable.getCorrelationName(context);
            // new SqlBuilder delegates SQL text construction to delegate
            // and parameters setting to derived table
            return new SqlBuilder() {
                final SqlBuilder aggregateFunctionBuilder = delegate.z$sqlOfAggregateFunction(context);
                @Override
                public void appendTo(final StringBuilder builder) {
                    aggregateFunctionBuilder.appendTo(builder);
                }

                @Override
                public char firstChar() {
                    return aggregateFunctionBuilder.firstChar();
                }

                @Override
                public void setParameters(final SqlParameters p) throws SQLException {
                    queryBuilder.setParameters(p);
                }
            };
        }
    };
    return AbstractAggregateQuerySpecification.adapt(count);
}


/**
* A terminal symbol of Symqle SQL language.
* Implementing classes are responsible for correct lexis and semantics.
*/
public interface TableName : SqlBuilder {}












