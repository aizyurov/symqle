
import org.symqle.common.*;
import org.symqle.jdbc.Configuration;
import org.symqle.querybuilder.CustomSql;
import org.symqle.querybuilder.SqlTerm;

import java.util.*;
class FromClauseBuilder {
    /**
     * Builds a Sql of FromClause from local scope tables
     * @param context
     * @return null if FROM CLAUSE is not applicable (no tables and supported by dialect and options)
     */
    Sql build(final SqlContext context) {
        SelectTableRegistry registry = (SelectTableRegistry) context.get(TableRegistry.class);
        final Configuration configuration = context.get(Configuration.class);
        final boolean allowNoFrom = configuration.allowNoFrom();
        final boolean allowImplicitCrossJoins = configuration.allowImplicitCrossJoins();
        final List<TableOrView> localTables = registry.getLocal();
        if (localTables.isEmpty()) {
            if (allowNoFrom) {
                return generateEmptyFromClause(context);
            } else {
                throw new MalformedStatementException("At least one table is required for FROM clause");
            }
        }
        final Set<TableOrView> roots = new HashSet<TableOrView>();
        for (TableOrView t: localTables) {
            roots.add(t.joinedTableRoot());
        }
        final Iterator<TableOrView> iterator = roots.iterator();
        TableReferenceList tableReferenceList = Symqle.createTableReferenceList(iterator.next());
        while (iterator.hasNext()) {
            if (!allowImplicitCrossJoins) {
                throw new MalformedStatementException("Implicit cross joins are not allowed, cross joined: "+ roots);
            }
            tableReferenceList = Symqle.appendTableReferenceList(tableReferenceList, iterator.next());
        }
        return Symqle.createFrom(tableReferenceList).z$sqlOfFromClause(context);
    }


    private Sql generateEmptyFromClause(SqlContext context) {
        final Dialect dialect = context.get(Dialect.class);
        final String fallbackTableName = dialect.fallbackTableName();
        if (fallbackTableName == null) {
            return null;
        } else {
            // need a unique correlation name for fallback table
            return new CompositeSql(
              SqlTerm.FROM.toSql(),
              new CustomSql(fallbackTableName),
              SqlTerm.AS.toSql(),
              new CustomSql("D" + System.identityHashCode(this)));
        }
    }
}

