public interface NumericExpression<T> extends Scalar<T>: Sql {}

public class AbstractNumericExpression<T> implements NumericExpression<T> {}

# implicit operations retain type argument
<T> NumericExpression<T> ::=
    t:Term<T> :: implicit {}
;

# all operations accept <? extends Number> and return <Number>
NumericExpression<Number> ::=
    /**
    * Creates expression {@code this + other}.
    * {@code this} and {@code other} should have database types, which are numeric or
    * can be converted to numbers by implicit conversion.
    * @param other the second operand
    * @return the resulting expression. It is always mapped to Number.
    */
    e:NumericExpression<?> PLUS other:Term<?> :: AbstractNumericExpression<Number> add {
            public Mapper<Number> getMapper() {
                    return CoreMappers.NUMBER;
            }
         }
|
    /**
    * Creates expression {@code this - other}.
    * {@code this} and {@code other} should have database types, which are numeric or
    * can be converted to numbers by implicit conversion.
    * @param other the second operand
    * @return the resulting expression. It is always mapped to Number.
    */
    e:NumericExpression<?> MINUS other:Term<?> :: AbstractNumericExpression<Number> sub {
            public Mapper<Number> getMapper() {
                    return CoreMappers.NUMBER;
            }
         }
;

::
    /**
    * Changes mapper of {@code this}.
    * The result produces the same SQL but is associated with different Java type.
    * Symqle does not check that the replacement is valid, is is your responsibility.
    * @param mapper new mapper to use.
    * @param <A> new associated Java type
    * @return new AbstractNumericExpression with required mapper.
    */
    <A> AbstractNumericExpression<A> map(final NumericExpression<?> e, final Mapper<A> mapper) {
        return new AbstractNumericExpression<A>() {
            @Override
            public Mapper<A> getMapper() {
                return mapper;
            }

            @Override
            public Sql z$sqlOfNumericExpression(final SqlContext context) {
                return e.z$sqlOfNumericExpression(context);
            }
        };
    }

::
    /**
    * Creates an expression {@code this + ?}.
    * Value of dynamic parameter is set to n.
    * {@code this} should have database type, which is numeric or
    * can be converted to number by implicit conversion.
    * @param n value of the second operand.
    * @return the resulting expression. It is always mapped to Number.
    */
    AbstractNumericExpression<Number> add(final NumericExpression<?> e, final Number n) {
        return add(e, DynamicParameter.create(CoreMappers.NUMBER, n));
    }

::
    /**
    * Creates an expression {@code this - ?}.
    * Value of dynamic parameter is set to n.
    * {@code this} should have database type, which is numeric or
    * can be converted to number by implicit conversion.
    * @param n value of the second operand.
    * @return the resulting expression. It is always mapped to Number.
    */
    AbstractNumericExpression<Number> sub(final NumericExpression<?> e, final Number n) {
        return sub(e,  DynamicParameter.create(CoreMappers.NUMBER, n));
    }


public interface Term<T> extends Scalar<T> : Sql {}

public class AbstractTerm<T> implements Term<T> {}

<T> Term<T> ::= f:Factor<T> :: implicit {}
;

Term<Number> ::=
    /**
    * Creates expression {@code this * other}.
    * {@code this} and {@code other} should have database types, which are numeric or
    * can be converted to numbers by implicit conversion.
    * @param other the second operand
    * @return the resulting expression. It is always mapped to Number.
    */
    t:Term<?> ASTERISK other:Factor<?> :: AbstractTerm<Number> mult {
            public Mapper<Number> getMapper() {
                    return CoreMappers.NUMBER;
            }
        }
|
    /**
    * Creates expression {@code this / other}.
    * {@code this} and {@code other} should have database types, which are numeric or
    * can be converted to numbers by implicit conversion.
    * @param other the second operand
    * @return the resulting expression. It is always mapped to Number.
    */
    t:Term<?> SOLIDUS other:Factor<?> :: AbstractTerm<Number> div {
            public Mapper<Number> getMapper() {
                    return CoreMappers.NUMBER;
            }
        }
;

::
    /**
    * Creates an expression {@code this * ?}.
    * Value of dynamic parameter is set to n.
    * {@code this} should have database type, which is numeric or
    * can be converted to number by implicit conversion.
    * @param n value of the second operand.
    * @return the resulting expression. It is always mapped to Number.
    */
    AbstractTerm<Number> mult(final Term<?> t, final Number n) {
        return mult(t, DynamicParameter.create(CoreMappers.NUMBER, n));
    }

::
    /**
    * Creates an expression {@code this / n}.
    * {@code this} should have database type, which is numeric or
    * can be converted to number by implicit conversion.
    * @param n the second operand. Is is converted to a DynamicParameter.
    * @return the resulting expression. It is always mapped to Number.
    */
    AbstractTerm<Number> div(final Term<?> t, final Number n) {
        return div(t, DynamicParameter.create(CoreMappers.NUMBER, n));
    }

::
    /**
    * Changes mapper of {@code this}.
    * The result produces the same SQL but is associated with different Java type.
    * Symqle does not check that the replacement is valid, is is your responsibility.
    * @param mapper new mapper to use.
    * @param <A> new associated Java type
    * @return new AbstractNumericExpression with required mapper.
    */
    <A> AbstractTerm<A> map(final Term<?> e, final Mapper<A> mapper) {
        return new AbstractTerm<A>() {
            @Override
            public Mapper<A> getMapper() {
                return mapper;
            }

            @Override
            public Sql z$sqlOfTerm(final SqlContext context) {
                return e.z$sqlOfTerm(context);
            }
        };
    }


public interface Factor<T> extends Scalar<T> : Sql {}

public class AbstractFactor<T> implements Factor<T> {}

# negate retains type argument
<T> Factor<T> ::=
    e:ValueExpressionPrimary<T> :: implicit {}
;
<T> Factor<T> ::=
    /**
    * Unary minus:  {@code - this}.
    * {@code this} should have database type, which is numeric or
    * can be converted to number by implicit conversion.
    * @return the resulting expression. Type parameter si the same as of {@code this}
    */
    MINUS e:ValueExpressionPrimary<T> :: AbstractFactor<T> opposite {}
;

::
    /**
    * Changes mapper of {@code this}.
    * The result produces the same SQL but is associated with different Java type.
    * Symqle does not check that the replacement is valid, is is your responsibility.
    * @param mapper new mapper to use.
    * @param <A> new associated Java type
    * @return new AbstractFactor with required mapper.
    */
    <A> AbstractFactor<A> map(final Factor<?> e, final Mapper<A> mapper) {
        return new AbstractFactor<A>() {
            @Override
            public Mapper<A> getMapper() {
                return mapper;
            }

            @Override
            public Sql z$sqlOfFactor(final SqlContext context) {
                return e.z$sqlOfFactor(context);
            }
        };
    }


