public interface Predicate : Sql {}
public class AbstractPredicate implements Predicate {}

# we do not need intermediate interfaces for predicate types: they do not add any functionality

#Predicate ::=
# 		p:ComparisonPredicate
#|
#        p:InPredicate
#|
#        p:NullPredicate
#|
#        p:ExistsPredicate
#|
#        p:LikePredicate
#;

# All predicates use Predicand (<row value predicand>)
# in current version of Symqle it can be only scalar

public interface Predicand<T> extends Scalar<T> : Sql {}

<T> Predicand<T> ::=
    e:NumericExpression<T> :: implicit {}
|
    e:StringExpression<T> :: implicit {}
|
    e:ValueExpressionPrimary<T> :: implicit {}
;

# skipped Predicand<Boolean> ::= LEFT_PAREN b:BooleanExpression RIGHT_PAREN
# because we can do it better vila ValueExpressionPrimary using asValue()

# ComparisonPredicate

<T> Predicate ::=
     p1:Predicand<T> EQ p2:Predicand<T>
        :: public AbstractPredicate eq {}
|

     p1:Predicand<T> NE p2:Predicand<T>
        :: public AbstractPredicate ne {}
|
     p1:Predicand<T> GT p2:Predicand<T>
        :: public AbstractPredicate gt {}
|
     p1:Predicand<T> GE p2:Predicand<T>
        :: public AbstractPredicate ge {}
|
     p1:Predicand<T> LT p2:Predicand<T>
        :: public AbstractPredicate lt {}
|
     p1:Predicand<T> LE p2:Predicand<T>
        :: public AbstractPredicate le {}
;

:: public <T> AbstractPredicate eq(Predicand<T> p, T v) {
    return eq(p, DynamicParameter.create(p.getMapper(), v));
}
:: public <T> AbstractPredicate ne(Predicand<T> p, T v) {
    return ne(p, DynamicParameter.create(p.getMapper(), v));
}
:: public <T> AbstractPredicate gt(Predicand<T> p, T v) {
    return gt(p, DynamicParameter.create(p.getMapper(), v));
}
:: public <T> AbstractPredicate ge(Predicand<T> p, T v) {
    return ge(p, DynamicParameter.create(p.getMapper(), v));
}
:: public <T> AbstractPredicate lt(Predicand<T> p, T v) {
    return lt(p, DynamicParameter.create(p.getMapper(), v));
}
:: public <T> AbstractPredicate le(Predicand<T> p, T v) {
    return le(p, DynamicParameter.create(p.getMapper(), v));
}


# InPredicate

<T> Predicate ::=
    p:Predicand<T> IN v:InPredicateValue<T> :: public AbstractPredicate in {}
|
        p:Predicand<T> NOT IN v:InPredicateValue<T> :: public AbstractPredicate notIn {}
;

public interface InPredicateValue<T> : Sql {}

<T> InPredicateValue<T> ::=
    s:ScalarSubquery<T> :: implicit {}
|
    LEFT_PAREN l:InValueList<T> RIGHT_PAREN :: implicit {}
;

public interface InValueList<T> : Sql {}
public class AbstractInValueList<T> implements InValueList<T> {}

<T>  InValueList<T> ::=
    e1:ValueExpression<T> :: AbstractInValueList<T> asInValueList
|
    l:InValueList<T> COMMA e:ValueExpression<T> :: AbstractInValueList<T> append {}
;

# public convenience methods for construction of InPredicate from list of ValueExpression

:: public <T> AbstractPredicate in(final Predicand<T> p, final T first, final T... other) {
     return in(p, prepareInPredicateValue(p.getMapper(), first, other));
}

:: public <T> AbstractPredicate notIn(final Predicand<T> p, final T first, final T... other) {
     return notIn(p, prepareInPredicateValue(p.getMapper(), first, other));
}

:: public <T> AbstractPredicate contains(final ScalarSubquery<T> subquery, T element) {
    return DynamicParameter.create(subquery.getMapper(), element).in(AbstractScalarSubquery.adapt(subquery));
}

:: protected <T> InPredicateValue<T> prepareInPredicateValue(Mapper<T> mapper, final T first, final T... other) {
     AbstractInValueList<T> list = DynamicParameter.create(mapper, first).asInValueList();
     for (T e: other) {
         list = list.append(DynamicParameter.create(mapper, e));
     }
     return list;
}

#NullPredicate

Predicate ::=
    p:Predicand<?> IS NULL :: public AbstractPredicate isNull {}
|
    p:Predicand<?> IS NOT NULL :: public AbstractPredicate isNotNull {}
;


#ExistsPredicate

Predicate ::= EXISTS s:ScalarSubquery<?> :: public AbstractPredicate exists {}
;

# LikePredicate
# BLOB like not supported yet

Predicate ::=
    b:LikePredicateBase :: implicit {}
|
    b:LikePredicateBase ESCAPE esc:StringExpression<String> :: public AbstractPredicate escape {}
;

:: public AbstractPredicate escape(final LikePredicateBase base, final char escapeCharacter) {
    return escape(base, DynamicParameter.create(Mappers.STRING, new String(new char[] {escapeCharacter})));
}

public interface LikePredicateBase : Sql {}
public class AbstractLikePredicateBase implements LikePredicateBase {}

LikePredicateBase ::=
    e:ValueExpression<?> LIKE p:StringExpression<String> :: public AbstractLikePredicateBase like {}
|
    e:ValueExpression<?> NOT LIKE p:StringExpression<String> :: public AbstractLikePredicateBase notLike {}
;

:: public AbstractLikePredicateBase like(ValueExpression<?> expr, String pattern) {
      return like(expr, DynamicParameter.create(Mappers.STRING, pattern));
}

:: public AbstractLikePredicateBase notLike(ValueExpression<?> expr, String pattern) {
      return notLike(expr, DynamicParameter.create(Mappers.STRING, pattern));
}
