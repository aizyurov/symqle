public interface Predicate : Sql {}
public class AbstractPredicate implements Predicate {}

# we do not need intermediate interfaces for predicate types: they do not add any functionality

#Predicate ::=
# 		p:ComparisonPredicate
#|
#        p:InPredicate
#|
#        p:NullPredicate
#|
#        p:ExistsPredicate
#|
#        p:LikePredicate
#;

# All predicates use Predicand (<row value predicand>)
# in current version of Symqle it can be only scalar

public interface Predicand<T> extends Scalar<T> : Sql {}

<T> Predicand<T> ::=
    e:NumericExpression<T> :: implicit
|
    e:StringExpression<T> :: implicit
|
    e:ValueExpressionPrimary<T> :: implicit
;

# skipped Predicand<Boolean> ::= LEFT_PAREN b:BooleanExpression RIGHT_PAREN
# because we can do it better vila ValueExpressionPrimary using asValue()

# ComparisonPredicate

<T> Predicate ::=
    /**
     * Constructs predicate {@code this = other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> EQ other:Predicand<T> :: AbstractPredicate eq
|
    /**
     * Constructs predicate {@code this <> other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> NE other:Predicand<T> :: AbstractPredicate ne
|
    /**
     * Constructs predicate {@code this > other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> GT other:Predicand<T> :: AbstractPredicate gt
|
    /**
     * Constructs predicate {@code this >= other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> GE other:Predicand<T> :: AbstractPredicate ge {}
|
    /**
     * Constructs predicate {@code this < other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> LT other:Predicand<T> :: AbstractPredicate lt
|
    /**
     * Constructs predicate {@code this <= other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> LE other:Predicand<T> :: AbstractPredicate le
;

::
    /**
     * Constructs predicate {@code this = ?}.
     * The value of dynamic parameter is set to {@code value>}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate eq(Predicand<T> p, T value) {
        return eq(p, DynamicParameter.create(p.getMapper(), value));
    }

::
    /**
     * Constructs predicate {@code this <> ?}.
     * The value of dynamic parameter is set to {@code value>}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate ne(Predicand<T> p, T value) {
        return ne(p, DynamicParameter.create(p.getMapper(), value));
    }
::
    /**
     * Constructs predicate {@code this > ?}.
     * The value of dynamic parameter is set to {@code value>}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate gt(Predicand<T> p, T value) {
        return gt(p, DynamicParameter.create(p.getMapper(), value));
    }

::
    /**
     * Constructs predicate {@code this >= ?}.
     * The value of dynamic parameter is set to {@code value>}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate ge(Predicand<T> p, T value) {
        return ge(p, DynamicParameter.create(p.getMapper(), value));
    }

::
    /**
     * Constructs predicate {@code this < ?}.
     * The value of dynamic parameter is set to {@code value>}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate lt(Predicand<T> p, T value) {
        return lt(p, DynamicParameter.create(p.getMapper(), value));
    }

::
    /**
     * Constructs predicate {@code this <= ?}.
     * The value of dynamic parameter is set to {@code value>}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate le(Predicand<T> p, T value) {
        return le(p, DynamicParameter.create(p.getMapper(), value));
    }


# InPredicate

<T> Predicate ::=
    /**
     * Constructs predicate {@code this IN values}.
     * {@code values} may be either {@link ScalarSubquery} or {@link InValueList}.
     * The latter can be constructed using {@link org.symqle.sql.ValueExpression#asInValueList()}
     * and {@link InValueList#append(ValueExpression)}.
     * @param values the list of values as InPredicateValue
     * @return constructed predicate
     */
    p:Predicand<T> IN values:InPredicateValue<T> :: AbstractPredicate in
|
    /**
     * Constructs predicate {@code this NOT IN values}.
     * {@code values} may be either {@link ScalarSubquery} or {@link InValueList}.
     * The latter can be constructed using {@link org.symqle.sql.ValueExpression#asInValueList()}
     * and {@link InValueList#append(ValueExpression)}.
     * @param values the list of values as InPredicateValue
     * @return constructed predicate
     */
        p:Predicand<T> NOT IN values:InPredicateValue<T> :: AbstractPredicate notIn
;

public interface InPredicateValue<T> : Sql {}

<T> InPredicateValue<T> ::=
    s:ScalarSubquery<T> :: implicit
|
    LEFT_PAREN l:InValueList<T> RIGHT_PAREN :: implicit
;

public interface InValueList<T> : Sql {}
public class AbstractInValueList<T> implements InValueList<T> {}

<T>  InValueList<T> ::=
    /**
     * Converts {@code this} to InValueList.
     * Other values can be appended to the list via {@link InValueList#append(ValueExpression)}.
     * The list can be used in {@link Predicand#in(InPredicateValue)} and {@link Predicand#notIn(InPredicateValue)}.
     * @return AbstractInValueList containing one element
     */
    e1:ValueExpression<T> :: AbstractInValueList<T> asInValueList
|
    /**
     * Constructs new list by appending {@code other} to {@code this}.
     * @param other the ValueExpression to append
     * @return extended list
     */
    l:InValueList<T> COMMA other:ValueExpression<T> :: AbstractInValueList<T> append
;

# public convenience methods for construction of InPredicate from list of ValueExpression

::
    /**
     * Constructs predicate {@code this IN (?,...)}.
     * Values of dynamic parameters are set from arguments.
     * @param first value of the first parameter
     * @param other values of other parameters
     * @return constructed predicate
     */
    <T> AbstractPredicate in(final Predicand<T> p, final T first, final T... other) {
         return in(p, prepareInPredicateValue(p.getMapper(), first, other));
    }

::
    /**
     * Constructs predicate {@code this IN (?,...)}.
     * Values of dynamic parameters are set from arguments.
     * @param first value of the first parameter
     * @param other values of other parameters
     * @return constructed predicate
     */
    <T> AbstractPredicate notIn(final Predicand<T> p, final T first, final T... other) {
         return notIn(p, prepareInPredicateValue(p.getMapper(), first, other));
    }

::
    /**
     * Constructs predicate {@code ? IN ((ScalarSubquery)this)}.
     * Values of dynamic parameter is set to argument
     * @param value the value set to dynamicc parameter
     * @return constructed predicate
     */
    <T> AbstractPredicate contains(final ScalarSubquery<T> subquery, T value) {
        return DynamicParameter.create(subquery.getMapper(), value).in(new InPredicateValue<T>() {
            @Override
            public Sql z$sqlOfInPredicateValue(final SqlContext context) {
                return z$InPredicateValue$from$ScalarSubquery(subquery).z$sqlOfInPredicateValue(context);
            }
        });
    }

:: private <T> InPredicateValue<T> prepareInPredicateValue(Mapper<T> mapper, final T first, final T... other) {
     AbstractInValueList<T> list = DynamicParameter.create(mapper, first).asInValueList();
     for (T e: other) {
         list = list.append(DynamicParameter.create(mapper, e));
     }
     return list;
}

#NullPredicate

Predicate ::=
    /**
     * Constructs predicate {@code this IS NULL}.
     * @return constructed predicate
     */
    p:Predicand<?> IS NULL :: AbstractPredicate isNull {}
|
    /**
     * Constructs predicate {@code this IS NOT NULL}.
     * @return constructed predicate
     */
    p:Predicand<?> IS NOT NULL :: AbstractPredicate isNotNull {}
;


#ExistsPredicate


Predicate ::=
    /**
     * Constructs predicate {@code EXISTS  ((ScalarSubquery)this)}.
     * @return constructed predicate
     */
    EXISTS s:ScalarSubquery<?> :: AbstractPredicate exists
;

# LikePredicate
# BLOB like not supported yet

Predicate ::=
    b:LikePredicateBase :: implicit
|
    /**
     * Creates a predicate adding {@code ESCAPE esc} to {code this}.
     * @param esc StringExpression, which value is escape character
     * @return constructed predicate
     */
    b:LikePredicateBase ESCAPE esc:StringExpression<String> :: AbstractPredicate escape
;

::
    /**
     * Creates a predicate adding {@code ESCAPE ?} to {code this}.
     * The value of dynamic parameter is set to escapeCharacter.
     * @param escapeCharacter the value to set
     * @return constructed predicate
     */
    AbstractPredicate escape(final LikePredicateBase base, final char escapeCharacter) {
        return escape(base, DynamicParameter.create(CoreMappers.STRING, new String(new char[] {escapeCharacter})));
    }

public interface LikePredicateBase : Sql {}
public class AbstractLikePredicateBase implements LikePredicateBase {}

LikePredicateBase ::=
    /**
     * Created a predicate {@code this LIKE pattern}
     * Value of dynamic parameter is set to pattern.
      * @param pattern the pattern
     * @return constructed predicate
     */
    e:ValueExpression<?> LIKE pattern:StringExpression<String> :: AbstractLikePredicateBase like
|
    /**
     * Created a predicate {@code this NOT LIKE pattern}
     * Value of dynamic parameter is set to pattern.
      * @param pattern the pattern
     * @return constructed predicate
     */
    e:ValueExpression<?> NOT LIKE pattern:StringExpression<String> :: public AbstractLikePredicateBase notLike
;

::
    /**
     * Created a predicate {@code this LIKE ?}
     * Value of dynamic parameter is set to pattern.
      * @param pattern the value
     * @return constructed predicate
     */
    AbstractLikePredicateBase like(ValueExpression<?> expr, String pattern) {
          return like(expr, DynamicParameter.create(CoreMappers.STRING, pattern));
    }


::
    /**
     * Created a predicate {@code this NOT LIKE ?}
     * Value of dynamic parameter is set to pattern.
      * @param pattern the value
     * @return constructed predicate
     */
    AbstractLikePredicateBase notLike(ValueExpression<?> expr, String pattern) {
          return notLike(expr, DynamicParameter.create(CoreMappers.STRING, pattern));
    }
