#############################################################################
#
#   Copyright 2010-2013 Alexander Izyurov
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.package org.symqle.common;
#
##############################################################################

public interface Predicate : SqlBuilder {}
public class AbstractPredicate implements Predicate {}

# we do not need intermediate interfaces for predicate types: they do not add any functionality

#Predicate ::=
# 		p:ComparisonPredicate
#|
#        p:InPredicate
#|
#        p:NullPredicate
#|
#        p:ExistsPredicate
#|
#        p:LikePredicate
#;

# All predicates use Predicand (<row value predicand>)
# in current version of Symqle it can be only scalar

public interface Predicand<T> extends Scalar<T> : SqlBuilder {}

public interface Predicand2<T> extends Scalar<T> : SqlBuilder {}

<T> Predicand<T> ::=
    e:NumericExpression<T> :: implicit
|
    e:StringExpression<T> :: implicit
|
    e:ValueExpressionPrimary<T> :: implicit
;

# skipped Predicand<Boolean> ::= LEFT_PAREN b:BooleanExpression RIGHT_PAREN
# because we can do it better vila ValueExpressionPrimary using asValue()

# ComparisonPredicate and QualifiedComparisonPredicate (combined)
# <quantified comparison predicate> ::=
#  <row value predicand> <quantified comparison predicate part 2>
#  <quantified comparison predicate part 2> ::=
#  <comp op> <quantifier> <table subquery>

<T> Predicand2<T> ::=
     p:Predicand<T> :: implicit
|
     /**
     * Creates a second predicand for qualified comparison.
     * The SQL of this predicand looks like {@code ALL ((ScalarSubquery) this)}.
     * @return constructed predicand
     */
     ALL s:ScalarSubquery<T> :: Predicand2<T> all
|
     /**
     * Creates a second predicand for qualified comparison.
     * The SQL of this predicand looks like {@code ANY ((ScalarSubquery) this)}.
     * @return constructed predicand
     */
    ANY s:ScalarSubquery<T> :: Predicand2<T> any
|
     /**
     * Creates a second predicand for qualified comparison.
     * The SQL of this predicand looks like {@code SOME ((ScalarSubquery) this)}.
     * @return constructed predicand
     */
    SOME s:ScalarSubquery<T> :: Predicand2<T> some
;


<T> Predicate ::=
    /**
     * Constructs predicate {@code this = other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> EQ other:Predicand2<T> :: AbstractPredicate eq
|
    /**
     * Constructs predicate {@code this <> other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> NE other:Predicand2<T> :: AbstractPredicate ne
|
    /**
     * Constructs predicate {@code this > other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> GT other:Predicand2<T> :: AbstractPredicate gt
|
    /**
     * Constructs predicate {@code this >= other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> GE other:Predicand2<T> :: AbstractPredicate ge {}
|
    /**
     * Constructs predicate {@code this < other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> LT other:Predicand2<T> :: AbstractPredicate lt
|
    /**
     * Constructs predicate {@code this <= other}.
     * @param other the second predicand
     * @return constructed predicate
     */
     p1:Predicand<T> LE other:Predicand2<T> :: AbstractPredicate le
;

::
    /**
     * Constructs predicate {@code this = ?}.
     * The value of dynamic parameter is set to {@code value}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate eq(final Predicand<T> p, final T value) {
        return eq(p, p.param(value));
    }

::
    /**
     * Constructs predicate {@code this <> ?}.
     * The value of dynamic parameter is set to {@code value}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate ne(final Predicand<T> p, final T value) {
        return ne(p, p.param(value));
    }
::
    /**
     * Constructs predicate {@code this > ?}.
     * The value of dynamic parameter is set to {@code value}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate gt(final Predicand<T> p, final T value) {
        return gt(p, p.param(value));
    }

::
    /**
     * Constructs predicate {@code this >= ?}.
     * The value of dynamic parameter is set to {@code value}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate ge(final Predicand<T> p, final T value) {
        return ge(p, p.param(value));
    }

::
    /**
     * Constructs predicate {@code this < ?}.
     * The value of dynamic parameter is set to {@code value}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate lt(final Predicand<T> p, final T value) {
        return lt(p, p.param(value));
    }

::
    /**
     * Constructs predicate {@code this <= ?}.
     * The value of dynamic parameter is set to {@code value}
     * @param value value of the second predicand
     * @return constructed predicate
     */
    <T> AbstractPredicate le(final Predicand<T> p, final T value) {
        return le(p, p.param(value));
    }


# InPredicate

<T> Predicate ::=
    /**
     * Constructs predicate {@code this IN values}.
     * {@code values} may be either {@link ScalarSubquery} or {@link InValueList}.
     * The latter can be constructed using {@link org.symqle.sql.ValueExpression#asInValueList()}
     * and {@link InValueList#append(ValueExpression)}.
     * @param values the list of values as InPredicateValue
     * @return constructed predicate
     */
    p:Predicand<T> IN values:InPredicateValue<T> :: AbstractPredicate in
|
    /**
     * Constructs predicate {@code this NOT IN values}.
     * {@code values} may be either {@link ScalarSubquery} or {@link InValueList}.
     * The latter can be constructed using {@link org.symqle.sql.ValueExpression#asInValueList()}
     * and {@link InValueList#append(ValueExpression)}.
     * @param values the list of values as InPredicateValue
     * @return constructed predicate
     */
        p:Predicand<T> NOT IN values:InPredicateValue<T> :: AbstractPredicate notIn
;

public interface InPredicateValue<T> : SqlBuilder {}

<T> InPredicateValue<T> ::=
    s:ScalarSubquery<T> :: implicit
|
    LEFT_PAREN l:InValueList<T> RIGHT_PAREN :: implicit
;

public interface InValueList<T> : SqlBuilder {}
public class AbstractInValueList<T> implements InValueList<T> {}

<T>  InValueList<T> ::=
    /**
     * Converts {@code this} to InValueList.
     * Other values can be appended to the list via {@link InValueList#append(ValueExpression)}.
     * The list can be used in {@link Predicand#in(InPredicateValue)} and {@link Predicand#notIn(InPredicateValue)}.
     * @return AbstractInValueList containing one element
     */
    e1:ValueExpression<T> :: AbstractInValueList<T> asInValueList
|
    /**
     * Constructs new list by appending {@code other} to {@code this}.
     * @param other the ValueExpression to append
     * @return extended list
     */
    l:InValueList<T> COMMA other:ValueExpression<T> :: AbstractInValueList<T> append
;

# public convenience methods for construction of InPredicate from list of ValueExpression

::
    /**
     * Constructs predicate {@code this IN (?,...)}.
     * Values of dynamic parameters are set from arguments.
     * @param first value of the first parameter
     * @param other values of other parameters
     * @return constructed predicate
     */
    <T> AbstractPredicate in(final Predicand<T> p, final T first, final T... other) {
         return in(p, prepareInPredicateValue(p.getMapper(), first, other));
    }

::
    /**
     * Constructs predicate {@code this IN (?,...)}.
     * Values of dynamic parameters are set from arguments.
     * @param first value of the first parameter
     * @param other values of other parameters
     * @return constructed predicate
     */
    <T> AbstractPredicate notIn(final Predicand<T> p, final T first, final T... other) {
         return notIn(p, prepareInPredicateValue(p.getMapper(), first, other));
    }

::
    /**
     * Constructs predicate {@code ? IN ((ScalarSubquery)this)}.
     * Value of dynamic parameter is set to argument.
     * @param value the value set to dynamic parameter
     * @return constructed predicate
     */
    <T> AbstractPredicate contains(final ScalarSubquery<T> subquery, final T value) {
        return DynamicParameter.create(subquery.getMapper(), value).in(new InPredicateValue<T>() {
            @Override
            public SqlBuilder z$sqlOfInPredicateValue(final SqlContext context) {
                return z$InPredicateValue$from$ScalarSubquery(subquery).z$sqlOfInPredicateValue(context);
            }
        });
    }

:: private <T> InPredicateValue<T> prepareInPredicateValue(final Mapper<T> mapper, final T first, final T... other) {
     AbstractInValueList<T> list = DynamicParameter.create(mapper, first).asInValueList();
     for (T e : other) {
         list = list.append(DynamicParameter.create(mapper, e));
     }
     return list;
}

#NullPredicate

Predicate ::=
    /**
     * Constructs predicate {@code this IS NULL}.
     * @return constructed predicate
     */
    p:Predicand<?> IS NULL :: AbstractPredicate isNull {}
|
    /**
     * Constructs predicate {@code this IS NOT NULL}.
     * @return constructed predicate
     */
    p:Predicand<?> IS NOT NULL :: AbstractPredicate isNotNull {}
;


#ExistsPredicate


Predicate ::=
    /**
     * Constructs predicate {@code EXISTS  ((ScalarSubquery)this)}.
     * @return constructed predicate
     */
    EXISTS s:ScalarSubquery<?> :: AbstractPredicate exists
;

# LikePredicate
# BLOB like not supported yet

Predicate ::=
    b:LikePredicateBase :: implicit
|
    /**
     * Creates a predicate adding {@code ESCAPE esc} to {code this}.
     * @param esc StringExpression, which value is escape character
     * @return constructed predicate
     */
    b:LikePredicateBase ESCAPE esc:StringExpression<String> :: AbstractPredicate escape
;

::
    /**
     * Creates a predicate adding {@code ESCAPE ?} to {code this}.
     * The value of dynamic parameter is set to escapeCharacter.
     * @param escapeCharacter the value to set
     * @return constructed predicate
     */
    AbstractPredicate escape(final LikePredicateBase base, final char escapeCharacter) {
        return escape(base, DynamicParameter.create(CoreMappers.STRING, new String(new char[] {escapeCharacter})));
    }

public interface LikePredicateBase : SqlBuilder {}
public class AbstractLikePredicateBase implements LikePredicateBase {}

LikePredicateBase ::=
    /**
     * Created a predicate {@code this LIKE pattern}
     * Value of dynamic parameter is set to pattern.
      * @param pattern the pattern
     * @return constructed predicate
     */
    e:ValueExpression<?> LIKE pattern:StringExpression<String> :: AbstractLikePredicateBase like
|
    /**
     * Created a predicate {@code this NOT LIKE pattern}
     * Value of dynamic parameter is set to pattern.
      * @param pattern the pattern
     * @return constructed predicate
     */
    e:ValueExpression<?> NOT LIKE pattern:StringExpression<String> :: AbstractLikePredicateBase notLike
;

::
    /**
     * Created a predicate {@code this LIKE ?}
     * Value of dynamic parameter is set to pattern.
      * @param pattern the value
     * @return constructed predicate
     */
    AbstractLikePredicateBase like(final ValueExpression<?> expr, final String pattern) {
          return like(expr, DynamicParameter.create(CoreMappers.STRING, pattern));
    }


::
    /**
     * Created a predicate {@code this NOT LIKE ?}
     * Value of dynamic parameter is set to pattern.
      * @param pattern the value
     * @return constructed predicate
     */
    AbstractLikePredicateBase notLike(final ValueExpression<?> expr, final String pattern) {
          return notLike(expr, DynamicParameter.create(CoreMappers.STRING, pattern));
    }


