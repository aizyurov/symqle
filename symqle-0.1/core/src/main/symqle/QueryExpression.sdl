#### QueryExpressionBody ###

# There are 2 flavors of QueryExpressionBody: multicolumn and scalar, the latter is QueryExpressionBodyScalar
# Scalar supports the whole hierarchy of QueryTerm, QueryPrimary, QuerySpecification
# Multicolumn QueryExpressionBody is derived only from QuerySpecification


public interface QueryExpressionBody<T> : Query<T> {}
public class AbstractQueryExpressionBody<T> implements QueryExpressionBody<T> {}
public interface QueryExpressionBodyScalar<T> extends Scalar<T> : Query<T> {}
public class AbstractQueryExpressionBodyScalar<T> implements QueryExpressionBodyScalar<T> {}

# see QueryBase.sdl, Where.sdl

<T> QueryExpressionBody<T> ::=
    qs:QuerySpecification<T> :: implicit {}
|
    qebs:QueryExpressionBodyScalar<T> :: implicit {}
;

:: private <T> Pair<Query<T>, Query<T>> prepareUnionOperands(final SqlContext context, final QueryExpressionBodyScalar<T> qe, final QueryTerm<T> qt) {
       // left and right parts have separate contexts
       final SqlContext leftContext = createScalarInnerContext(context);
       final SqlContext rightContext = createScalarInnerContext(context);
       // learning
       qe.z$sqlOfQueryExpressionBodyScalar(makeLearningContext(leftContext));
       qt.z$sqlOfQueryTerm(makeLearningContext(rightContext));
       // construction
       final Query<T> left = qe.z$sqlOfQueryExpressionBodyScalar(leftContext);
       final Query<T> right = qt.z$sqlOfQueryTerm(rightContext);
       return Pair.make(left, right);
}


<T> QueryExpressionBodyScalar<T> ::=
    qt:QueryTerm<T> :: implicit {}
|
    qe:QueryExpressionBodyScalar<T> UNION ALL qt:QueryTerm<T> ::
        public AbstractQueryExpressionBodyScalar<T> unionAll {
            public Query<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                Pair<Query<T>, Query<T>> operands = prepareUnionOperands(context, qe, qt);

                return new ComplexQuery<T>(operands.first(),
                    context.get(Dialect.class)
                        .QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_UNION_ALL_QueryTerm(operands.first(), operands.second()));
            }
        }
|
    qe:QueryExpressionBodyScalar<T> UNION DISTINCT qt:QueryTerm<T> ::
        public AbstractQueryExpressionBodyScalar<T> unionDistinct {
            public Query<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                Pair<Query<T>, Query<T>> operands = prepareUnionOperands(context, qe, qt);

                return new ComplexQuery<T>(operands.first(),
                    context.get(Dialect.class)
                        .QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_UNION_DISTINCT_QueryTerm(operands.first(), operands.second()));
            }
        }
|
    qe:QueryExpressionBodyScalar<T> UNION qt:QueryTerm<T> ::
        public AbstractQueryExpressionBodyScalar<T> union {
            public Query<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                Pair<Query<T>, Query<T>> operands = prepareUnionOperands(context, qe, qt);

                return new ComplexQuery<T>(operands.first(),
                    context.get(Dialect.class)
                        .QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_UNION_QueryTerm(operands.first(), operands.second()));
            }
        }
|
    qe:QueryExpressionBodyScalar<T> EXCEPT ALL qt:QueryTerm<T> ::
        public AbstractQueryExpressionBodyScalar<T> exceptAll {
            public Query<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                Pair<Query<T>, Query<T>> operands = prepareUnionOperands(context, qe, qt);

                return new ComplexQuery<T>(operands.first(),
                    context.get(Dialect.class)
                        .QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_EXCEPT_ALL_QueryTerm(operands.first(), operands.second()));
            }
        }
|
    qe:QueryExpressionBodyScalar<T> EXCEPT DISTINCT qt:QueryTerm<T> ::
        public AbstractQueryExpressionBodyScalar<T> exceptDistinct {
            public Query<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                Pair<Query<T>, Query<T>> operands = prepareUnionOperands(context, qe, qt);

                return new ComplexQuery<T>(operands.first(),
                    context.get(Dialect.class)
                        .QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_EXCEPT_DISTINCT_QueryTerm(operands.first(), operands.second()));
            }
        }
|
    qe:QueryExpressionBodyScalar<T> EXCEPT qt:QueryTerm<T> ::
        public AbstractQueryExpressionBodyScalar<T> except {
            public Query<T> z$sqlOfQueryExpressionBodyScalar(final SqlContext context) {
                Pair<Query<T>, Query<T>> operands = prepareUnionOperands(context, qe, qt);

                return new ComplexQuery<T>(operands.first(),
                    context.get(Dialect.class)
                        .QueryExpressionBodyScalar_is_QueryExpressionBodyScalar_EXCEPT_QueryTerm(operands.first(), operands.second()));
            }
        }
;

# zQueryTerm is always scalar; we do not add suffix _scalar for brevity
#
public interface QueryTerm<T> extends Scalar<T> :  Query<T> {}

public class AbstractQueryTerm<T> implements QueryTerm<T> {}

:: private <T> Pair<Query<T>, Query<T>> prepareIntersectOperands(final SqlContext context, final QueryTerm<T> qt, final QueryPrimary<T> qp) {
   final SqlContext leftContext = createScalarInnerContext(context);
   final SqlContext rightContext = createScalarInnerContext(context);
   qt.z$sqlOfQueryTerm(makeLearningContext(leftContext));
   qp.z$sqlOfQueryPrimary(makeLearningContext(rightContext));
   // construction
   final Query<T> left = qt.z$sqlOfQueryTerm(leftContext);
   final Query<T> right = qp.z$sqlOfQueryPrimary(rightContext);
   return Pair.make(left, right);
}


<T> QueryTerm<T> ::=
    qp:QueryPrimary<T> :: implicit {}
|
    qt:QueryTerm<T> INTERSECT ALL qp:QueryPrimary<T> ::
        public AbstractQueryTerm<T> intersectAll {
            public Query<T> z$sqlOfQueryTerm(final SqlContext context) {
                Pair<Query<T>, Query<T>> operands = prepareIntersectOperands(context, qt, qp);
                return new ComplexQuery<T>(operands.first(),
                    context.get(Dialect.class)
                        .QueryTerm_is_QueryTerm_INTERSECT_ALL_QueryPrimary(operands.first(), operands.second()));
            }
        }
|
    qt:QueryTerm<T> INTERSECT DISTINCT qp:QueryPrimary<T> ::
          public AbstractQueryTerm<T> intersectDistinct {
            public Query<T> z$sqlOfQueryTerm(final SqlContext context) {
                Pair<Query<T>, Query<T>> operands = prepareIntersectOperands(context, qt, qp);
                return new ComplexQuery<T>(operands.first(),
                    context.get(Dialect.class)
                        .QueryTerm_is_QueryTerm_INTERSECT_DISTINCT_QueryPrimary(operands.first(), operands.second()));
            }
          }
|
    qt:QueryTerm<T> INTERSECT qp:QueryPrimary<T> ::
          public AbstractQueryTerm<T> intersect {
            public Query<T> z$sqlOfQueryTerm(final SqlContext context) {
                Pair<Query<T>, Query<T>> operands = prepareIntersectOperands(context, qt, qp);
                return new ComplexQuery<T>(operands.first(),
                    context.get(Dialect.class)
                        .QueryTerm_is_QueryTerm_INTERSECT_QueryPrimary(operands.first(), operands.second()));
            }
          }
;

public interface QueryPrimary<T> extends Scalar<T>  : Query<T> {}

public class AbstractQueryPrimary<T> implements QueryPrimary<T> {}

<T> QueryPrimary<T> ::=
    qs:QuerySpecificationScalar<T> :: implicit {}
|
    LEFT_PAREN qe:QueryExpressionBodyScalar<T> RIGHT_PAREN :: implicit {}
;









