##### SelectStatement ####


# corresponds to <direct_select_statement: multiple rows>

import java.sql.SQLException;
import java.util.List;
import org.symqle.jdbc.Option;
import org.symqle.jdbc.QueryEngine;
import org.symqle.jdbc.PreparedQuery;
import org.symqle.common.Callback;
public interface SelectStatement<T> : QueryBuilder<T> {
}

public class AbstractSelectStatement<T> implements SelectStatement<T> {}

# key Symqle methods to query values

import java.sql.SQLException;
import org.symqle.common.Callback;
import org.symqle.jdbc.Option;
import org.symqle.jdbc.QueryEngine;
::
    /**
     * Executes a statement and calls callback for each returned row.
     * @param engine gate to DB
     * @param callback will be called until it returns false or there are no more rows
     * @param options to be applied to query builder and PreparedStatement
     * @return number of calls to callback
     * @throws SQLException from the underlying jdbc driver
     */
    <T> int scroll(final SelectStatement<T> statement,
                         final QueryEngine engine,
                         final Callback<T> callback,
                         final Option... options) throws SQLException {
        return compileQuery(statement, engine, options).scroll(callback);
    }

import java.sql.SQLException;
import org.symqle.jdbc.Option;
import org.symqle.jdbc.QueryEngine;
import org.symqle.jdbc.PreparedQuery;
::
    /**
     * Compiles {@code (SelectStatement)this}.
     * The result may be executed later (once or many times).
     * @param engine the target engine
     * @param options query builder and execution options to apply
     * @return pre-compiled query
     */
    <T> PreparedQuery<T> compileQuery(final SelectStatement<T> statement,
                                                                   final QueryEngine engine,
                                                                   final Option... options
                                                                   ) {

        final Dialect dialect = engine.getDialect();
        final SqlContext.Builder contextBuilder = new SqlContext.Builder().put(Dialect.class, dialect);
        List<Option> allOptions = new ArrayList<Option>(engine.getOptions());
        allOptions.addAll(Arrays.asList(options));
        UpdatableConfiguration configuration = new UpdatableConfiguration();
        for (Option option : allOptions) {
            option.apply(configuration);
        }
        final QueryBuilder<T> query = prepareQuery(statement, dialect, configuration);
        return new PreparedQuery<T>(engine, query, allOptions);
    }

import java.sql.SQLException;
import java.util.List;
import org.symqle.jdbc.Option;
::
    /**
     * Executes a statement and returns the list of objects of type T.
     * @param engine gate to DB
     * @param options to be applied to query builder and PreparedStatement
     * @return the list of objects
     * @throws SQLException from the underlying jdbc driver
     */
<T> List<T> list(final SelectStatement<T> statement,
                          final QueryEngine engine,
                          final Option... options
                        ) throws SQLException {
    return compileQuery(statement, engine, options).list();
    }

:: private Configuration getDebugConfiguration() {
    final UpdatableConfiguration configuration = new UpdatableConfiguration();
    configuration.setNoFromOk(true);
    configuration.setImplicitCrossJoinsOk(true);
    return configuration;
}

::
    /**
     * Formats a string, which would be passed to prepareStatement method by list() and scroll() methods.
     * @param dialect the dialect to use
     * @param options query builder options
     * @return the query string
     */
    String showQuery(final SelectStatement<?> statement, final Dialect dialect, final Option... options) {
        final UpdatableConfiguration configuration = new UpdatableConfiguration();
        for (Option option : options) {
             option.apply(configuration);
        }
        final StringBuilder stringBuilder = new StringBuilder();
        prepareQuery(statement, dialect, configuration).appendTo(stringBuilder);
        return stringBuilder.toString();
    }

:: private static <T> QueryBuilder<T> prepareQuery(final SelectStatement<T> statement, final Dialect dialect, final Configuration configuration) {
    final SelectTableRegistry tableRegistry = new RootSelectTableRegistry();
    final SqlContext context = new SqlContext.Builder().
            put(ColumnNameGenerator.class, new UniqueColumnNameGenerator()).
            put(TableRegistry.class, tableRegistry).
            put(Dialect.class, dialect).
            put(TableNameGenerator.class, new TableNameGenerator()).
            put(Configuration.class, configuration).toSqlContext();

    statement.z$sqlOfSelectStatement(makeLearningContext(context));
    return statement.z$sqlOfSelectStatement(context);
}

###### SelectStatement Construction methods #####

#  <direct select statement: multiple rows> ::= <cursor specification>
#  <cursor specification> ::= <query expression> [ <updatability clause> ]
# updatability_clause ::= FOR { READ ONLY | UPDATE [ OF column_name_list ] }
#
# Changes:
# <cursor specification> is redundant for Symqle (may be introduced later)
# [ OF column_name_list ] not supported
# SelectStatement methods require these imports, but it has no productions for its methods

<T> SelectStatement<T> ::=
    qe:QueryExpression<T> :: implicit
|
    /**
    * Creates select statement for read only.
    * @return new select statement
    */
    qe:QueryExpression<T>  FOR READ ONLY ::
        AbstractSelectStatement<T> forReadOnly
|
    /**
    * Creates select statement for update.
    * @return new select statement
    */
    qe:QueryExpression<T> FOR UPDATE
        :: AbstractSelectStatement<T> forUpdate
;

##### QueryExpression ####

public interface QueryExpression<T> : QueryBuilder<T> {}
public class AbstractQueryExpression<T> implements QueryExpression<T> {}

# <query expression> ::= [ <with clause> ] <query expression body> [ <order by clause> ] [ <result offset clause> ] [ <fetch first clause> ]
#
# Changes:
# [ <with clause> ] not supported
# [ <result offset clause> ] [ <fetch first clause> ] -> [ <result offset clause> [ <fetch first clause> ]]
# i.e. we require limit if there is an offset, but may be limit only
# offset only is not allowed (mysql limitation)
# additional non-terminals
#     QueryExpressionBasic for <query expression body> [ <order by clause> ]
# two flavors: QueryBuilderExpressionBody and QueryExpressionBodyScalar
# [<result offset clause>] ::= OFFSET <offset row count> { ROW | ROWS }
# <offset row count> ::= <simple value specification>
# <fetch first clause> ::= FETCH { FIRST | NEXT } [ <fetch first row count> ] { ROW | ROWS } ONLY
# <fetch first row count> ::= <simple value specification>
# <simple value specification> ::= <literal>
# | <host parameter name>
# | <SQL parameter reference>
# | <embedded variable name>
# Symqle supports only <literal> here
#
# see QueryExpressionBody.sdl, Sort.sdl

<T> QueryExpression<T> ::=
    qe:QueryExpressionBasic<T> :: implicit
|
    qe:QueryExpressionBasic<T> OFFSET offset:Literal ROWS FETCH FIRST limit:Literal ROWS ONLY ::
      private AbstractQueryExpression<T> offsetAndLimit {}

|
    qe:QueryExpressionBasic<T> FETCH FIRST limit:Literal ROWS ONLY ::
      private AbstractQueryExpression<T> limitOnly {}
;

# public methods
::
    /**
     * Applies limit to {@code (QueryExpression)this}.
     * The resulting AbstractQueryExpression will return not more than {@code limit} number of rows.
     * @param limit the row number limit
     * @return new AbstractQueryExpression with row limit
     */
    <T> AbstractQueryExpression<T> limit(final QueryExpressionBasic<T> qeb, final int limit) {
        return limitOnly(qeb, new IntLiteral(limit));
    }

::
    /**
     * Applies limit and offset to {@code (QueryExpression)this}.
     * @param offset the number of rows to skip
     * @param limit the row number limit
     * @return new AbstractQueryExpression with offset and row limit
     */
    <T> AbstractQueryExpression<T> limit(final QueryExpressionBasic<T> qeb, final int offset, final int limit) {
                  return offsetAndLimit(qeb, new IntLiteral(offset), new IntLiteral(limit));
    }

##### QueryExpressionBasic ####

public interface QueryExpressionBasic <T> : QueryBuilder<T> {}
public class AbstractQueryExpressionBasic <T> implements QueryExpressionBasic<T> {}

# <query expression body> [ <order by clause> ]
# special rule for Aggregates : no Body - Expression - ... - Primary,
# expands as AggregateQuerySpecification

<T> QueryExpressionBasic<T> ::=
    body:QueryExpressionBody<T> :: implicit
|
    body:QueryExpressionBody<T> order:OrderByClause :: private AbstractQueryExpressionBasic<T> orderBy
|
    body:AggregateQuerySpecification<T> :: implicit
;

::
    /**
     * Applies SortSpecifications to {@code (QueryExpressionBody)this}.
     * @param sort first sort specification
     * @param additionalSort sort specifications to apply if previous sort keys are equal
     * @return new AbstractQueryExpressionBasic with sort specifications applied
     */
    <T> AbstractQueryExpressionBasic<T> orderBy(final QueryExpressionBody<T> qe, final SortSpecification sort, final SortSpecification... additionalSort) {
        SortSpecificationList list = createSortSpecificationList(sort);
         for (SortSpecification add : additionalSort) {
             list = appendSortSpecification(list, add);
         }
         return  orderBy(qe, createOrderByClause(list));
    }

# see QueryExpressionBody.sdl, Sort.sdl

# Literal is used by Symqle in limit/offset only, so defining it here
# note that it is not convertible to ValueExpression and is not Scalar;
# we cannot select Literals
# for the time being it is a package scope class

/**
* A terminal symbol of Symqle SQL language.
* Implementing classes are responsible for correct lexis and semantics.
*/
public interface Literal : SqlBuilder {}

import org.symqle.common.StringSqlBuilder;
class IntLiteral implements Literal {
    private final int value;

    IntLiteral(final int value) {
        this.value = value;
    }

    /**
    * Creates an SqlBuilder representing Literal.
    * @param context the Sql construction context
    * @return constructed Sql
    */
    public SqlBuilder z$sqlOfLiteral(final SqlContext context) {
        return new StringSqlBuilder(String.valueOf(value));
    }

}
