##### SelectStatement ####


# corresponds to <direct_select_statement: multiple rows>

import java.sql.SQLException;
import java.util.List;
import org.symqle.jdbc.Option;
import org.symqle.jdbc.QueryEngine;
import org.symqle.jdbc.PreparedQuery;
import org.symqle.common.Callback;
public interface SelectStatement<T> : Query<T> {
}

public class AbstractSelectStatement<T> implements SelectStatement<T> {}

# key Symqle methods to query values

import java.sql.SQLException;
import org.symqle.common.Callback;
import org.symqle.jdbc.Option;
import org.symqle.jdbc.QueryEngine;
::
    /**
     * Executes a statement and calls callback for each returned row.
     * @param engine gate to DB
     * @param callback will be called until it returns false or there are no more rows
     * @param options to be applied to query builder and PreparedStatement
     * @return number of calls to callback
     * @throws SQLException from the underlying jdbc driver
     */
  <T> int scroll(final SelectStatement<T> statement,
                       final QueryEngine engine,
                       final Callback<T> callback,
                       final Option... options) throws SQLException {
      return compileQuery(statement, engine, options).scroll(callback);
  }

import java.sql.SQLException;
import org.symqle.jdbc.Option;
import org.symqle.jdbc.QueryEngine;
import org.symqle.jdbc.PreparedQuery;
::
<T> PreparedQuery<T> compileQuery(final SelectStatement<T> statement,
                                                               final QueryEngine engine,
                                                               final Option... options
                                                               ) {

    final Dialect dialect = engine.getDialect();
    final SqlContext.Builder contextBuilder = new SqlContext.Builder().put(Dialect.class, dialect);
    List<Option> allOptions = new ArrayList<Option>(engine.getOptions());
    allOptions.addAll(Arrays.asList(options));
    UpdatableConfiguration configuration = new UpdatableConfiguration();
    for (Option option : allOptions) {
        option.apply(configuration);
    }
    final Query<T> query = prepareQuery(statement, dialect, configuration);
    return new PreparedQuery<T>(engine, query, allOptions);
}

import java.sql.SQLException;
import java.util.List;
import org.symqle.jdbc.Option;
::
    /**
     * Executes a statement and returns the list of objects of type T.
     * @param engine gate to DB
     * @param options to be applied to query builder and PreparedStatement
     * @return the list of objects
     * @throws SQLException from the underlying jdbc driver
     */
<T> List<T> list(final SelectStatement<T> statement,
                          final QueryEngine engine,
                          final Option... options
                        ) throws SQLException {
    return compileQuery(statement, engine, options).list();
    }

:: private Configuration getDebugConfiguration() {
    final UpdatableConfiguration configuration = new UpdatableConfiguration();
    configuration.setNoFromOk(true);
    configuration.setImplicitCrossJoinsOk(true);
    return configuration;
}

::
    /**
     * Formats a string, which would be passed to prepareStatement method by list() and scroll() methods.
     * @param dialect the dialect to use
     * @param options query builder options
     * @return the query string
     */
String showQuery(final SelectStatement<?> statement, final Dialect dialect, final Option... options) {
     final UpdatableConfiguration configuration = new UpdatableConfiguration();
     for (Option option : options) {
         option.apply(configuration);
     }
    final StringBuilder stringBuilder = new StringBuilder();
    prepareQuery(statement, dialect, configuration).appendTo(stringBuilder);
    return stringBuilder.toString();
    }

:: private static <T> Query<T> prepareQuery(final SelectStatement<T> statement, final Dialect dialect, final Configuration configuration) {
    final SelectTableRegistry tableRegistry = new RootSelectTableRegistry();
    final SqlContext context = new SqlContext.Builder().
            put(ColumnNameGenerator.class, new UniqueColumnNameGenerator()).
            put(TableRegistry.class, tableRegistry).
            put(Dialect.class, dialect).
            put(TableNameGenerator.class, new TableNameGenerator()).
            put(Configuration.class, configuration).toSqlContext();

    statement.z$sqlOfSelectStatement(makeLearningContext(context));
    return statement.z$sqlOfSelectStatement(context);
}

###### SelectStatement Construction methods #####

#  <direct select statement: multiple rows> ::= <cursor specification>
#  <cursor specification> ::= <query expression> [ <updatability clause> ]
# updatability_clause ::= FOR { READ ONLY | UPDATE [ OF column_name_list ] }
#
# Changes:
# <cursor specification> is redundant for Symqle (may be introduced later)
# [ OF column_name_list ] not supported
# SelectStatement methods require these imports, but it has no productions for its methods

<T> SelectStatement<T> ::=
    qe:QueryExpression<T> :: implicit {}
|
    /**
    * Creates select statement for read only.
    * @return new select statement
    */
    qe:QueryExpression<T>  FOR READ ONLY ::
        import java.util.LinkedList;
        AbstractSelectStatement<T> forReadOnly
|
    /**
    * Creates select statement for update.
    * @return new select statement
    */
    qe:QueryExpression<T> FOR UPDATE
        :: AbstractSelectStatement<T> forUpdate
;

##### QueryExpression ####

public interface QueryExpression<T> : Query<T> {}
public class AbstractQueryExpression<T> implements QueryExpression<T> {}

# <query expression> ::= [ <with clause> ] <query expression body> [ <order by clause> ] [ <result offset clause> ] [ <fetch first clause> ]
#
# Changes:
# [ <with clause> ] not supported
# [ <result offset clause> ] [ <fetch first clause> ] -> [ <result offset clause> [ <fetch first clause> ]]
# i.e. we require limit if there is an offset, but may be limit only
# offset only is not allowed (mysql limitation)
# additional non-terminals
#     QueryExpressionBasic for <query expression body> [ <order by clause> ]
# two flavors: QueryExpressionBody and QueryExpressionBodyScalar
# [<result offset clause>] ::= OFFSET <offset row count> { ROW | ROWS }
# <offset row count> ::= <simple value specification>
# <fetch first clause> ::= FETCH { FIRST | NEXT } [ <fetch first row count> ] { ROW | ROWS } ONLY
# <fetch first row count> ::= <simple value specification>
# <simple value specification> ::= <literal>
# | <host parameter name>
# | <SQL parameter reference>
# | <embedded variable name>
# Symqle supports only <literal> here
#
# see QueryExpressionBody.sdl, Sort.sdl

<T> QueryExpression<T> ::=
    qe:QueryExpressionBasic<T> :: implicit {}
|
    qe:QueryExpressionBasic<T> OFFSET offset:Literal ROWS FETCH FIRST limit:Literal ROWS ONLY ::
      private AbstractQueryExpression<T> offsetAndLimit {}

|
    qe:QueryExpressionBasic<T> FETCH FIRST limit:Literal ROWS ONLY ::
      private AbstractQueryExpression<T> limitOnly {}
;

# public methods
::
    /**
     * Creates an AbstractQueryExpression, which returns not more than {@code limit} number of rows.
     * @param limit the row number limit
     * @return new AbstractQueryExpression with row limit
     */
  <T> AbstractQueryExpression<T> limit(final QueryExpressionBasic<T> qeb, int limit) {
      return limitOnly(qeb, new IntLiteral(limit));
  }

::
    /**
     * Applies limit and offset to {@code this}.
     * @param offset the number of rows to skip
     * @param limit the row number limit
     * @return new AbstractQueryExpression with offset and row limit
     */
  <T> AbstractQueryExpression<T> limit(final QueryExpressionBasic<T> qeb, int offset, int limit) {
                return offsetAndLimit(qeb, new IntLiteral(offset), new IntLiteral(limit));
  }

##### QueryExpressionBasic ####

public interface QueryExpressionBasic <T> : Query<T> {}
public class AbstractQueryExpressionBasic <T> implements QueryExpression<T> {}

# <query expression body> [ <order by clause> ]

<T> QueryExpressionBasic<T> ::=
    body:QueryExpressionBody<T> :: implicit {}
|
    body:QueryExpressionBody<T> order:OrderByClause :: private AbstractQueryExpressionBasic<T> orderBy {}
;

::
    /**
     * Applies SortSpecifications to {@code this}.
     * @param sort first sort specification
     * @param additionalSort sort specifications to apply if previous sort keys are equal
     * @return new AbstractQueryExpressionBasic with sort specifications applied
     */
    <T> AbstractQueryExpressionBasic<T> orderBy(final QueryExpressionBody<T> qe, final SortSpecification sort, final SortSpecification... additionalSort) {
        SortSpecificationList list = createSortSpecificationList(sort);
         for (SortSpecification add: additionalSort) {
             list = appendSortSpecification(list, add);
         }
         return  orderBy(qe, createOrderByClause(list));
    }

# see QueryExpressionBody.sdl, Sort.sdl

# Literal is used by Symqle in limit/offset only, so defining it here
# note that it is not convertible to ValueExpression and is not Scalar;
# we cannot select Literals
public interface Literal : Sql {}

import org.symqle.querybuilder.StringSql;
public class IntLiteral implements Literal {
    private final int value;

    public IntLiteral(final int value) {
        this.value = value;
    }

    /**
    * Creates an Sql representing Literal.
    * @param context the Sql construction context
    * @return constructed Sql
    */
    public Sql z$sqlOfLiteral(final SqlContext context) {
        return new StringSql(String.valueOf(value));
    }

}
