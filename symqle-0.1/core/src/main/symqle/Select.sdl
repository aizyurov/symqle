# # corresponds to direct_select-statement in Sql-2003.2
public interface SelectStatement<T> : Query<T>
{}

public class AbstractSelectStatement<T> implements SelectStatement<T>
{}

# key Symqle methods to query values

import java.sql.SQLException;
import org.symqle.common.Callback;
import org.symqle.jdbc.Option;
import org.symqle.jdbc.QueryEngine;
::
    /**
     * Executes a statement and calls callback for each returned row.
     * @param statement provides the query and mapper.
     * @param gate provides connection to DB
     * @param callback will be called until it returns false or there are no more rows
     * @param options will be applied to java.sql.Statement
     * @param <T> the type of object passed to callback
     * @return number of calls to callback
     * @throws SQLException from the underlying jdbc driver
     */
public <T> int scroll(final SelectStatement<T> statement,
                          final QueryEngine engine,
                          final Callback<T> callback,
                          final Option... options
                          ) throws SQLException {
    final SqlContext initialContext = engine.initialContext();
    final UpdatableConfiguration configuration = new UpdatableConfiguration(initialContext.get(Configuration.class));
    for (final Option option : options) {
       option.apply(configuration);
    }
    final Dialect bestDialect = initialContext.get(Dialect.class);
    final Query<T> query = prepareQuery(statement, bestDialect != null ? bestDialect : new GenericDialect(), configuration);
    return engine.scroll(query,
            new Callback<Row>() {
                @Override
                public boolean iterate(Row row) throws SQLException {
                    return callback.iterate(query.extract(row));
                }
            },
            options);
}

import java.sql.SQLException;
import java.util.List;
import org.symqle.jdbc.Option;
::
    /**
     * Executes a statement and returns the list of objects of type T.
     * @param statement provides the query and mapper.
     * @param gate provides connection to DB
     * @param options will be applied to java.sql.Statement
     * @param <T> the type of objects to create from result set rows
     * @return the list of objects
     * @throws SQLException from the underlying jdbc driver
     */
public <T> List<T> list(final SelectStatement<T> statement,
                          final QueryEngine engine,
                          final Option... options
                        ) throws SQLException {
        final List<T> result = new LinkedList<T>();
        scroll(statement,  engine,
            new Callback<T>() {
                public boolean iterate(T arg) {
                    result.add(arg);
                    return true;
                }
             }, options);
        return result;
    }

:: private Configuration getDebugConfiguration() {
    final UpdatableConfiguration configuration = new UpdatableConfiguration();
    configuration.setNoFromOk(true);
    configuration.setImplicitCrossJoinsOk(true);
    return configuration;
}

::
    /**
     * Formats a string, which would be passed to prepareStatement method by list() and scroll() methods.
      * @param statement provides the query source in the form of {@link SelectStatement}
     * @param dialect the dialect to use
     * @param options options to use
     * @return the query string
     */
public String show(final SelectStatement<?> statement, final Dialect dialect, final Option... options) {
     final UpdatableConfiguration configuration = new UpdatableConfiguration();
     for (Option option : options) {
         option.apply(configuration);
     }
     return prepareQuery(statement, dialect, configuration).sql();
    }

:: private static <T> Query<T> prepareQuery(final SelectStatement<T> statement, final Dialect dialect, final Configuration configuration) {
    final SelectTableRegistry tableRegistry = new RootSelectTableRegistry();
    final SqlContext context = new SqlContext.Builder().
            put(UniqueNameProvider.class, new ColumnNameProvider()).
            put(TableRegistry.class, tableRegistry).
            put(Dialect.class, dialect).
            put(Configuration.class, configuration).toSqlContext();

    statement.z$sqlOfSelectStatement(makeLearningContext(context));
    final Query<T> query = statement.z$sqlOfSelectStatement(context);
    return new Query<T>() {
        @Override
        public T extract(final Row row) throws SQLException {
            return query.extract(row);
        }

        @Override
        public String sql() {
            return dialect.formatSql(query.sql());
        }

        @Override
        public void setParameters(final SqlParameters p) throws SQLException {
            query.setParameters(p);
        }
    };
}


# # direct_zSelectStatement:_multiple_rows ::= zCursorSpecification
# # zCursorSpecification ::= zQueryExpression [ zOrderByClause ] [ updatability_clause ]
# # updatability_clause ::= FOR { READ ONLY | UPDATE [ OF column_name_list ] }
# 
# # Symqle re-defines this in the following way:
# # updateability_clause moves to zSelectStatement;
# # OF column_name_list is not supported in the current version (0.7)
# 
# forward references: CursorSpecification, AbstractCursorSpecification

<T> SelectStatement<T> ::=
    cspec:CursorSpecification<T> :: implicit {}
|
    /**
    * Creates select statement for read only.
    * The locking of selected rows depends on transaction isolation.
    * @param cspec the cursor specification to be selected in read only mode.
    * @param <T> the type of objects, to which result set rows will be converted.
    * @return new select statement
    */
    cspec:CursorSpecification<T>  FOR READ ONLY ::
        import java.util.LinkedList;
        public AbstractSelectStatement<T> forReadOnly {}
|
    cspec:CursorSpecification<T> FOR UPDATE
        :: public AbstractSelectStatement<T> forUpdate {}
;


public interface CursorSpecification<T> : Query<T> {}

public class AbstractCursorSpecification<T> implements CursorSpecification<T> {}

# #zCursorSpecification ::= zQueryExpression [ zOrderByClause ] [ updatability_clause ]
# #updatability_clause moved to zSelectStatement
# 
# see QueryExpression.sdl, Sort.sdl

<T> CursorSpecification<T> ::=
    qe:QueryExpression<T> :: implicit {}
|
    qe:QueryExpressionScalar<T> :: implicit {
            public Query<T> z$sqlOfCursorSpecification(final SqlContext context) {
                final Query<T> __rowMapper = qe.z$sqlOfQueryExpressionScalar(context);
                return new ComplexQuery<T>(__rowMapper, context.get(Dialect.class).CursorSpecification_is_QueryExpressionScalar(__rowMapper));
            }/*delegation*/

    }
|
    qe:QueryExpression<T> obc:OrderByClause :: private AbstractCursorSpecification<T> orderBy {}
|
    qe:QueryExpressionScalar<T> obc:OrderByClause :: private AbstractCursorSpecification<T> orderBy {
            public Query<T> z$sqlOfCursorSpecification(final SqlContext context) {
                final Query<T> __rowMapper = qe.z$sqlOfQueryExpressionScalar(context);
                return new ComplexQuery<T>(__rowMapper, context.get(Dialect.class).CursorSpecification_is_QueryExpressionScalar_OrderByClause(__rowMapper, obc.z$sqlOfOrderByClause(context)));
            }/*delegation*/
    }
;

::  public <T> AbstractCursorSpecification<T> orderBy(final QueryExpression<T> qe, final SortSpecification sort, final SortSpecification... additionalSort) {
    SortSpecificationList list = createSortSpecificationList(sort);
     for (SortSpecification add: additionalSort) {
         list = appendSortSpecification(list, add);
     }
     return  orderBy(qe, createOrderByClause(list));
}

::  public <T> AbstractCursorSpecification<T> orderAsc(final QueryExpressionScalar<T> qe) {
      final SortSpecification sortSpec = z$SortSpecification$from$SortOrderingSpecification(asc(createScalarSortKey()));
      SortSpecificationList list = createSortSpecificationList(sortSpec);
      return orderBy(qe, createOrderByClause(list));
}

::  public <T> AbstractCursorSpecification<T> orderDesc(final QueryExpressionScalar<T> qe) {
      final SortSpecification sortSpec = z$SortSpecification$from$SortOrderingSpecification(desc(createScalarSortKey()));
      SortSpecificationList list = createSortSpecificationList(sortSpec);
      return orderBy(qe, createOrderByClause(list));
}

::    private SortKey createScalarSortKey() {
          return new SortKey() {
              @Override
              public Sql z$sqlOfSortKey(final SqlContext context) {
                  return new CustomSql(context.get(UniqueNameProvider.class).getUniqueName());
              }
          };
      }
