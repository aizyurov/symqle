##### SelectStatement ####


# corresponds to <direct_select_statement: multiple rows>

public interface SelectStatement<T> : Query<T> {}

public class AbstractSelectStatement<T> implements SelectStatement<T> {}

# key Symqle methods to query values

import java.sql.SQLException;
import org.symqle.common.Callback;
import org.symqle.jdbc.Option;
import org.symqle.jdbc.QueryEngine;
::
    /**
     * Executes a statement and calls callback for each returned row.
     * @param statement provides the query and mapper.
     * @param engine gate to DB
     * @param callback will be called until it returns false or there are no more rows
     * @param options will be applied to java.sql.Statement
     * @param <T> the type of object passed to callback
     * @return number of calls to callback
     * @throws SQLException from the underlying jdbc driver
     */
public <T> int scroll(final SelectStatement<T> statement,
                          final QueryEngine engine,
                          final Callback<T> callback,
                          final Option... options
                          ) throws SQLException {
    final SqlContext initialContext = engine.initialContext();
    final UpdatableConfiguration configuration = new UpdatableConfiguration(initialContext.get(Configuration.class));
    for (final Option option : options) {
       option.apply(configuration);
    }
    final Dialect bestDialect = initialContext.get(Dialect.class);
    final Query<T> query = prepareQuery(statement, bestDialect != null ? bestDialect : new GenericDialect(), configuration);
    return engine.scroll(query,
            new Callback<Row>() {
                @Override
                public boolean iterate(Row row) throws SQLException {
                    return callback.iterate(query.extract(row));
                }
            },
            options);
}

import java.sql.SQLException;
import java.util.List;
import org.symqle.jdbc.Option;
::
    /**
     * Executes a statement and returns the list of objects of type T.
     * @param statement provides the query and mapper.
     * @param engine gate to DB
     * @param options will be applied to java.sql.Statement
     * @param <T> the type of objects to create from result set rows
     * @return the list of objects
     * @throws SQLException from the underlying jdbc driver
     */
public <T> List<T> list(final SelectStatement<T> statement,
                          final QueryEngine engine,
                          final Option... options
                        ) throws SQLException {
        final List<T> result = new LinkedList<T>();
        scroll(statement,  engine,
            new Callback<T>() {
                public boolean iterate(T arg) {
                    result.add(arg);
                    return true;
                }
             }, options);
        return result;
    }

:: private Configuration getDebugConfiguration() {
    final UpdatableConfiguration configuration = new UpdatableConfiguration();
    configuration.setNoFromOk(true);
    configuration.setImplicitCrossJoinsOk(true);
    return configuration;
}

::
    /**
     * Formats a string, which would be passed to prepareStatement method by list() and scroll() methods.
      * @param statement provides the query source in the form of {@link SelectStatement}
     * @param dialect the dialect to use
     * @param options options to use
     * @return the query string
     */
public String show(final SelectStatement<?> statement, final Dialect dialect, final Option... options) {
     final UpdatableConfiguration configuration = new UpdatableConfiguration();
     for (Option option : options) {
         option.apply(configuration);
     }
     final StringBuilder sqlBuilder = new StringBuilder();
     prepareQuery(statement, dialect, configuration).append(sqlBuilder);
    return sqlBuilder.toString();
    }

:: private static <T> Query<T> prepareQuery(final SelectStatement<T> statement, final Dialect dialect, final Configuration configuration) {
    final SelectTableRegistry tableRegistry = new RootSelectTableRegistry();
    final SqlContext context = new SqlContext.Builder().
            put(UniqueNameProvider.class, new ColumnNameProvider()).
            put(TableRegistry.class, tableRegistry).
            put(Dialect.class, dialect).
            put(Configuration.class, configuration).toSqlContext();

    statement.z$sqlOfSelectStatement(makeLearningContext(context));
    final Query<T> query = statement.z$sqlOfSelectStatement(context);
    return new Query<T>() {
        @Override
        public T extract(final Row row) throws SQLException {
            return query.extract(row);
        }

        @Override
        public void append(final StringBuilder builder) {
            final StringBuilder tmp = new StringBuilder();
            query.append(tmp);
            builder.append(dialect.formatSql(tmp.toString()));
        }

        @Override
        public void setParameters(final SqlParameters p) throws SQLException {
            query.setParameters(p);
        }
    };
}

###### SelectStatement Construction methods #####

#  <direct select statement: multiple rows> ::= <cursor specification>
#  <cursor specification> ::= <query expression> [ <updatability clause> ]
# updatability_clause ::= FOR { READ ONLY | UPDATE [ OF column_name_list ] }
#
# Changes:
# <cursor specification> is redundant for Symqle (may be intrioduced later
# [ OF column_name_list ] not supported

<T> SelectStatement<T> ::=
    qe:QueryExpression<T> :: implicit {}
|
    /**
    * Creates select statement for read only.
    * The locking of selected rows depends on transaction isolation.
    * @param cspec the cursor specification to be selected in read only mode.
    * @param <T> the type of objects, to which result set rows will be converted.
    * @return new select statement
    */
    qe:QueryExpression<T>  FOR READ ONLY ::
        import java.util.LinkedList;
        public AbstractSelectStatement<T> forReadOnly {}
|
    qe:QueryExpression<T> FOR UPDATE
        :: public AbstractSelectStatement<T> forUpdate {}
;

##### QueryExpression ####

public interface QueryExpression<T> : Query<T> {}
public class AbstractQueryExpression<T> implements QueryExpression<T> {}

# <query expression> ::= [ <with clause> ] <query expression body> [ <order by clause> ] [ <result offset clause> ] [ <fetch first clause> ]
#
# Changes:
# [ <with clause> ] not supported
# [ <result offset clause> ] [ <fetch first clause> ] -> [ <result offset clause> [ <fetch first clause> ]]
# i.e. we require limit if there is an offset, but may be limit only
# offset only is not allowed (mysql limitation)
# additional non-terminals
#     QueryExpressionBasic for <query expression body> [ <order by clause> ]
# two flavors: QueryExpressionBody and QueryExpressionBodyScalar
# [<result offset clause>] ::= OFFSET <offset row count> { ROW | ROWS }
# <offset row count> ::= <simple value specification>
# <fetch first clause> ::= FETCH { FIRST | NEXT } [ <fetch first row count> ] { ROW | ROWS } ONLY
# <fetch first row count> ::= <simple value specification>
# <simple value specification> ::= <literal>
# | <host parameter name>
# | <SQL parameter reference>
# | <embedded variable name>
# Symqle supports only <literal> here
#
# see QueryExpressionBody.sdl, Sort.sdl

<T> QueryExpression<T> ::=
    qe:QueryExpressionBasic<T> :: implicit {}
|
    qe:QueryExpressionBasic<T> OFFSET offset:Literal ROWS FETCH FIRST limit:Literal ROWS ONLY ::
      private AbstractQueryExpression<T> offsetAndLimit {}

|
    qe:QueryExpressionBasic<T> LIMIT limit:Literal ::
      private AbstractQueryExpression<T> limitOnly {}
;

# public methods
:: public <T> AbstractQueryExpression<T> limit(final QueryExpressionBasic<T> qeb, int limit) {
    return limitOnly(qeb, new IntLiteral(limit));
}

:: public <T> AbstractQueryExpression<T> limit(final QueryExpressionBasic<T> qeb, int limit, int offset) {
              return offsetAndLimit(qeb, new IntLiteral(offset), new IntLiteral(limit));
}

##### QueryExpressionBasic ####

public interface QueryExpressionBasic <T> : Query<T> {}
public class AbstractQueryExpressionBasic <T> implements QueryExpression<T> {}

# <query expression body> [ <order by clause> ]

<T> QueryExpressionBasic<T> ::=
    body:QueryExpressionBody<T> :: implicit {}
|
    body:QueryExpressionBody<T> order:OrderByClause :: private AbstractQueryExpressionBasic<T> orderBy {}
|
    body:QueryExpressionBodyScalar<T> :: implicit {}
|
    body:QueryExpressionBodyScalar<T> order:OrderByClause :: private AbstractQueryExpressionBasic<T> orderBy {}
;

::  public <T> AbstractQueryExpressionBasic<T> orderBy(final QueryExpressionBody<T> qe, final SortSpecification sort, final SortSpecification... additionalSort) {
    SortSpecificationList list = createSortSpecificationList(sort);
     for (SortSpecification add: additionalSort) {
         list = appendSortSpecification(list, add);
     }
     return  orderBy(qe, createOrderByClause(list));
}

::  public <T> AbstractQueryExpressionBasic<T> orderBy(final QueryExpressionBodyScalar<T> qe, final SortSpecification sort, final SortSpecification... additionalSort) {
    SortSpecificationList list = createSortSpecificationList(sort);
     for (SortSpecification add: additionalSort) {
         list = appendSortSpecification(list, add);
     }
     return  orderBy(qe, createOrderByClause(list));
}

# see QueryExpressionBody.sdl, Sort.sdl

# Literal is used by Symqle in limit/offset only, so defining it here
# note that it is not convertible to ValueExpression and is not Scalar;
# we cannot select Literals
public interface Literal : Sql {}

import org.symqle.querybuilder.CustomSql;
public class IntLiteral implements Literal {
    private final int value;

    public IntLiteral(int value) {
        this.value = value;
    }

    /**
    * Creates an Sql representing Literal.
    * @param context the Sql construction context
    * @return constructed Sql
    */
    public Sql z$sqlOfLiteral(SqlContext context) {
        return new CustomSql(String.valueOf(value));
    }

}
