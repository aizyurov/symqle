
import org.symqle.common.Pair;
public interface SelectList<T> : QueryBuilder<T> {}
public class AbstractSelectList<T> implements SelectList<T> {}

<T> SelectList<T> ::= sl:SelectSublist<T> :: implicit
;

# non-trivial construction of resulting Query; cannot be derived automatically
import org.symqle.common.Pair;
<T, U> SelectList<Pair<T, U>> ::=
     /**
     * Creates a new SelectList representing a pair of {@code this} and {@code other}.
     * @param other the second participant of resulting SelectList
     * @param <U> {@code other} type argument
     * @return new AbstractSelectList
     */
    self:SelectList<T> COMMA other:SelectList<U> :: AbstractSelectList<Pair<T, U>> pair {
            /**
            * Creates a Query representing <code>this</code>
            * @param context the Sql construction context
            * @return query conforming to <code>this</code> syntax
            */
            public QueryBuilder<Pair<T, U>> z$sqlOfSelectList(final SqlContext context) {
                final QueryBuilder<T> query1 = self.z$sqlOfSelectList(context);
                final QueryBuilder<U> query2 = other.z$sqlOfSelectList(context);
                RowMapper<Pair<T, U>> extractor = new RowMapper<Pair<T, U>>() {
                    @Override
                    public Pair<T, U> extract(final Row row) throws SQLException {
                        return Pair.make(query1.extract(row), query2.extract(row));
                    }
                };
                return new ComplexQueryBuilder<Pair<T, U>>(extractor, context.get(Dialect.class).SelectList_is_SelectList_COMMA_SelectList(query1, query2));
            }
    }
;

public interface SelectListScalar<T> extends Scalar<T> : QueryBuilder<T> {}

<T> SelectListScalar<T> ::=
  sl:SelectSublist<T> :: implicit
;

public interface SelectSublist<T> extends Scalar<T> : QueryBuilder<T> {}
public class AbstractSelectSublist<T> implements SelectSublist<T> {}

/**
* A terminal symbol of Symqle SQL language.
* Implementing classes are responsible for correct lexis and semantics.
*/
public interface Identifier : SqlBuilder {}

<T> SelectSublist<T> ::= ve:ValueExpression<T> ::
    implicit {
           /**
            * Creates a Query representing <code>this</code>
            * @param context the Sql construction context
            * @return query conforming to <code>this</code> syntax
            */
            public QueryBuilder<T> z$sqlOfSelectSublist(final SqlContext context) {
                final ColumnNameGenerator nameProvider = context.get(ColumnNameGenerator.class);
                final SqlBuilder veSql = ve.z$sqlOfValueExpression(context);
                if (nameProvider == null) {
                    return new ComplexQueryBuilder<T>(new NullRowMapper<T>(),
                    context.get(Dialect.class).SelectSublist_is_ValueExpression(veSql));
                } else {
                    final String name = nameProvider.getUniqueName();
                    return new ComplexQueryBuilder<T>(new RowMapper<T>() {
                                @Override
                                public T extract(final Row row) throws SQLException {
                                    return ve.getMapper().value(row.getValue(name));
                                }
                            }, context.get(Dialect.class).SelectSublist_is_ValueExpression_AS_Identifier(veSql, new StringSqlBuilder(name)));
                }
            }
    }
|
    ve:ValueExpression<T> AS id:Identifier
;


::
/**
* Set a label to {@code this}.
* Label can be referenced later in OrderBy clause.
* @param label the label to associate with {@code this}
* @return new AbstractSelectSublist
*/
<T> AbstractSelectSublist<T> label(final ValueExpression<T> ve, final Label label) {
  return new AbstractSelectSublist<T>() {
          public QueryBuilder<T> z$sqlOfSelectSublist(final SqlContext context) {
              final ColumnNameGenerator nameProvider = context.get(ColumnNameGenerator.class);
              final SqlBuilder veSql = ve.z$sqlOfValueExpression(context);
              if (nameProvider == null) {
                  throw new MalformedStatementException("Label cannot be used in this context");
              } else {
                  final String name = nameProvider.getUniqueName();
                  label.setName(ve, name);
                  return new ComplexQueryBuilder<T>(new RowMapper<T>() {
                              @Override
                              public T extract(final Row row) throws SQLException {
                                  return ve.getMapper().value(row.getValue(name));
                              }
                          }, context.get(Dialect.class).SelectSublist_is_ValueExpression_AS_Identifier(veSql, new StringSqlBuilder(name)));
              }
          }
        @Override
        public Mapper<T> getMapper() {
            return ve.getMapper();
        }
  };
}

public interface AggregateSelectSublist<T> extends Scalar<T> : QueryBuilder<T> {}

<T> AggregateSelectSublist<T> ::= aggr:AggregateFunction<T> ::
    implicit {
            /**
            * Creates a Query representing <code>this</code>
            * @param context the Sql construction context
            * @return query conforming to <code>this</code> syntax
            */
            public QueryBuilder<T> z$sqlOfAggregateSelectSublist(final SqlContext context) {
                final ColumnNameGenerator nameProvider = context.get(ColumnNameGenerator.class);
                final SqlBuilder aggrSql = aggr.z$sqlOfAggregateFunction(context);
                if (nameProvider == null) {
                    return new ComplexQueryBuilder<T>(new NullRowMapper<T>(),
                    context.get(Dialect.class).AggregateSelectSublist_is_AggregateFunction(aggrSql));
                } else {
                    final String name = nameProvider.getUniqueName();
                    return new ComplexQueryBuilder<T>(new RowMapper<T>() {
                                @Override
                                public T extract(final Row row) throws SQLException {
                                    return aggr.getMapper().value(row.getValue(name));
                                }
                            }, context.get(Dialect.class).AggregateSelectSublist_is_AggregateFunction_AS_Identifier(aggrSql, new StringSqlBuilder(name)));
                }
            }
    }
|
    aggr:AggregateFunction<T> AS id:Identifier
;
