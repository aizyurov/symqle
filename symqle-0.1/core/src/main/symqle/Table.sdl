import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.symqle.common.*;
import org.symqle.querybuilder.StringSql;
import org.symqle.querybuilder.TableNameGenerator;

public abstract class TableOrView implements TablePrimary,
                                                            TableName,
                                                            TableReference {


    private TableOrView referral = null;
    private final Map<TableOrView, JoinInfo> referents = new LinkedHashMap<TableOrView, JoinInfo>();

    public abstract String getTableName();

    private final int LEFT_JOIN = 1;
    private final int RIGHT_JOIN = 2;
    private final int INNER_JOIN = 3;
    private final int OUTER_JOIN = 4;
    
    
    private static class JoinInfo {
        private final int joinType;
        private final BooleanExpression condition;

        private JoinInfo(final int joinType, final BooleanExpression condition) {
            this.joinType = joinType;
            this.condition = condition;
        }
    }


    private Set<TableOrView> allReachable() {
        final Set<TableOrView> reachable = new HashSet<TableOrView>(referents.keySet());
        for (TableOrView referent: referents.keySet()) {
            reachable.addAll(referent.allReachable());
        }
        return reachable;
    }



    private void checkJoin(TableOrView other) {
        if (other.referral != null) {
            throw new MalformedStatementException(other + "is already joined to "+ other.referral);
        }
        List<TableOrView> cycle = new ArrayList<TableOrView>();
        // try to find cycle starting from other
        TableOrView t;
        for (t = this; t != null; t = t.referral) {
            cycle.add(0, t);
            if (other==t) {
                // cycle!
                throw new MalformedStatementException("Cyclic join: " + cycle);
            }
        }
        // OK, came to the root
    }

    protected final <T> Column<T> defineColumn(final Mapper<T> mapper, final String name) {
        return new Column<T>(mapper, name, this);
    }

    public String getCorrelationName(SqlContext context) {
        String name;
        for (name = context.get(TableRegistry.class).getCorrelationName(this);
                name == null;
                name = context.get(TableRegistry.class).getCorrelationName(this)) {
            context.get(TableRegistry.class).addAll(joinedTableParticipants(), context.get(TableNameGenerator.class));
        }
        return name;
    }

    public void innerJoin(TableOrView other, BooleanExpression condition) {
        checkJoin(other);
        other.referral = this;
        referents.put(other, new JoinInfo(INNER_JOIN, condition));
    }

    public Set<TableOrView> joinedTableParticipants() {
        if (referral != null) {
            return referral.joinedTableParticipants();
        } else {
            Set<TableOrView> participants = new LinkedHashSet<TableOrView>();
            participants.add(this);
            participants.addAll(allReachable());
            return participants;
        }
    }

    public TableOrView joinedTableRoot() {
        return referral == null ? this : referral.joinedTableRoot();
    }

    public void leftJoin(TableOrView other, BooleanExpression condition) {
        checkJoin(other);
        other.referral = this;
        referents.put(other, new JoinInfo(LEFT_JOIN, condition));
    }

    public void outerJoin(TableOrView other, BooleanExpression condition) {
        checkJoin(other);
        other.referral = this;
        referents.put(other, new JoinInfo(OUTER_JOIN, condition));
    }

    public void rightJoin(TableOrView other, BooleanExpression condition) {
        checkJoin(other);
        other.referral = this;
        referents.put(other, new JoinInfo(RIGHT_JOIN, condition));
    }

    /**
    * Creates an Sql representing <code>this</code>
    * @param context the Sql construction context
    * @return sql conforming to <code>this</code> syntax
    */
    public Sql z$sqlOfTableName(SqlContext context) {
        return new StringSql(getTableName());
    }

    /**
    * Creates an Sql representing <code>this</code>
    * @param context the Sql construction context
    * @return sql conforming to <code>this</code> syntax
    */
    public Sql z$sqlOfTablePrimary(SqlContext context) {
        return context.get(Dialect.class).TablePrimary_is_TableName_AS_Identifier(this.z$sqlOfTableName(context),
                new StringSql(getCorrelationName(context)));
    }

    /**
    * Creates an Sql representing <code>this</code>
    * @param context the Sql construction context
    * @return sql conforming to <code>this</code> syntax
    */
    public Sql z$sqlOfTableReference(SqlContext context) {
        TableReference tableReference = Symqle.asTableReference(this);
        for (Map.Entry<TableOrView, JoinInfo> entry : referents.entrySet()) {
            final TableOrView referent = entry.getKey();
            final JoinInfo joinInfo = entry.getValue();
            switch (joinInfo.joinType) {
                case LEFT_JOIN : 
                    tableReference = Symqle.leftJoin(tableReference, referent, joinInfo.condition);
                    break;
                case RIGHT_JOIN : 
                    tableReference = Symqle.rightJoin(tableReference, referent, joinInfo.condition);
                    break;
                case INNER_JOIN : 
                    tableReference = Symqle.innerJoin(tableReference, referent, joinInfo.condition);
                    break;
                case OUTER_JOIN : 
                    tableReference = Symqle.outerJoin(tableReference, referent, joinInfo.condition);
                    break;
            }
        }
        return tableReference.z$sqlOfTableReference(context);
    }

}
