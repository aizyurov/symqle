#############################################################################
#
#   Copyright 2010-2013 Alexander Izyurov
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.package org.symqle.common;
#
##############################################################################

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.symqle.common.MalformedStatementException;
import org.symqle.common.Mapper;
import org.symqle.common.StringSqlBuilder;
import org.symqle.querybuilder.TableNameGenerator;

/**
 * Corresponds to Table, View or Synonym.
 * It is read-only: you can use columns of this table to construct queries
 * and join to other tables, but there are no methods to create dta change statements.
 * For updatable entities use {@link Table}.
 * Use {@link #defineColumn(org.symqle.common.Mapper, String)} to add columns to model.
 */
public abstract class TableOrView implements TablePrimary,
                                                            TableReference,
                                                            TableName {



    private TableOrView referral = null;

    private final Map<TableOrView, DeferredJoin> referents = new LinkedHashMap<TableOrView, DeferredJoin>();

    private abstract static class DeferredJoin {
        private final TableReference referent;
        private final BooleanExpression condition;

        protected DeferredJoin(final TableReference referent, final BooleanExpression condition) {
            this.referent = referent;
            this.condition = condition;
        }

        protected final TableReference getReferent() {
            return referent;
        }

        protected final BooleanExpression getCondition() {
            return condition;
        }

        protected abstract TableReference makeJoin(TableReference referral);
    }

    private static final class LeftDeferredJoin extends DeferredJoin {
        private LeftDeferredJoin(final TableReference referent, final BooleanExpression condition) {
            super(referent, condition);
        }
        @Override
        protected TableReference makeJoin(final TableReference referral) {
            return Symqle.leftJoin(referral, getReferent(), getCondition());
        }
    }

    private static final class RightDeferredJoin extends DeferredJoin {
        private RightDeferredJoin(final TableReference referent, final BooleanExpression condition) {
            super(referent, condition);
        }
        @Override
        protected TableReference makeJoin(final TableReference referral) {
            return Symqle.rightJoin(referral, getReferent(), getCondition());
        }
    }

    private static final class InnerDeferredJoin extends DeferredJoin {
        private InnerDeferredJoin(final TableReference referent, final BooleanExpression condition) {
            super(referent, condition);
        }
        @Override
        protected TableReference makeJoin(final TableReference referral) {
            return Symqle.innerJoin(referral, getReferent(), getCondition());
        }
    }

    private static final class OuterDeferredJoin extends DeferredJoin {
        private OuterDeferredJoin(final TableReference referent, final BooleanExpression condition) {
            super(referent, condition);
        }
        @Override
        protected TableReference makeJoin(final TableReference referral) {
            return Symqle.outerJoin(referral, getReferent(), getCondition());
        }
    }


    private Set<TableOrView> allReachable() {
        final Set<TableOrView> reachable = new HashSet<TableOrView>(referents.keySet());
        for (TableOrView referent : referents.keySet()) {
            reachable.addAll(referent.allReachable());
        }
        return reachable;
    }


    private void checkJoin(final TableOrView other) {
        if (other.referral != null) {
            throw new MalformedStatementException(other + "is already joined to " + other.referral);
        }
        List<TableOrView> cycle = new ArrayList<TableOrView>();
        // try to find cycle starting from other
        TableOrView t;
        for (t = this; t != null; t = t.referral) {
            cycle.add(0, t);
            if (other == t) {
                // cycle!
                throw new MalformedStatementException("Cyclic join: " + cycle);
            }
        }
        // OK, came to the root
    }



    /**
     * Use in derived classes to define table columns.
     * @param mapper the mapper to use
     * @param name column name
     * @param <T> associated Java type
     * @return new instance of Column
     */
    protected final <T> Column<T> defineColumn(final Mapper<T> mapper, final String name) {
        return new Column<T>(mapper, name, this);
    }


    final String getCorrelationName(final SqlContext context) {
        String name;
        for (name = context.get(TableRegistry.class).getCorrelationName(this);
                name == null;
                name = context.get(TableRegistry.class).getCorrelationName(this)) {
            context.get(TableRegistry.class).addAll(joinedTableParticipants(), context.get(TableNameGenerator.class));
        }
        return name;
    }


    /**
    * Table name as accepted by database: identifier or quoted identifier.
    * @return table name
    */
    public abstract String getTableName();


    /**
     * Creates {@code this INNER JOIN other ON condition}.
     * Modifies {@code this}.
     * @param other the table to join
     * @param condition join condition
     * @param <T> type of {@code other}
     * @return other
     */
    public final <T extends TableOrView> T innerJoin(final T other, final BooleanExpression condition) {
        join(other, new InnerDeferredJoin(other, condition));
        return other;
    }


    private void join(final TableOrView other, final DeferredJoin join) {
        checkJoin(other);
        other.referral = this;
        referents.put(other, join);
    }



    final Set<TableOrView> joinedTableParticipants() {
        if (referral != null) {
            return referral.joinedTableParticipants();
        } else {
            Set<TableOrView> participants = new LinkedHashSet<TableOrView>();
            participants.add(this);
            participants.addAll(allReachable());
            return participants;
        }
    }


    final TableOrView joinedTableRoot() {
        return referral == null ? this : referral.joinedTableRoot();
    }


    /**
     * Creates {@code this LEFT JOIN other ON condition}.
     * Modifies {@code this}.
     * @param other the table to join
     * @param condition join condition
     * @param <T> type of {@code other}
     * @return other
     */
    public final <T extends TableOrView> T leftJoin(final T other, final BooleanExpression condition) {
        join(other, new LeftDeferredJoin(other, condition));
        return other;
    }


    /**
     * Creates {@code this OUTER JOIN other ON condition}.
     * Modifies {@code this}.
     * @param other the table to join
     * @param condition join condition
     * @param <T> type of {@code other}
     * @return other
     */
    public final <T extends TableOrView> T outerJoin(final T other, final BooleanExpression condition) {
        join(other, new OuterDeferredJoin(other, condition));
        return other;
    }


    /**
     * Creates {@code this RIGHT JOIN other ON condition}.
     * Modifies {@code this}.
     * @param other the table to join
     * @param condition join condition
     * @param <T> type of {@code other}
     * @return other
     */
    public final <T extends TableOrView> T rightJoin(final T other, final BooleanExpression condition) {
        join(other, new RightDeferredJoin(other, condition));
        return other;
    }



    /**
    * Creates an SqlBuilder representing <code>(TableName)this</code>.
    * @param context the Sql construction context
    * @return sql conforming to <code>this</code> syntax
    */
    public final SqlBuilder z$sqlOfTableName(final SqlContext context) {
        return new StringSqlBuilder(getTableName());
    }


    /**
    * Creates an SqlBuilder representing <code>(TablePrimary)this</code>.
    * @param context the Sql construction context
    * @return sql conforming to <code>this</code> syntax
    */
    public final SqlBuilder z$sqlOfTablePrimary(final SqlContext context) {
        return context.get(Dialect.class)
              .TablePrimary_is_TableName_AS_Identifier(this.z$sqlOfTableName(context),
                new StringSqlBuilder(getCorrelationName(context)));
    }


    /**
    * Creates an SqlBuilder representing <code>(TableReference)this</code>.
    * @param context the Sql construction context
    * @return sql conforming to <code>this</code> syntax
    */
    public final SqlBuilder z$sqlOfTableReference(final SqlContext context) {
        TableReference tableReference = Symqle.asTableReference(this);
        for (DeferredJoin join : referents.values()) {
            tableReference = join.makeJoin(tableReference);
        }
        return tableReference.z$sqlOfTableReference(context);
    }

}
