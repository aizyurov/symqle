import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.symqle.common.MalformedStatementException;
import org.symqle.common.Mapper;
import org.symqle.querybuilder.StringSql;
import org.symqle.querybuilder.TableNameGenerator;

/**
 * Corresponds to Table, View or Synonym.
 * It is read-only: you can use columns of this table to construct queries
 * and join to other tables, but there are no methods to create dta change statements.
 * For updatable entities use {@link Table}.
 * Use {@link #defineColumn(org.symqle.common.Mapper, String)} to add columns to model.
 */
public abstract class TableOrView implements TablePrimary,
                                                            TableName,
                                                            TableReference {


    private TableOrView referral = null;
    private final Map<TableOrView, JoinInfo> referents = new LinkedHashMap<TableOrView, JoinInfo>();

    /**
    * Table name as accepted by database: identifier or quoted identifier.
    * @return table name
    */
    public abstract String getTableName();

    private static final int LEFT_JOIN = 1;
    private static final int RIGHT_JOIN = 2;
    private static final int INNER_JOIN = 3;
    private static final int OUTER_JOIN = 4;


    private static class JoinInfo {
        private final int joinType;
        private final BooleanExpression condition;

        public JoinInfo(final int joinType, final BooleanExpression condition) {
            this.joinType = joinType;
            this.condition = condition;
        }
    }

    private Set<TableOrView> allReachable() {
        final Set<TableOrView> reachable = new HashSet<TableOrView>(referents.keySet());
        for (TableOrView referent : referents.keySet()) {
            reachable.addAll(referent.allReachable());
        }
        return reachable;
    }

    private void checkJoin(final TableOrView other) {
        if (other.referral != null) {
            throw new MalformedStatementException(other + "is already joined to " + other.referral);
        }
        List<TableOrView> cycle = new ArrayList<TableOrView>();
        // try to find cycle starting from other
        TableOrView t;
        for (t = this; t != null; t = t.referral) {
            cycle.add(0, t);
            if (other == t) {
                // cycle!
                throw new MalformedStatementException("Cyclic join: " + cycle);
            }
        }
        // OK, came to the root
    }


    /**
     * Use in derived classes to define table columns.
     * @param mapper the mapper to use
     * @param name column name
     * @param <T> associated Java type
     * @return new instance of Column
     */
    protected final <T> Column<T> defineColumn(final Mapper<T> mapper, final String name) {
        return new Column<T>(mapper, name, this);
    }

    final String getCorrelationName(final SqlContext context) {
        String name;
        for (name = context.get(TableRegistry.class).getCorrelationName(this);
                name == null;
                name = context.get(TableRegistry.class).getCorrelationName(this)) {
            context.get(TableRegistry.class).addAll(joinedTableParticipants(), context.get(TableNameGenerator.class));
        }
        return name;
    }


    final Set<TableOrView> joinedTableParticipants() {
        if (referral != null) {
            return referral.joinedTableParticipants();
        } else {
            Set<TableOrView> participants = new LinkedHashSet<TableOrView>();
            participants.add(this);
            participants.addAll(allReachable());
            return participants;
        }
    }

    final TableOrView joinedTableRoot() {
        return referral == null ? this : referral.joinedTableRoot();
    }

    private void join(final TableOrView other, final int type, final BooleanExpression condition) {
        checkJoin(other);
        other.referral = this;
        referents.put(other, new JoinInfo(type, condition));
    }

    /**
     * Creates {@code this INNER JOIN other ON condition}.
     * Modifies {@code this}.
     * @param other the table to join
     * @param condition join condition
     * @param <T> type of {@code other}
     * @return other
     */
    public final <T extends TableOrView> T innerJoin(final T other, final BooleanExpression condition) {
        join(other, INNER_JOIN, condition);
        return other;
    }

    /**
     * Creates {@code this LEFT JOIN other ON condition}.
     * Modifies {@code this}.
     * @param other the table to join
     * @param condition join condition
     * @param <T> type of {@code other}
     * @return other
     */
    public final <T extends TableOrView> T leftJoin(final T other, final BooleanExpression condition) {
        join(other, LEFT_JOIN, condition);
        return other;
    }

    /**
     * Creates {@code this OUTER JOIN other ON condition}.
     * Modifies {@code this}.
     * @param other the table to join
     * @param condition join condition
     * @param <T> type of {@code other}
     * @return other
     */
    public final <T extends TableOrView> T outerJoin(final T other, final BooleanExpression condition) {
        join(other, OUTER_JOIN, condition);
        return other;
    }

    /**
     * Creates {@code this RIGHT JOIN other ON condition}.
     * Modifies {@code this}.
     * @param other the table to join
     * @param condition join condition
     * @param <T> type of {@code other}
     * @return other
     */
    public final <T extends TableOrView> T rightJoin(final T other, final BooleanExpression condition) {
        join(other, RIGHT_JOIN, condition);
        return other;
    }


    /**
    * Creates an Sql representing <code>(TableName)this</code>.
    * @param context the Sql construction context
    * @return sql conforming to <code>this</code> syntax
    */
    public final Sql z$sqlOfTableName(final SqlContext context) {
        return new StringSql(getTableName());
    }

    /**
    * Creates an Sql representing <code>(TablePrimary)this</code>.
    * @param context the Sql construction context
    * @return sql conforming to <code>this</code> syntax
    */
    public final Sql z$sqlOfTablePrimary(final SqlContext context) {
        return context.get(Dialect.class)
              .TablePrimary_is_TableName_AS_Identifier(this.z$sqlOfTableName(context),
                new StringSql(getCorrelationName(context)));
    }

    /**
    * Creates an Sql representing <code>(TableReference)this</code>.
    * @param context the Sql construction context
    * @return sql conforming to <code>this</code> syntax
    */
    public final Sql z$sqlOfTableReference(final SqlContext context) {
        TableReference tableReference = Symqle.asTableReference(this);
        for (Map.Entry<TableOrView, JoinInfo> entry : referents.entrySet()) {
            final TableOrView referent = entry.getKey();
            final JoinInfo joinInfo = entry.getValue();
            switch (joinInfo.joinType) {
                case LEFT_JOIN :
                    tableReference = Symqle.leftJoin(tableReference, referent, joinInfo.condition);
                    break;
                case RIGHT_JOIN :
                    tableReference = Symqle.rightJoin(tableReference, referent, joinInfo.condition);
                    break;
                case INNER_JOIN :
                    tableReference = Symqle.innerJoin(tableReference, referent, joinInfo.condition);
                    break;
                case OUTER_JOIN :
                    tableReference = Symqle.outerJoin(tableReference, referent, joinInfo.condition);
                    break;
            }
        }
        return tableReference.z$sqlOfTableReference(context);
    }

}
