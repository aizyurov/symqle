#############################################################################
#
#   Copyright 2010-2013 Alexander Izyurov
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.package org.symqle.common;
#
##############################################################################

import java.util.Collection;
import org.symqle.querybuilder.TableNameGenerator;
/**
 * Symqle internal structure, holding table to correlation name mapping.
 *
 */
public interface TableRegistry {

    /**
     * Adds tables to the registry and generates correlation names for them.
     * @param tables the tables to add.
     * @param generator used to generate correlation names
     */
    void addAll(Collection<TableOrView> tables, final TableNameGenerator generator);

    /**
     * Gets correlation name for given table.
     * @param table the table
     * @return correlation name; null if table not found (never added).
     */
    String getCorrelationName(TableOrView table);

}

import java.util.List;
/**
 * Symqle internal structure, holding tables in the current select clause scope.
 *
 */
public interface SelectTableRegistry extends TableRegistry {

    /**
     * Tables local to current scope.
     * Tables from enclosing scopes are not included.
     * @return the list of local tables
     */
    List<TableOrView> getLocal();

    /**
     * Locks {@code this}.
     * After a call to this method, adding new tables to the registry is not allowed.
     */
    void lock();
}

import java.util.*;
import java.util.Collection;
import java.util.List;
import org.symqle.common.Bug;
import org.symqle.common.MalformedStatementException;


 class RootSelectTableRegistry implements SelectTableRegistry {

    private Map<TableOrView, String> localTables = new HashMap<TableOrView, String>();

    private boolean locked = false;


    public void addAll(final Collection<TableOrView> tables, final TableNameGenerator generator) {
        if (locked) {
            throw new MalformedStatementException("Illegal in this context: " + tables);
        }
        // it expected that addAll is called only when none of the tables
        // had been registered yet
        for (TableOrView table : tables) {
            Bug.reportIfNotNull(getCorrelationName(table));
            addToLocalTables(table, generator);
        }
    }


    private void addToLocalTables(final TableOrView table, final TableNameGenerator generator) {
            final String newName = generator.generate(table.getTableName());
            localTables.put(table, newName);
    }

    public String getCorrelationName(final TableOrView table) {
        return localTables.get(table);
    }


    public List<TableOrView> getLocal() {
        return new ArrayList<TableOrView>(localTables.keySet());
    }


     @Override
     public void lock() {
         locked = true;
     }
}

class ChildSelectTableRegistry extends RootSelectTableRegistry {

    private final TableRegistry parent;

    public ChildSelectTableRegistry(final TableRegistry parent) {
        this.parent = parent;
    }

    public String getCorrelationName(final TableOrView table) {
        final String parentName = parent.getCorrelationName(table);
        return parentName != null ? parentName : super.getCorrelationName(table);
    }

}


import java.util.*;
import org.symqle.common.Bug;
import org.symqle.common.MalformedStatementException;
class DataChangeTableRegistry implements TableRegistry {

    private TableOrView targetTable;

    public final void addAll(final Collection<TableOrView> tables, final TableNameGenerator generator) {
        Bug.reportIf(tables.isEmpty());
        Set<TableOrView> illegalTables = new HashSet<TableOrView>(tables);
        if (targetTable != null) {
            illegalTables.remove(targetTable);
        }
        if (tables.size() > 1) {
            throw new MalformedStatementException("Illegal in this context: " + illegalTables);
        } else {
            final TableOrView table = tables.iterator().next();
            if (targetTable == null) {
                targetTable = table;
                generator.force(targetTable.getTableName());
            } else {
                Bug.reportIf(table.equals(targetTable));
                // table can be added only once
                throw new MalformedStatementException("Illegal in this context: " + illegalTables);
            }
        }
    }


    public final String getCorrelationName(final TableOrView table) {
        if (table.equals(targetTable)) {
            return targetTable.getTableName();
        } else {
            return null;
        }
    }

}

import org.symqle.common.MalformedStatementException;
class NoTablesRegistry implements TableRegistry {
    private final TableRegistry parent;

     NoTablesRegistry(final TableRegistry parent) {
         this.parent = parent;
     }


     public final void addAll(final Collection<TableOrView> tables, final TableNameGenerator generator) {
        throw new MalformedStatementException("Illegal in this context: " + tables);
    }

    public final String getCorrelationName(final TableOrView table) {
        if (parent.getCorrelationName(table) != null) {
            throw new MalformedStatementException("Illegal in this context: " + table);
        }
        return null;
    }

}
