# <update statement: searched> ::= UPDATE <target table> SET <set clause list> [ WHERE <search condition> ]
# <set clause list> ::= <set clause> [ { <comma> <set clause> }... ]
# <set clause> ::=
#		<multiple column assignment>
#	|	<set target> <equals operator> <update source>
#
# <set target> ::= <update target> | <mutated set clause>
#
# <multiple column assignment> ::= <set target list> <equals operator> <assigned row>
#
# <set target list> ::= <left paren> <set target> [ { <comma> <set target> }... ] <right paren>
#
# <assigned row> ::= <contextually typed row value expression>
#
# <update target> ::=
#		<object column>
#	|	<object column> <left bracket or trigraph> <simple value specification> <right bracket or trigraph>
#
# <object column> ::= <column name>
#
# <mutated set clause> ::= <mutated target> <period> <method name>
# <update source> ::= <value expression> | <contextually typed value specification>
# <contextually typed value specification> ::=
#  		<implicitly typed value specification> | <default specification>
#
#  <implicitly typed value specification> ::= <null specification> | <empty specification>
#
#  <null specification> ::= NULL
#  <default specification> ::= DEFAULT

import java.sql.SQLException;
import org.symqle.jdbc.Option;
import org.symqle.jdbc.Engine;
import org.symqle.jdbc.Batcher;
import org.symqle.jdbc.PreparedUpdate;
public interface DataChangeStatement : Sql {}

:: private static Sql prepareUpdate(final DataChangeStatement statement, final Builder contextBuilder, final List<Option> options) {
        final UpdatableConfiguration configuration = new UpdatableConfiguration();
        for (final Option option : options) {
           option.apply(configuration);
        }
        final SqlContext context = contextBuilder
                .put(Configuration.class, configuration)
                .put(TableRegistry.class, new DataChangeTableRegistry())
                .put(TableNameGenerator.class, new TableNameGenerator())
                .toSqlContext();
        return statement.z$sqlOfDataChangeStatement(context);
    }



import org.symqle.jdbc.Option;
:: String showUpdate(final DataChangeStatement statement, final Dialect dialect, final Option... options) {
     final SqlContext.Builder contextBuilder = new SqlContext.Builder().put(Dialect.class, dialect);
     final StringBuilder sqlBuilder = new StringBuilder();
     prepareUpdate(statement, contextBuilder, Arrays.asList(options)).appendTo(sqlBuilder);
     return sqlBuilder.toString();
}

import org.symqle.jdbc.Option;
import org.symqle.jdbc.Engine;
import java.sql.SQLException;
:: public int execute(final DataChangeStatement statement, final Engine engine, final Option... options) throws SQLException {
     return compileUpdate(statement, engine, options).execute();
}

import org.symqle.jdbc.PreparedUpdate;
:: public PreparedUpdate compileUpdate(final DataChangeStatement statement, final Engine engine, final Option... options) {
     final SqlContext.Builder contextBuilder = new SqlContext.Builder().put(Dialect.class, engine.getDialect());
     List<Option> allOptions = new ArrayList<Option>(engine.getOptions());
     allOptions.addAll(Arrays.asList(options));
     final Sql sql = prepareUpdate(statement, contextBuilder, allOptions);
     return new PreparedUpdate(engine, sql, allOptions, null);
}


import org.symqle.jdbc.Batcher;
:: public int[] submit(final DataChangeStatement statement, final Batcher batcher, final Option... options) throws SQLException {
        return compileUpdate(statement, batcher.getEngine(), options).submit(batcher);
   }

DataChangeStatement ::=
    s:UpdateStatement :: implicit {}
|
    s:InsertStatement :: implicit {}
|
    s:DeleteStatement :: implicit {}
;

public interface UpdateStatement : Sql {}

public class AbstractUpdateStatement implements UpdateStatement {}

UpdateStatement ::=
    b:UpdateStatementBase :: implicit {}
|
    b:UpdateStatementBase wc:WhereClause ::
        public AbstractUpdateStatement where {}
;

public interface UpdateStatementBase : Sql {}

public class AbstractUpdateStatementBase implements UpdateStatementBase {}

UpdateStatementBase ::=
    UPDATE t:TargetTable SET l:SetClauseList :: AbstractUpdateStatementBase update {}
;

public interface TargetTable : Sql {}

public interface SetClauseList extends InsertColumnList, ContextuallyTypedRowValueList : Sql {}

SetClauseList ::=
    c:SetClause :: implicit {}
|
    l:SetClauseList COMMA c:SetClauseList :: SetClauseList also {
            /**
            * Creates an Sql representing ContextuallyTypedRowValueList.
            * @param context the Sql construction context
            * @return constructed Sql
            */
            public Sql z$sqlOfContextuallyTypedRowValueList(final SqlContext context) {
                return combineRowValueLists(l, c).z$sqlOfContextuallyTypedRowValueList(context);
            }
            /**
            * Creates an Sql representing InsertColumnList.
            * @param context the Sql construction context
            * @return constructed Sql
            */
            public Sql z$sqlOfInsertColumnList(final SqlContext context) {
                return combineInsertColumnLists(l, c).z$sqlOfInsertColumnList(context);
            }
    }
;

public interface SetClause extends InsertColumn, ContextuallyTypedRowValueElement : Sql {}

public class AbstractSetClause implements SetClause {
              /**
              * Creates an Sql representing InsertColumnList.
              * @param context the Sql construction context
              * @return constructed Sql
              */
              public final Sql z$sqlOfInsertColumnList(final SqlContext context) {
                  return Symqle.z$InsertColumnList$from$InsertColumn(this).z$sqlOfInsertColumnList(context);
              }
}

:: public <T> AbstractSetClause set(final ColumnName<T> column, final T value) {
    return set(column, DynamicParameter.create(column.getMapper(), value));
}

<T> SetClause ::=
    c:ColumnName<T> EQ e:ValueExpression<T> :: public AbstractSetClause set {
            public Sql z$sqlOfContextuallyTypedRowValueElement(final SqlContext context) {
                return e.z$sqlOfValueExpression(context);
            }

            public Sql z$sqlOfInsertColumn(final SqlContext context) {
                return c.z$sqlOfColumnName(context);
            }
    }
;

SetClause ::=
    c:ColumnName<?> EQ NULL :: public AbstractSetClause setNull {
            public Sql z$sqlOfContextuallyTypedRowValueElement(final SqlContext context) {
                return SqlTerm.NULL;
            }
            public Sql z$sqlOfInsertColumn(final SqlContext context) {
                return c.z$sqlOfColumnName(context);
            }
    }
|
    c:ColumnName<?> EQ DEFAULT :: public AbstractSetClause setDefault {
            public Sql z$sqlOfContextuallyTypedRowValueElement(final SqlContext context) {
                return SqlTerm.DEFAULT;
            }
            public Sql z$sqlOfInsertColumn(final SqlContext context) {
                return c.z$sqlOfColumnName(context);
            }
    }
;


public interface ColumnName<T> extends Scalar<T> : Sql {}


import java.util.Collections;
public abstract class Table extends TableOrView implements TargetTable {

    public Sql z$sqlOfTargetTable(final SqlContext context) {
        context.get(TableRegistry.class).addAll(Collections.<TableOrView>singleton(this), context.get(TableNameGenerator.class));
        return new StringSql(getTableName());
    }
}


import java.sql.SQLException;
import org.symqle.jdbc.Option;
import org.symqle.jdbc.Engine;
import org.symqle.jdbc.GeneratedKeys;
import org.symqle.jdbc.PreparedUpdate;
public interface InsertStatement : Sql {}
public class AbstractInsertStatement implements InsertStatement {}

# TODO <override clause> not implemented

InsertStatement ::=
#    INSERT INTO t:TargetTable s:FromSubquery
#        :: protected AbstractInsertStatement fromSubquery {}
#|
    INSERT INTO t:TargetTable s:FromConstructor
        :: private AbstractInsertStatement insert {}
|
    INSERT INTO t:TargetTable DEFAULT VALUES
        :: public AbstractInsertStatement insertDefault {}
;

:: public AbstractInsertStatement insert(final TargetTable targetTable, final SetClauseList list) {
    return insert(targetTable, createFromConstructor(list, createTableValueConstructor(list)));
}

# interface FromSubquery : Sql {}

interface FromConstructor : Sql {}

# FromSubquery ::= LEFT_PAREN l:InsertColumnList RIGHT_PAREN e:QueryExpression
#         :: protected FromSubquery createFromSubquery {}
# ;


FromConstructor ::= LEFT_PAREN l:InsertColumnList RIGHT_PAREN t:TableValueConstructor
         :: private FromConstructor createFromConstructor {
            /**
            * Creates an Sql representing FromConstructor.
            * @param context the Sql construction context
            * @return constructed Sql
            */
            public Sql z$sqlOfFromConstructor(final SqlContext context) {
                final SqlContext innerContext = context.newBuilder()
                        .put(TableRegistry.class, new NoTablesRegistry(context.get(TableRegistry.class)))
                        .put(TableNameGenerator.class, new TableNameGenerator())
                        .toSqlContext();
                return context.get(Dialect.class)
                  .FromConstructor_is_LEFT_PAREN_InsertColumnList_RIGHT_PAREN_TableValueConstructor(
                        l.z$sqlOfInsertColumnList(context), t.z$sqlOfTableValueConstructor(innerContext));
            }
         }
;

interface InsertColumnList : Sql {}

InsertColumnList ::=
    c:InsertColumn :: implicit {}
|
    l:InsertColumnList COMMA c:InsertColumnList :: private InsertColumnList combineInsertColumnLists {}
;

public interface InsertColumn : Sql {}

interface TableValueConstructor : Sql {}

# only one row is supported so far. The syntax is not that of SQL-2011, but is supported by all major databases
# (standard define
TableValueConstructor ::= VALUES LEFT_PAREN l:ContextuallyTypedRowValueList RIGHT_PAREN :: private TableValueConstructor createTableValueConstructor {

}
;

interface ContextuallyTypedRowValueList : Sql {}

ContextuallyTypedRowValueList ::=
    e:ContextuallyTypedRowValueElement
        :: implicit {}
|
    l:ContextuallyTypedRowValueList COMMA d:ContextuallyTypedRowValueList
        :: private ContextuallyTypedRowValueList combineRowValueLists {}
;

public interface ContextuallyTypedRowValueElement : Sql {}

public interface DeleteStatement : Sql {}

public class AbstractDeleteStatement implements DeleteStatement {}

DeleteStatement ::= b:DeleteStatementBase :: implicit {}
|
    b:DeleteStatementBase wc:WhereClause :: public AbstractDeleteStatement where {}
;

public interface DeleteStatementBase : Sql {}

public class AbstractDeleteStatementBase implements DeleteStatementBase {}

DeleteStatementBase ::= DELETE FROM t:TargetTable :: public AbstractDeleteStatementBase delete {}
;

import org.symqle.jdbc.GeneratedKeys;
:: public int execute(final InsertStatement statement, GeneratedKeys<?> generatedKeys, final Engine engine, final Option... options) throws SQLException {
       return compileUpdate(statement, generatedKeys, engine, options).execute();
}


:: public PreparedUpdate compileUpdate(final InsertStatement statement, GeneratedKeys<?> generatedKeys, final Engine engine, final Option... options) throws SQLException {
     final SqlContext.Builder contextBuilder = new SqlContext.Builder().put(Dialect.class, engine.getDialect());
     List<Option> allOptions = new ArrayList<Option>(engine.getOptions());
     allOptions.addAll(Arrays.asList(options));
       final DataChangeStatement dataChange = new AbstractInsertStatement() {
           @Override
           public Sql z$sqlOfInsertStatement(final SqlContext context) {
               return statement.z$sqlOfInsertStatement(context);
           }
       };
      final Sql sql = prepareUpdate(dataChange, contextBuilder, allOptions);
      return new PreparedUpdate(engine, sql, allOptions, generatedKeys);
}

