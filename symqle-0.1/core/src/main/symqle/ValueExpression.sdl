public interface ValueExpression<T> extends Scalar<T> : Sql {}

// public class AbstractValue<T> implements ValueExpression<T> {}

# Hierarchy of ValueExpression approximately follows SQL standard.
# For some interfaces type parameters are bounded
# <row value expression> is not considered being <value expression>
# it is not Scalar and we have different rules for RowValueExpression and ValueExpression

public class AbstractValueExpression<T> implements ValueExpression<T> {}

:: public <T> AbstractValueExpression<T> map(final ValueExpression<?> e, final Mapper<T> mapper) {
    return new AbstractValueExpression<T>() {
        @Override
        public Mapper<T> getMapper() {
            return mapper;
        }

        @Override
        public Sql z$sqlOfValueExpression(final SqlContext context) {
            return e.z$sqlOfValueExpression(context);
        }
    };
}


<T> ValueExpression<T> ::=
    e:NumericExpression<T> :: implicit {}
|
    e:StringExpression<T> :: implicit {}
|
    e:ValueExpressionPrimary<T> :: implicit {}
;

# see BooleanValueExpression.sdl
ValueExpression<Boolean> ::=  bve:BooleanExpression :: public AbstractValueExpression<Boolean> asValue {
                public Mapper<Boolean> getMapper() {
                    return CoreMappers.BOOLEAN;
                }
    }
;

# no abstract class: no methods - removed as unnecessary
// public interface CommonValueExpression<T> extends Scalar<T> : Sql {}

public interface StringExpression<T> extends Scalar<T> : Sql {}

public class AbstractStringExpression<T> implements StringExpression<T> {}

:: public <T> AbstractStringExpression<T> map(final StringExpression<?> e, final Mapper<T> mapper) {
    return new AbstractStringExpression<T>() {
        @Override
        public Mapper<T> getMapper() {
            return mapper;
        }

        @Override
        public Sql z$sqlOfStringExpression(final SqlContext context) {
            return e.z$sqlOfStringExpression(context);
        }
    };
}


<T> StringExpression<T> ::=
    cf:CharacterFactor<T> :: implicit {}
;

StringExpression<String> ::=
    s:StringExpression<?> CONCAT e:CharacterFactor<?>
        :: public AbstractStringExpression<String> concat {
                public Mapper<String> getMapper() {
                    return CoreMappers.STRING;
                }
        }
;

# SUBSTRING <left paren> <character value expression> FROM <start position> [ FOR <string length> ] [ USING <char length units> ] <right paren>

StringExpression<String> ::=
    SUBSTRING LEFT_PAREN s:StringExpression<?> FROM start:NumericExpression<?> RIGHT_PAREN
        :: public AbstractStringExpression<String> substring {
                public Mapper<String> getMapper() {
                    return CoreMappers.STRING;
                }
        }
|
    SUBSTRING LEFT_PAREN s:StringExpression<?> FROM start:NumericExpression<?> FOR len:NumericExpression<?> RIGHT_PAREN
        :: public AbstractStringExpression<String> substring {
                public Mapper<String> getMapper() {
                    return CoreMappers.STRING;
                }
        }
;

:: public AbstractStringExpression<String> substring(StringExpression<?> source, int start) {
    return substring(source, DynamicParameter.create(CoreMappers.INTEGER, start));
}

:: public AbstractStringExpression<String> substring(StringExpression<?> source, int start, int len) {
    return substring(source, DynamicParameter.create(CoreMappers.INTEGER, start), DynamicParameter.create(CoreMappers.INTEGER, len));
}

:: public AbstractStringExpression<String> concat(final StringExpression<?> e, final String s) {
    return concat(e,  DynamicParameter.create(CoreMappers.STRING, s));
}

public interface CharacterFactor<T> extends Scalar<T> : Sql {}

public class AbstractCharacterFactor<T> implements CharacterFactor<T> {}

public interface CollationName : Sql {}

<T> CharacterFactor<T> ::=
    e:ValueExpressionPrimary<T> :: implicit {}
|
    e:ValueExpressionPrimary<T> COLLATE cn:CollationName :: private AbstractCharacterFactor<T> collate {}
;

:: public <T> AbstractCharacterFactor<T> collate (final ValueExpressionPrimary<T> e, final String collationName) {
     return collate(e, new CollationName() {
         @Override
         public Sql z$sqlOfCollationName(final SqlContext context) {
             return new CustomSql(collationName);
         }
     });
}

# POSITION <left paren> <string value expression> IN <string value expression> [ USING <char length units> ] <right paren>

NumericExpression<Integer> ::= POSITION  LEFT_PAREN pattern:StringExpression<?> IN source:StringExpression<?> RIGHT_PAREN
    :: private AbstractNumericExpression<Integer> pos {
                public Mapper<Integer> getMapper() {
                    return CoreMappers.INTEGER;
                }
    }
;

:: public AbstractNumericExpression<Integer> positionOf(StringExpression<?> source, StringExpression<?> pattern) {
    return pos(pattern, source);
}

:: public AbstractNumericExpression<Integer> positionOf(StringExpression<?> source, String pattern) {
    return pos(DynamicParameter.create(CoreMappers.STRING, pattern), source);
}


