public interface ValueExpressionPrimary<T> extends Scalar<T> : SqlBuilder {}

<T> ValueExpressionPrimary<T> ::=
    LEFT_PAREN e:ValueExpression<T> RIGHT_PAREN :: implicit
|
    p:DynamicParameterSpecification<T> :: implicit
|
    c:ColumnReference<T> :: implicit
|
    /**
     * Converts {@code (ScalarSubquery)this} to an expression, which represents the
     * subquery return value.
     * It is assumed that the subquery returns exactly one row.
     * @return expression representing
     * subquery return value.
     */
    s:ScalarSubquery<T> :: AbstractValueExpressionPrimary<T> queryValue
|
    e:CaseExpression<T> :: implicit
|
    r:RoutineInvocation<T> :: implicit
|
    c:CastSpecification<T> :: implicit
;

public class AbstractValueExpressionPrimary<T> implements ValueExpressionPrimary<T> {}

::
    /**
    * Changes mapper of {@code this}.
    * The result produces the same SQL but is associated with different Java type.
    * Symqle does not check that the replacement is valid, is is your responsibility.
    * @param newMapper new mapper to use.
    * @param <R> new associated Java type
    * @return new AbstractNumericExpression with required mapper.
    */
    <R> AbstractValueExpressionPrimary<R> map(final ValueExpressionPrimary<?> e, final Mapper<R> newMapper) {
        return new AbstractValueExpressionPrimary<R>() {
            @Override
            public Mapper<R> getMapper() {
                return newMapper;
            }

            @Override
            public SqlBuilder z$sqlOfValueExpressionPrimary(final SqlContext context) {
                return e.z$sqlOfValueExpressionPrimary(context);
            }
        };
    }



/**
* A terminal symbol of Symqle SQL language.
* Implementing classes are responsible for correct lexis and semantics.
* @param <T> Java type of parameter value
*/
public interface DynamicParameterSpecification<T> extends Scalar<T> : SqlBuilder {}

import org.symqle.common.Mapper;
import org.symqle.common.SqlParameters;
/**
* Mutable dynamic parameter. Constructs SQL as required for
* DynamicParameterSpecification. Sets current value to OutBox.
* The current value can be changed at any time.
* @param <T> Java type of parameter value
*/
public class DynamicParameter<T> implements DynamicParameterSpecification<T> {
    private final Mapper<T> mapper;
    private T currentValue;

    /**
     * Creates a new dynamic parameter with given initial value.
     * @param mapper the mapper to use when passing this parameter value to database
     * @param value initial value
     */
    public DynamicParameter(final Mapper<T> mapper, final T value) {
        this.mapper = mapper;
        this.currentValue = value;
     }

    /**
     * Creates a new dynamic parameter with initial value {@code value}.
     * @param mapper the mapper to use when passing this parameter value to database
     * @param value initial value
     * @param <T> the type of value of this dynamic parameter
     * @return constructed dynamic parameter
     */
     public static <T> DynamicParameter<T> create(final Mapper<T> mapper, final T value) {
        return new DynamicParameter<T>(mapper, value);
     }

    /**
     * Creates a new dynamic parameter with initial value {@code null}.
     * @param mapper the mapper to use
     * @param <T> the type of value of this dynamic parameter
     * @return constructed dynamic parameter
     */
     public static <T> DynamicParameter<T> create(final Mapper<T> mapper) {
        return new DynamicParameter<T>(mapper, null);
     }


    /**
     * Changes the value, which this parameter holds.
     * @param value new value
     */
     public final void setValue(final T value) {
        this.currentValue = value;
     }

      /**
      * Creates an SqlBuilder representing <code>this</code>.
      * @param context the Sql construction context
      * @return sql conforming to <code>this</code> syntax
      */
      public final SqlBuilder z$sqlOfDynamicParameterSpecification(final SqlContext context) {
          return new SqlBuilder() {
              @Override
              public void appendTo(final StringBuilder builder) {
                  builder.append("?");
              }

              @Override
              public void setParameters(final SqlParameters p) throws SQLException {
                  mapper.setValue(p.next(), currentValue);
              }

              @Override
              public char firstChar() {
                  return '?';
              }
          };
      }

    /**
     * Mapper for this parameter.
     * @return the mapper
     */
     public final Mapper<T> getMapper() {
        return mapper;
     }

}

public interface ColumnReference<T> extends Scalar<T> : SqlBuilder {}

<T> ColumnReference<T> ::=
    tableRef:Identifier PERIOD columnName:ColumnName<T>
;

import org.symqle.common.StringSqlBuilder;
import org.symqle.common.Mapper;
/**
 * This class represents a database column.
 * It does not have public constructor; use {@link TableOrView#defineColumn(org.symqle.common.Mapper, String)}
 * to create an instance of Column.
 * @param <T> associated Java type. Objects of this type
 * will be returned by {@link #list(org.symqle.jdbc.QueryEngine, org.symqle.jdbc.Option...)}
 * and can be set via {@link #set(Object)} and then written to the database.
 */
public class Column<T> implements ColumnReference<T>, ColumnName<T> {
    private final String columnName;
    private final TableOrView owner;
    private final Mapper<T> mapper;

    Column(final Mapper mapper, final String name,  final TableOrView owner)  {
        this.mapper = mapper;
        this.columnName = name;
        this.owner = owner;
     }

    /**
    * Creates an SqlBuilder representing ColumnReference.
    * @param context the Sql construction context
    * @return constructed Sql
    */
    public final SqlBuilder z$sqlOfColumnReference(final SqlContext context) {
        final String correlationName = owner.getCorrelationName(context);
        return context.get(Dialect.class).ColumnReference_is_Identifier_PERIOD_ColumnName(
                new StringSqlBuilder(correlationName),
                z$sqlOfColumnName(context));
    }

    /**
    * Creates an Sql representing ColumnName.
    * @param context the Sql construction context
    * @return constructed Sql
    */
    public final SqlBuilder z$sqlOfColumnName(final SqlContext context) {
        // make sure that owner is valid in the context
        // by getting correlation name; the result is not used
        owner.getCorrelationName(context);
        return new StringSqlBuilder(columnName);
    }

    /**
     * Mapper for this Column.
     * @return the mapper
     */
    public final Mapper<T> getMapper() {
        return mapper;
    }
}


public interface RoutineInvocation<T> extends Scalar<T> : SqlBuilder {}

public class AbstractRoutineInvocation<T> implements RoutineInvocation<T> {}

<T> RoutineInvocation<T> ::=
    rn:RoutineName<T> LEFT_PAREN al:ArgumentList RIGHT_PAREN
        :: private AbstractRoutineInvocation<T> invoke
|
    rn:RoutineName<T> LEFT_PAREN RIGHT_PAREN
        :: private AbstractRoutineInvocation<T> invoke
;

::
    /**
     * Creates an expression, which represents the result of call of {@code this} with
     * given arguments.
     * @param arg the arguments
     * @return created expression
     */
  <T> AbstractRoutineInvocation<T> apply(final RoutineName<T> routine, final ValueExpression<?>... arg) {
      if (arg.length == 0) {
          return invoke(routine);
      } else {
          ArgumentList al = createArgument(arg[0]);
          int i;
          for (i = 1; i < arg.length; i++) {
              al = appendArgument(al, arg[i]);
          }
          return invoke(routine, al);
      }
  }

/**
* A terminal symbol of Symqle SQL language.
* Implementing classes are responsible for correct lexis and semantics.
* @param <T> Java type of returned value
*/
public interface RoutineName<T> extends Scalar<T> : SqlBuilder {}

public interface ArgumentList : SqlBuilder {}

ArgumentList ::=
    e:ValueExpression<?> :: private ArgumentList createArgument {}
|
    al:ArgumentList COMMA e:ValueExpression<?>
        :: private ArgumentList appendArgument {}
;

import org.symqle.common.StringSqlBuilder;
/**
 * An implementation of RoutineName.
 * @param <T> Java type of returned value
 */
public class SqlFunction<T> implements RoutineName<T> {
    private final String functionName;
    private final Mapper<T> functionMapper;

    /**
     * Constructs new SqlFunction.
     * @param name function name
     * @param mapper mapper to use
     */
    public SqlFunction(final String name, final Mapper<T> mapper) {
        this.functionName = name;
        this.functionMapper = mapper;
    }

    /**
    * Creates an SqlBuilder representing RoutineName.
    * @param context the Sql construction context
    * @return constructed Sql
    */
    public final SqlBuilder z$sqlOfRoutineName(final SqlContext context) {
        return new StringSqlBuilder(functionName);
    }

    /**
     * Mapper for this function.
     * @return the mapper
     */
    public final Mapper<T> getMapper() {
        return functionMapper;
    }

    /**
     * Constructs new SqlFunction.
     * @param name function name
     * @param mapper mapper to use
     * @param <T> Java type of return value
     * @return new instance of SqlFunction
     */
    public static <T> SqlFunction<T> create(final String name, final Mapper<T> mapper) {
        return new SqlFunction<T>(name, mapper);
    }
}


public interface CaseExpression<T> extends Scalar<T> : SqlBuilder {}

# Case abbreviations are not included here (considering them as functions, e.g nullIf)
# only <searched case> is supported
# <searched case> ::= CASE <searched when clause>... [ <else clause> ] END

<T> CaseExpression<T> ::= CASE l:SearchedWhenClauseList<T> END :: implicit
;

public interface SearchedWhenClauseList<T> extends Scalar<T> : SqlBuilder {}

public class AbstractSearchedWhenClauseList<T> implements SearchedWhenClauseList<T> {}

<T> SearchedWhenClauseList<T> ::=
    l:SearchedWhenClauseBaseList<T> :: implicit
|
    /**
     * Creates a new conditional expression by appending {@code ELSE value} to {@code this} SQL.
     * @param elseValue the value of conditional expression if all conditions are false
     * @return constructed when clause list, which produces SQL like {@code WHEN c1 THEN v1 ... ELSE value}
     */
    l:SearchedWhenClauseBaseList<T> elseValue:ElseClause<T> :: AbstractSearchedWhenClauseList<T> orElse
;

public interface ElseClause<T> extends Scalar<T> : SqlBuilder {}

<T> ElseClause<T> ::= ELSE e:ValueExpression<T> :: implicit {}
;

public interface SearchedWhenClauseBaseList<T> extends Scalar<T> : SqlBuilder {}
public class AbstractSearchedWhenClauseBaseList<T> implements SearchedWhenClauseBaseList<T> {}

<T> SearchedWhenClauseBaseList<T> ::=
    c:SearchedWhenClause<T> :: implicit {}
|
    /**
     * Chain another conditional expression to {code this}.
     * @param whenClause another when clause, see {@link BooleanExpression#then(ValueExpression)}.
     * @return constructed when clause list, which produces SQL like {@code WHEN c1 THEN v1 ELSE WHEN c2 ELSE v2...}
     */
    l:SearchedWhenClauseBaseList<T> whenClause:SearchedWhenClause<T> :: AbstractSearchedWhenClauseBaseList<T> orWhen
|
    /**
     * Chain another conditional expression to {code this}.
     * @param whenClause another when clause with null value if condition is true,
     * see {@link BooleanExpression#thenNull()}.
     * @return constructed when clause list, which produces SQL like {@code WHEN c1 THEN v1 ELSE WHEN c2 ELSE NULL}
     */
    l:SearchedWhenClauseBaseList<T> whenClause:ThenNullClause :: AbstractSearchedWhenClauseBaseList<T> orWhen
;

public interface SearchedWhenClause<T> extends Scalar<T> : SqlBuilder {}
public class AbstractSearchedWhenClause<T> implements SearchedWhenClause<T> {}

<T> SearchedWhenClause<T> ::=
    /**
     * Creates a when clause {@code WHEN this THEN value}.
     * @param value the expression value when condition is true
     * @param <T> Java type associated with value
     * @return new when clause
     */
    WHEN condition:BooleanExpression THEN value:ValueExpression<T> :: AbstractSearchedWhenClause<T> then {
        private final Mapper<T> mapper = value.getMapper();
        public Mapper<T> getMapper() {
            return mapper;
        }
    }
;

public interface ThenNullClause : SqlBuilder {}

ThenNullClause ::=
    /**
     * Creates a when clause {@code WHEN this THEN NULL}.
     * @return new when clause
     */
    WHEN condition:BooleanExpression THEN NULL :: ThenNullClause thenNull {}
;

public interface CastSpecification<T> extends Scalar<T> : SqlBuilder {}

public abstract class AbstractCastSpecification<T> implements CastSpecification<T> {}

# only ValueExpression is supported, though standard allows NullSpecification (CAST (NULL AS ...))
<T> CastSpecification<T> ::=
    CAST LEFT_PAREN e:ValueExpression<T> AS target:CastTarget RIGHT_PAREN :: private AbstractCastSpecification<T> cast {
    }
;

::
    /**
     * Creates an expression equivalent to {@code CAST(this AS castTarget)}.
     * It does not affect associated Java type, this is database-side cast.
     * @param castTarget any valid database type name.
     * @return created expression
     */
    <T> AbstractCastSpecification<T> cast(final ValueExpression<T> e, final String castTarget) {
         return cast(e, new CastTarget() {
             @Override
             public SqlBuilder z$sqlOfCastTarget(final SqlContext context) {
                 return new StringSqlBuilder(castTarget);
             }
         });
    }

/**
* A terminal symbol of Symqle SQL language.
* Implementing classes are responsible for correct lexis and semantics.
*/
public interface CastTarget : SqlBuilder {}

# Special ValueExpressionPrimary, which may have different names in dialects
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
ValueExpressionPrimary<Date> ::=
   /**
    * {@code current_date}.
    * @return ValueExpressionPrimary, which SQL code is {@code current_date}
    */
    CURRENT_DATE :: public AbstractValueExpressionPrimary<Date> currentDate {
      public Mapper<Date> getMapper() {
          return CoreMappers.DATE;
      }
    }
;

ValueExpressionPrimary<Timestamp> ::=
   /**
    * {@code current_timestamp}.
    * @return ValueExpressionPrimary, which SQL code is {@code current_timestamp}
    */
    CURRENT_TIMESTAMP :: public AbstractValueExpressionPrimary<Timestamp> currentTimestamp {
       public Mapper<Timestamp> getMapper() {
           return CoreMappers.TIMESTAMP;
       }
    }
;

ValueExpressionPrimary<Time> ::=
   /**
    * {@code current_time}.
    * @return ValueExpressionPrimary, which SQL code is {@code current_time}
    */
    CURRENT_TIME :: public AbstractValueExpressionPrimary<Time> currentTime {
       public Mapper<Time> getMapper() {
           return CoreMappers.TIME;
       }
    }
;

ValueExpressionPrimary<String> ::=
   /**
    * {@code current_user}.
    * @return ValueExpressionPrimary, which SQL code is {@code current_user}
    */
    CURRENT_USER :: public AbstractValueExpressionPrimary<String> currentUser {
       public Mapper<String> getMapper() {
           return CoreMappers.STRING;
       }
    }
;



