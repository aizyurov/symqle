public interface ValueExpressionPrimary<T> extends Scalar<T> : Sql {}

<T> ValueExpressionPrimary<T> ::=
     LEFT_PAREN e:ValueExpression<T> RIGHT_PAREN :: implicit
|
     p:DynamicParameterSpecification<T> :: implicit
|
	   c:ColumnReference<T> :: implicit
|
    /**
     * Converts {@code (ScalarSubquery)this} to an expression, which represents the
     * subquery return value.
     * It is assumed that the subquery returns exactly one row.
     * @return expression representing
     * subquery return value.
     */
    s:ScalarSubquery<T> :: AbstractValueExpressionPrimary<T> queryValue
|
    e:CaseExpression<T> :: implicit
|
	  r:RoutineInvocation<T> :: implicit
|
    c:CastSpecification<T> :: implicit
;

public class AbstractValueExpressionPrimary<T> implements ValueExpressionPrimary<T> {}

::
    /**
    * Changes mapper of {@code this}.
    * The result produces the same SQL but is associated with different Java type.
    * Symqle does not check that the replacement is valid, is is your responsibility.
    * @param mapper new mapper to use.
    * @param <A> new associated Java type
    * @return new AbstractNumericExpression with required mapper.
    */
    <A> AbstractValueExpressionPrimary<A> map(final ValueExpressionPrimary<?> e, final Mapper<A> mapper) {
        return new AbstractValueExpressionPrimary<A>() {
            @Override
            public Mapper<A> getMapper() {
                return mapper;
            }

            @Override
            public Sql z$sqlOfValueExpressionPrimary(final SqlContext context) {
                return e.z$sqlOfValueExpressionPrimary(context);
            }
        };
    }



import org.symqle.common.SqlParameters;
public interface DynamicParameterSpecification<T> extends Scalar<T> : Sql {}

import org.symqle.common.Mapper;
public class DynamicParameter<T> implements DynamicParameterSpecification<T> {
    private final Mapper<T> mapper;
    private T value;

    private DynamicParameter(final Mapper<T> mapper, T value) {
        this.mapper = mapper;
        this.value = value;
     }

    /**
     * Creates a new dynamic parameter with initial value {@code value}
     * @param mapper the mapper to use when passing this parameter value to database
     * @param value initial value
     * @param <T> the type of value of this dynamic parameter
     * @return constructed dynamic parameter
     */
     public static <T> DynamicParameter<T> create(final Mapper<T> mapper, final T value) {
        return new DynamicParameter<T>(mapper, value); 
     }

    /**
     * Creates a new dynamic parameter with initial value {@code null}
     * @param mapper the mapper to use
     * @param <T> the type of value of this dynamic parameter
     * @return constructed dynamic parameter
     */
     public static <T> DynamicParameter<T> create(final Mapper<T> mapper) {
        return new DynamicParameter<T>(mapper, null);
     }


    /**
     * Changes the value, which this parameter holds.
     * @param value new value
     */
     public void setValue(T value) {
        this.value = value;
     }

            /**
            * Creates an Sql representing <code>this</code>
            * @param context the Sql construction context
            * @return sql conforming to <code>this</code> syntax
            */
            public final Sql z$sqlOfDynamicParameterSpecification(SqlContext context) {
                return new Sql() {
                    @Override
                    public void appendTo(final StringBuilder builder) {
                        builder.append("?");
                    }

                    @Override
                    public void setParameters(final SqlParameters p) throws SQLException {
                        mapper.setValue(p.next(), value);
                    }

                    @Override
                    public char firstChar() {
                        return '?';
                    }
                };
            }

            /**
            * Implement in derived classes
            */
             public final Mapper<T> getMapper() {
                return mapper;
             }

}

public interface ColumnReference<T> extends Scalar<T> : Sql {}

<T> ColumnReference<T> ::=
    tableRef:Identifier PERIOD columnName:ColumnName<T>
;

import org.symqle.querybuilder.StringSql;
import org.symqle.common.Mapper;
/**
 * This class represents a database column.
 * It does not have public constructor; use {@link TableOrView#defineColumn(org.symqle.common.Mapper, String)}
 * to create an instance of Column.
 * @param <T> associated Java type. Objects of this type
 * will be returned by {@link #list(org.symqle.jdbc.QueryEngine, org.symqle.jdbc.Option...)}
 * and can be set via {@link #set(Object)} and then written to the database.
 */
public class Column<T> implements ColumnReference<T>, ColumnName<T> {
    private final String columnName;
    private final TableOrView owner;
    private final Mapper<T> mapper;

    Column(final Mapper mapper, final String name,  final TableOrView owner)  {
        this.mapper = mapper;
        this.columnName = name;
        this.owner = owner;
     }

    public final Sql z$sqlOfColumnReference(SqlContext context) {
        final String correlationName = owner.getCorrelationName(context);
        return context.get(Dialect.class).ColumnReference_is_Identifier_PERIOD_ColumnName(new StringSql(correlationName),
                z$sqlOfColumnName(context));
    }

    public final Sql z$sqlOfColumnName(final SqlContext context) {
        // make sure that owner is valid in the context
        // by getting correlation name; the result is not used
        owner.getCorrelationName(context);
        return new StringSql(columnName);
    }

    public final Mapper<T> getMapper() {
        return mapper;
    }
}


public interface RoutineInvocation<T> extends Scalar<T> : Sql {}

public class AbstractRoutineInvocation<T> implements RoutineInvocation<T> {}

<T> RoutineInvocation<T> ::=
    rn:RoutineName<T> LEFT_PAREN al:ArgumentList RIGHT_PAREN
        :: private AbstractRoutineInvocation<T> invoke
|
    rn:RoutineName<T> LEFT_PAREN RIGHT_PAREN
        :: private AbstractRoutineInvocation<T> invoke
;

::
    /**
     * Creates an expression, which represents the result of call of {@code this} with
     * given arguments.
     * @param arg the arguments
     * @return created expression
     */
  <T> AbstractRoutineInvocation<T> apply(final RoutineName<T> routine, final ValueExpression<?>... arg) {
      if (arg.length == 0) {
          return invoke(routine);
      } else {
          ArgumentList al = createArgument(arg[0]);
          int i;
          for (i = 1; i < arg.length; i++) {
              al = appendArgument(al, arg[i]);
          }
          return invoke(routine, al);
      }
  }

public interface RoutineName<T> extends Scalar<T> : Sql {}

public interface ArgumentList : Sql {}

ArgumentList ::=
    e:ValueExpression<?> :: private ArgumentList createArgument {}
|
    al:ArgumentList COMMA e:ValueExpression<?>
        :: private ArgumentList appendArgument {}
;

import org.symqle.querybuilder.StringSql;
public class SqlFunction<T> implements RoutineName<T> {
    private final String name;
    private final Mapper<T> mapper;

    private SqlFunction(final String name, final Mapper<T> mapper) {
        this.name = name;
        this.mapper = mapper;
    }

    public final Sql z$sqlOfRoutineName(SqlContext context) {
        return new StringSql(name);
    }

    public final Mapper<T> getMapper() {
        return mapper;
    }

    public static <T> SqlFunction<T> create(final String name, final Mapper<T> mapper) {
        return new SqlFunction<T>(name, mapper);
    }
}


public interface CaseExpression<T> extends Scalar<T> : Sql {}

# Case abbreviations are not included here (considering them as functions, e.g nullIf)
# only <searched case> is supported
# <searched case> ::= CASE <searched when clause>... [ <else clause> ] END

<T> CaseExpression<T> ::= CASE l:SearchedWhenClauseList<T> END :: implicit
;

public interface SearchedWhenClauseList<T> extends Scalar<T> : Sql {}

public class AbstractSearchedWhenClauseList<T> implements SearchedWhenClauseList<T> {}

<T> SearchedWhenClauseList<T> ::=
    l:SearchedWhenClauseBaseList<T> :: implicit
|
    /**
     * Creates a new conditional expression by appending {@code ELSE value} to {@code this} SQL.
     * @param elseValue the value of conditional expression if all conditions are false
     * @return constructed when clause list, which produces SQL like {@code WHEN c1 THEN v1 ... ELSE value}
     */
    l:SearchedWhenClauseBaseList<T> elseValue:ElseClause<T> :: AbstractSearchedWhenClauseList<T> orElse
;

public interface ElseClause<T> extends Scalar<T> : Sql {}

<T> ElseClause<T> ::= ELSE e:ValueExpression<T> :: implicit {}
;

public interface SearchedWhenClauseBaseList<T> extends Scalar<T> : Sql {}
public class AbstractSearchedWhenClauseBaseList<T> implements SearchedWhenClauseBaseList<T> {}

<T> SearchedWhenClauseBaseList<T> ::=
    c:SearchedWhenClause<T> :: implicit {}
|
    /**
     * Chain another conditional expression to {code this}
     * @param whenClause another when clause, see {@link BooleanExpression#then(ValueExpression)}.
     * @return constructed when clause list, which produces SQL like {@code WHEN c1 THEN v1 ELSE WHEN c2 ELSE v2...}
     */
    l:SearchedWhenClauseBaseList<T> whenClause:SearchedWhenClause<T> :: AbstractSearchedWhenClauseBaseList<T> orWhen
|
    /**
     * Chain another conditional expression to {code this}
     * @param whenClause another when clause with null value if condition is true,
     * see {@link BooleanExpression#thenNull()}.
     * @return constructed when clause list, which produces SQL like {@code WHEN c1 THEN v1 ELSE WHEN c2 ELSE NULL}
     */
    l:SearchedWhenClauseBaseList<T> whenClause:ThenNullClause :: AbstractSearchedWhenClauseBaseList<T> orWhen
;

public interface SearchedWhenClause<T> extends Scalar<T> : Sql {}
public class AbstractSearchedWhenClause<T> implements SearchedWhenClause<T> {}

<T> SearchedWhenClause<T> ::=
    /**
     * Creates a when clause {@code WHEN this THEN value}.
     * @param value the expression value when condition is true
     * @param <T> Java type associated with value
     * @return new when clause
     */
    WHEN condition:BooleanExpression THEN value:ValueExpression<T> :: AbstractSearchedWhenClause<T> then {
        private final Mapper<T> mapper = value.getMapper();
        public Mapper<T> getMapper() {
            return mapper;
        }
    }
;

public interface ThenNullClause : Sql {}

ThenNullClause ::=
    /**
     * Creates a when clause {@code WHEN this THEN NULL}.
     * @return new when clause
     */
    WHEN condition:BooleanExpression THEN NULL :: ThenNullClause thenNull {}
;

public interface CastSpecification<T> extends Scalar<T> : Sql {}

public abstract class AbstractCastSpecification<T> implements CastSpecification<T> {}

# only ValueExpression is supported, though standard allows NullSpecification (CAST (NULL AS ...))
<T> CastSpecification<T> ::=
    CAST LEFT_PAREN e:ValueExpression<T> AS target:CastTarget RIGHT_PAREN :: private AbstractCastSpecification<T> cast {
    }
;

::
    /**
     * Creates an expression equivalent to {@code CAST(this AS castTarget)}.
     * It does not affect associated Java type, this is database-side cast.
     * @param castTarget any valid database type name.
     * @return created expression
     */
    <T> AbstractCastSpecification<T> cast(final ValueExpression<T> e, final String castTarget) {
         return cast(e, new CastTarget() {
             @Override
             public Sql z$sqlOfCastTarget(final SqlContext context) {
                 return new StringSql(castTarget);
             }
         });
    }

public interface CastTarget : Sql {}

# Special ValueExpressionPrimary, which may have different names in dialects
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
ValueExpressionPrimary<Date> ::=
   /**
    * {@code current_date}.
    * @return ValueExpressionPrimary, which SQL code is {@code current_date}
    */
    CURRENT_DATE :: public AbstractValueExpressionPrimary<Date> currentDate {
      public Mapper<Date> getMapper() {
          return CoreMappers.DATE;
      }
    }
;

ValueExpressionPrimary<Timestamp> ::=
   /**
    * {@code current_timestamp}.
    * @return ValueExpressionPrimary, which SQL code is {@code current_timestamp}
    */
    CURRENT_TIMESTAMP :: public AbstractValueExpressionPrimary<Timestamp> currentTimestamp {
       public Mapper<Timestamp> getMapper() {
           return CoreMappers.TIMESTAMP;
       }
    }
;

ValueExpressionPrimary<Time> ::=
   /**
    * {@code current_time}.
    * @return ValueExpressionPrimary, which SQL code is {@code current_time}
    */
    CURRENT_TIME :: public AbstractValueExpressionPrimary<Time> currentTime {
       public Mapper<Time> getMapper() {
           return CoreMappers.TIME;
       }
    }
;


