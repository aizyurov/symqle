<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
    <bookinfo>
        <title>Symqle guide</title>
          <author>
            <firstname>Alexander</firstname>
            <surname>Izyurov</surname>
          </author>
          <copyright>
            <year>2009-2013</year><holder>Alexander Izyurov</holder>
          </copyright>
    </bookinfo>
    <preface><title>Introduction</title>
    <para>
        Symqle is a collection of Java primitives for building SQL statements. Each Symqle interface corresponds to a
        symbol of SQL language. Nethods of Symqle objects represent grammar rules of the language. So, you build more
        complex objects from more simple ones until you get the final SelectStatement of DataChangeStatement, which can be executed.
    </para>
        <para>
            The starting point is Symqle model, which describes tables and columns. The model can be generated by Symqle modeler;
            it is also very easy to write the model from scratch. It looks like
            <programlisting>
public class Person extends Table {
    public Person() {
        super("person");
    }
    public Column&lt;Long&gt; id() { return createColumn(Mappers.LONG, "person_id"); }
    public Column&lt;String&gt; lastName() { return createColumn(Mappers.STRING, "last_name"); }
    private Department departmentRef = new LazyReference() {
            public Department create() {
                Department department = new Department();
                Person.this.leftJoin(department, departmentId().eq(department.departmentId());
                return department;
        };
    public Department department() { return departmentRef.get(); }
    ...
}
public class Department extends Table  {
...
}
            </programlisting>
        </para>
        <para>
            Another basic object is Engine, which can execute queries. Typically you use DataSource-based Engine,
            you can construct it as
        <programlisting>
Engine engine = new ConnectorEngine(dataSource);
        </programlisting>
        </para>
        <para>
            Now you can construct and execute queries.
            Symqle classes typically implement multiple interfaces, so construction of "more complex" objects can be
            implicit. For example, Column class implements SelectStatement interface, so it has list(Engine, Option...) method.
            <programlisting>
List&lt;String&gt; names = new Person().lastName().list(engine);
            </programlisting>
            would return what is intuitively expected: list of all last names from "person" table.
        </para>
        <para>
            More complex example, which illustrates how Symqle methods are applied to construct queries:
            <programlisting>
Person person = new Person();
List&lt;Pair&lt;Long, String&gt;&gt; personList = person.id()
    .pair(person.lastName())
    .where(person.lastName().like("J%").and(person.department().name().eq("R&amp;D"))
    .orderBy(person.id())
    .limit(10)
    .list(engine);
            </programlisting>
            It will execute SQL statement looking like
            <programlisting>SELECT T0.id AS C0, T0.last_name AS C1 FROM person AS T0 LEFT JOIN department AS T1 WHERE T0.last_name LIKE ? AND T1.name = ?</programlisting>
            provide proper parameters and convert result set rows to Pair&lt;Long, String&gt; objects.
        </para>
        <para>
            Returned values are not limited to simple types and Pairs, you can easily convert result sets to any Java objects.
            See further chapters for full capabilities of Symqle.
        </para>
        <para>
            Symqle is not an Object-relation mapper. There are no objects, which correspond to database <emphasis>data</emphasis>.
            The objects produced by Symqle are typically simple DataTransferObjects. There is no notion of session and no caches.
            You can add caches on top of Symqle if  you need them. If your main database tasks are CRUD operations you will probably prefer
            ORM or non-SQL database. If you really need to exercise capabilities of relational database, Symqle may be better option.
        </para>
        <para>
            Symqle is designed to be efficient alternative to direct JDBC coding. It does not create any objects in the heap but a few short-living
            query builder structures (and of course resulting DTOs). It is optimized for fast query building and data conversions.
            See <link linkend="performance">Performance section</link>for comparison of Symqle and direct JDBC timings.
        </para>
        <para>
            There is no hidden code in Symqle - no dynamic proxies, instrumentation etc. - just plain inheritance and polymorphism. Query building is expressed with
            plain old java methods - enjoy auto-completion features of your favourite IDE.
        </para>

    </preface>
    <chapter><title>Building and executing statements</title>
        <sect1><title>Symqle classes and interfaces</title>
            <para>
            Each interface corresponds to an SQL language symbol.
            Most interfaces have factory methods, which build more complex objects from simpler ones. They accept other interfaces
            (or sometimes java.lang objects) as arguments and
            return instances of Symqle classes. Applying these methods, you build
            your more and more complex objects until you get an executable statement.
            There are two Symqle interfaces, which have methods for statement execution: SelectStatement and DataChangeStatement.
            </para>
            <para>

                Each symqle classes implements multiple interfaces. It allows different interpretation of a Symqle object in different contexts.
                For example, Column class is a ValueExpression and so it has method <emphasis>add</emphasis>,
                which constructs a new object, representing sum of <emphasis>this</emphasis> and its argument.
                On the other hand, Column is also a SortOrderingSpecification and can be used as an argument of <emphasis>orderBy</emphasis> method.
                Column is also a SelectStatement, so you can list values of column using its <emphasis>list</emphasis> method.
            </para>
            <para>
                Factory methods of Symqle interfaces accept interfaces as their arguments and returm instances of Symqle classes. So, return value
                implements multiple interfaces and  you have many options to continue building of statement.
            </para>
            <para>
                Each Symqle interface also has a method starting with <emphasis>z$</emphasis>. It is used internally for query building. '$" stresses that is is 'technical' method
                not intended to be called directly. 'z' is prepended to make sure that the method appears at the bottom of auto-completion list in your IDE.
            </para>
        </sect1>
        <sect1><title>Tables and columns</title>
            <para>
                Most of Symqle objects are built using factory methods, but we have something to start with.
                The starting point is a model of our database. Symqle model consists of classes, which extend TableOrView or Table class.
                The difference is that TableOrView has no methods for data change operations; Table has methods, which construct
                DataChangeStatement, see <link linkend="datachange">Data change</link> chapter.
            </para>
            <para>
                Tables define their columns, usually as accessor methods. Tables may also provide methods, which return other tables joined to
                this table - see <link linkend="autojoins">Auto joins</link>
            </para>
            <para>
                Other primitive elements, which can be used for query construction, are dynamic parameters and
                SQL functions.
            </para>
        </sect1>
        <sect1><title>SelectStatement and DataChangeStatement structure</title>
            <para>
                SelectStatement basically consists of 3 parts. First, you define <link linkend="select">what</link> you are selecting.
                It may be any java object. If you need a single column or a couple of columns, Symqle will make all necessary data conversions for you.
                If it is more comlex object, you have to decide the conversion algorithm yourself. Symqle provides <link linkend="selectors">abstract classes</link>,
                which make this task easy.
                Then you may apply <link linkend="where">where clause</link> and/or <link linkend="orderby">order by clause</link> to the result.
                Additionally, you can use <link linkend="limit">limit and offset</link> and <link linkend="forupdate">for update</link>.
                GROUP BY and HAVING are not supported by Symqle.
                Note that you do not have to construct FROM clause. Symqle generates it <link linkend="from">automatically</link> based on the columns involved to
                SELECT, WHERE and ORDER BY and joins defined by you or created automatically.
            </para>
            <para>
                DataChangeStatements are created by methods of Table class. It has <link linkend="insert">insert</link>,
                <link linkend="update">update</link> and <link linkend="delete">delete</link> methods.
                Update and insert methods require  <link linkend="setclauselist">SetClausList</link> argument.
                The objects returned by
                update and delete have <emphasis>where</emphasis> method to identify which columns will be updated/deleted.
            </para>
        </sect1>
        <sect1 id="execution">
            <para>
                To execute a statement, you need an <link linkend="engine">Engine</link> - an object, which connects Symqle ot jdbc layer.
                Usually it is DataSource-based. SelectStatement has <link linkend="list">list and scroll</link> methods. the first just returns a list
                of objects. The second calls your Callback, providing one object at a time. It is more memory-saving if you need not the whole collection -
                for example, you make some calculations or write the objects to a stream.
            </para>
            <para>
                DataChangeStatement has an <link linkend="execute">execute</link> method. <link linkend="batching">JDBC batching</link> is also supported.
            </para>
            <para>
                Statement execution methods accept Option arguments. Engine constructor also has <emphasis>options</emphasis> argument.
                There are 2 kinds of options: the query builder options and statement execution options. Options provided to Engine constructor
                are applied to all statements executed with this engine. They may be overridden for a particular statement.
            </para>
            <para>
                Query builder options affect the construction of <link linkend="from">FROM clause</link> and are described in corresponding chapter.
            </para>
            <para>
                Statement execution options are passed to Statement before execution. They are constructed by static methods of Option class:
                <code>setFetchDirection</code>, <code>setFetchSize</code>, <code>setQueryTimeout</code>, <code>setMaxRows</code>, <code>setMaxFieldSize</code>.
                See API documentation for detail.
            </para>
        </sect1>
    </chapter>
    <chapter id="select"><title>Building SELECT clause</title>
        <sect1 id="typeparameters">
            <title>Symqle objects have type parameters</title>
            <para>
                Symqle objects, which can participate in SELECT clause, always have type parameters. The type parameter
                defines the Java class, to which this object will be converted when appears in the results set.
            </para>
        </sect1>
        <sect1>
            <title>Primary value expressions</title>

        </sect1>
        <sect1>
            <title>Arithmetic expressions</title>
        </sect1>
        <sect1>
            <title>String expressions</title>
        </sect1>
        <sect1>
            <title>Boolean expressions</title>
        </sect1>
        <sect1>
            <title>Subqueries</title>
        </sect1>
        <sect1>
            <title>Functions</title>
        </sect1>
        <sect1 id="pair">
            <title>Pairs</title>
            TODO include code re-use here
        </sect1>
        <sect1 id="selectors">
            <title>Selectors</title>
            TODO include code re-use here
        </sect1>
        <sect1>
            <title>Cast and map</title>
        </sect1>
    </chapter>
    <chapter id="where"><title>Building WHERE clause</title>
        <sect1>
            <title>Predicates</title>
        </sect1>
        <sect1>
            <title>Boolean expressions</title>
        </sect1>
    </chapter>
    <chapter id="from"><title>FROM clause</title>
        <sect1>
            <title>How Symqle build FROM clause</title>
        </sect1>
    </chapter>
    <chapter id="orderby"><title>ORDER BY</title>
    </chapter>
    <chapter><title>Set operations</title>
    </chapter>
    <chapter><title>Building select statement</title>
        <sect1 id="limit">
            <title>Offset and limit</title>
        </sect1>
        <sect1 id="forupdate">
            <title>FOR UPDATE and FOR READ ONLY</title>
        </sect1>
        <sect1 id="list">
            <title>List and scroll</title>
        </sect1>
        <sect1>
            <title>Statement options</title>
        </sect1>
    </chapter>
    <chapter><title>Aggregate functions</title>
    </chapter>
    <chapter><title>Collections</title>
    </chapter>
    <chapter id="datachange"><title>Data change statements</title>
        <sect1 id="update">
            <title>Update</title>
        </sect1>
        <sect1 id="setclauselist">
            <title>Update</title>
        </sect1>
        <sect1 id="insert">
            <title>Insert</title>
        </sect1>
        <sect1 id="delete">
            <title>Delete</title>
        </sect1>
        <sect1 id="execute">
            <title>Execution of data change statements</title>
        </sect1>
    </chapter>
    <chapter id="model"><title>Symqle model</title>
        <sect1>
            <title>Using modeler</title>
        </sect1>
        <sect1>
            <title>Writing model manually</title>
        </sect1>
        <sect1 id="autojoins">
            <title>Auto joins</title>
        </sect1>
        <sect1>
            <title>Derived tables</title>
        </sect1>
    </chapter>
    <chapter><title>Increasing performance</title>
        <sect1 id="batching">
            <title>Batching</title>
        </sect1>
        <sect1>
            <title>Pre-compiled statements</title>
        </sect1>
    </chapter>
    <chapter><title>Transactions</title>
        <sect1>
            <title>TODO</title>
        </sect1>
    </chapter>
    <chapter id="engine"><title>Engine</title>
        <sect1>
            <title>Creating engine</title>
        </sect1>
    </chapter>
    <chapter><title>Exceptions</title>
        <sect1>
            <title>TODO</title>
        </sect1>
    </chapter>
    <chapter><title>Extending Symqle</title>
        <sect1>
            <title>TODO</title>
        </sect1>
    </chapter>
    <chapter><title>Supported databases</title>
        <sect1>
            <title>TODO</title>
        </sect1>
    </chapter>
    <chapter xreflabel="Performance" id="performance"><title>Performance</title>
        <sect1>
            <title>TODO</title>
        </sect1>
    </chapter>
</book>

