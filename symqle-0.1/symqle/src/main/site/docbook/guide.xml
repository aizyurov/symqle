<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
    <bookinfo>
        <title>Symqle guide</title>
          <author>
            <firstname>Alexander</firstname>
            <surname>Izyurov</surname>
          </author>
          <copyright>
            <year>2009-2013</year><holder>Alexander Izyurov</holder>
          </copyright>
    </bookinfo>
    <preface><title>Introduction</title>
    <para>
        Symqle is a collection of Java primitives for building SQL statements. Each Symqle interface corresponds to a
        symbol of SQL language. Nethods of Symqle objects represent grammar rules of the language. So, you build more
        complex objects from more simple ones until you get the final SelectStatement of DataChangeStatement, which can be executed.
    </para>
        <para>
            The starting point is Symqle model, which describes tables and columns. The model can be generated by Symqle modeler;
            it is also very easy to write the model from scratch. It looks like
            <programlisting>
public class Person extends Table {
    public Person() {
        super("person");
    }
    public Column&lt;Long&gt; id() { return createColumn(Mappers.LONG, "person_id"); }
    public Column&lt;String&gt; lastName() { return createColumn(Mappers.STRING, "last_name"); }
    private Department departmentRef = new LazyReference() {
            public Department create() {
                Department department = new Department();
                Person.this.leftJoin(department, departmentId().eq(department.departmentId());
                return department;
        };
    public Department department() { return departmentRef.get(); }
    ...
}
public class Department extends Table  {
...
}
            </programlisting>
        </para>
        <para>
            Another basic object is Engine, which can execute queries. Typically you use DataSource-based Engine,
            you can construct it as
        <programlisting>
Engine engine = new ConnectorEngine(dataSource);
        </programlisting>
        </para>
        <para>
            Now you can construct and execute queries.
            Symqle classes typically implement multiple interfaces, so construction of "more complex" objects can be
            implicit. For example, Column class implements SelectStatement interface, so it has list(Engine, Option...) method.
            <programlisting>
List&lt;String&gt; names = new Person().lastName().list(engine);
            </programlisting>
            would return what is intuitively expected: list of all last names from "person" table.
        </para>
        <para>
            More complex example, which illustrates how Symqle methods are applied to construct queries:
            <programlisting>
Person person = new Person();
List&lt;Pair&lt;Long, String&gt;&gt; personList = person.id()
    .pair(person.lastName())
    .where(person.lastName().like("J%").and(person.department().name().eq("R&amp;D"))
    .orderBy(person.id())
    .limit(10)
    .list(engine);
            </programlisting>
            It will execute SQL statement looking like
            <programlisting>SELECT T0.id AS C0, T0.last_name AS C1 FROM person AS T0 LEFT JOIN department AS T1 WHERE T0.last_name LIKE ? AND T1.name = ?</programlisting>
            provide proper parameters and convert result set rows to Pair&lt;Long, String&gt; objects.
        </para>
        <para>
            Returned values are not limited to simple types and Pairs, you can easily convert result sets to any Java objects.
            See further chapters for full capabilities of Symqle.
        </para>
        <para>
            Symqle is not an Object-relation mapper. There are no objects, which correspond to database <emphasis>data</emphasis>.
            The objects produced by Symqle are typically simple DataTransferObjects. There is no notion of session and no caches.
            You can add caches on top of Symqle if  you need them. If your main database tasks are CRUD operations you will probably prefer
            ORM or non-SQL database. If you really need to exercise capabilities of relational database, Symqle may be better option.
        </para>
        <para>
            Symqle is designed to be efficient alternative to direct JDBC coding. It does not create any objects in the heap but a few short-living
            query builder structures (and of course resulting DTOs). It is optimized for fast query building and data conversions.
            See <link linkend="performance">Performance section</link>for comparison of Symqle and direct JDBC timings.
        </para>
        <para>
            There is no hidden code in Symqle - no dynamic proxies, instrumentation etc. - just plain inheritance and polymorphism. Query building is expressed with
            plain old java methods - enjoy auto-completion features of your favourite IDE.
        </para>

    </preface>
    <chapter><title>Symqle classes and interfaces</title>

    </chapter>
    <chapter><title>Building SELECT clause</title>
        <sect1>
            <title>Primary value expressions</title>

        </sect1>
        <sect1>
            <title>Arithmetic expressions</title>
        </sect1>
        <sect1>
            <title>String expressions</title>
        </sect1>
        <sect1>
            <title>Boolean expressions</title>
        </sect1>
        <sect1>
            <title>Subqueries</title>
        </sect1>
        <sect1>
            <title>Functions</title>
        </sect1>
        <sect1>
            <title>Selectors</title>
            TODO include code re-use here
        </sect1>
        <sect1>
            <title>Cast and map</title>
        </sect1>
    </chapter>
    <chapter><title>Building WHERE clause</title>
        <sect1>
            <title>Predicates</title>
        </sect1>
        <sect1>
            <title>Boolean expressions</title>
        </sect1>
    </chapter>
    <chapter><title>FROM clause</title>
        <sect1>
            <title>How Symqle build FROM clause</title>
        </sect1>
    </chapter>
    <chapter><title>ORDER BY</title>
    </chapter>
    <chapter><title>Set operations</title>
    </chapter>
    <chapter><title>Building select statement</title>
        <sect1>
            <title>Offset and limit</title>
        </sect1>
        <sect1>
            <title>FOR UPDATE and FOR READ ONLY</title>
        </sect1>
        <sect1>
            <title>List and scroll</title>
        </sect1>
        <sect1>
            <title>Statement options</title>
        </sect1>
    </chapter>
    <chapter><title>Aggregate functions</title>
    </chapter>
    <chapter><title>Collections</title>
    </chapter>
    <chapter><title>Data change statements</title>
        <sect1>
            <title>Update</title>
        </sect1>
        <sect1>
            <title>Insert</title>
        </sect1>
        <sect1>
            <title>Batching</title>
        </sect1>
    </chapter>
    <chapter><title>Symqle model</title>
        <sect1>
            <title>Using modeler</title>
        </sect1>
        <sect1>
            <title>Derived tables</title>
        </sect1>
    </chapter>
    <chapter><title>Transactions</title>
        <sect1>
            <title>TODO</title>
        </sect1>
    </chapter>
    <chapter><title>Extending Symqle</title>
        <sect1>
            <title>TODO</title>
        </sect1>
    </chapter>
    <chapter><title>Supported databases</title>
        <sect1>
            <title>TODO</title>
        </sect1>
    </chapter>
    <chapter xreflabel="Performance" id="performance"><title>Performance</title>
        <sect1>
            <title>TODO</title>
        </sect1>
    </chapter>
</book>

